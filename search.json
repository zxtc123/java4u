[{"title":"RUST入门","url":"/java4u/2023/05/16/RUST%E5%85%A5%E9%97%A8/","content":"RUST入门","categories":["编程语言"],"tags":["学习"]},{"title":"人工智能入门","url":"/java4u/2023/04/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%85%A5%E9%97%A8/","content":"人工智能入门机器学习基础机器学习是一门专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身性能的学科。列举一些机器学习经典的场景：\n\n搜索引擎：根据搜索和使用习惯，优化下一次搜索的结果。\n电商网站：自动推荐你可能感兴趣的商品。\n贷款申请：通过你最近的金融活动信息进行综合评定。\n图像识别：自动识别图片中有没有不和谐的内容。\n\n机器学习可以分为监督学习和非监督学习。监督学习是从给定的训练数据集中学习得到一个函数，当新的数据到来时，可以根据这个函数预测结果，监督学习的训练集包括输入和输出，也可以说是特征和目标。监督学习的目标是由人来标注的，而非监督学习的数据没有类别信息，训练集也没有人为标注结果，通过无监督学习可以减少数据特征的维度，以便我们可以使用二维或三维图形更加直观地展示数据信息 。\n实现机器学习的一般步骤：\n\n数据收集\n数据准备\n数据分析\n训练算法\n测试算法\n应用算法\n\n一. 引言日常生活机器学习通过语音唤醒Siri。收集一个包含大量音频样本的数据集（dataset），定义一个灵活的程序算法，其输出由许多参数决定。 任一调整参数后的程序被称为模型（model）。通过操作参数而生成的所有不同程序（输入-输出映射）的集合称为“模型族”。使用数据集来选择参数的元程序被称为学习算法（learning algorithm）。\n1. 监督学习监督学习一般分为3步：\n\n从已知大量数据样本中随机选取一个子集，为每个样本获取真实标签。有时，这些样本已有标签（例如，患者是否在下一年内康复？）；有时，这些样本可能需要被人工标记（例如，图像分类）。这些输入和相应的标签一起构成了训练数据集；\n选择有监督的学习算法，它将训练数据集作为输入，并输出一个“已完成学习的模型”；\n将之前没有见过的样本特征放到这个“已完成学习的模型”中，使用模型的输出作为相应标签的预测。\n\n\n1.1 回归当标签取任意数值时，我们称之为回归问题，此时的目标是生成一个模型，使它的预测非常接近实际标签值。任何有关“有多少”的问题很可能就是回归问题。比如：\n\n这个手术需要多少小时；\n在未来6小时，这个镇会有多少降雨量。\n\n1.2 分类分类问题希望模型能够预测样本属于哪个类别（category，正式称为类（class））。 例如，手写数字可能有10类，标签被设置为数字0～9。 最简单的分类问题是只有两类，这被称之为二项分类（binomial classification）。 例如，数据集可能由动物图像组成，标签可能是猫狗{猫,狗}两类。 回归是训练一个回归函数来输出一个数值； 分类是训练一个分类器来输出预测的类别。\n1.3 标记问题学习预测不相互排斥的类别的问题称为多标签分类（multi-label classification）。举个例子，人们在技术博客上贴的标签，比如“机器学习”“技术”“小工具”“编程语言”“Linux”“云计算”“AWS”。 一篇典型的文章可能会用5～10个标签，因为这些概念是相互关联的。 关于“云计算”的帖子可能会提到“AWS”，而关于“机器学习”的帖子也可能涉及“编程语言”。\n\n1.4 搜索有时，我们不仅仅希望输出一个类别或一个实值。 在信息检索领域，我们希望对一组项目进行排序。 以网络搜索为例，目标不是简单的“查询（query）-网页（page）”分类，而是在海量搜索结果中找到用户最需要的那部分。\n1.5 推荐系统它的目标是向特定用户进行“个性化”推荐。 例如，对于电影推荐，科幻迷和喜剧爱好者的推荐结果页面可能会有很大不同。 类似的应用也会出现在零售产品、音乐和新闻推荐等等。\n\n1.6 序列学习如果输入是连续的，模型可能就需要拥有“记忆”功能。 比如，我们该如何处理视频片段呢？ 在这种情况下，每个视频片段可能由不同数量的帧组成。 通过前一帧的图像，我们可能对后一帧中发生的事情更有把握。 语言也是如此，机器翻译的输入和输出都为文字序列。\n2. 无监督学习如果工作没有十分具体的目标，就需要“自发”地去学习了。 比如，老板可能会给我们一大堆数据，然后要求用它做一些数据科学研究，却没有对结果有要求。 这类数据中不含有“目标”的机器学习问题通常被为无监督学习（unsupervised learning）\n3. 与环境互动不管是监督学习还是无监督学习，我们都会预先获取大量数据，然后启动模型，不再与环境交互。 这里所有学习都是在算法与环境断开后进行的，被称为离线学习（offline learning）。这种简单的离线学习有它的魅力。 好的一面是，我们可以孤立地进行模式识别，而不必分心于其他问题。 但缺点是，解决的问题相当有限。 这时我们可能会期望人工智能不仅能够做出预测，而且能够与真实环境互动。 \n4. 强化学习在强化学习问题中，智能体（agent）在一系列的时间步骤上与环境交互。 在每个特定时间点，智能体从环境接收一些观察（observation），并且必须选择一个动作（action），然后通过某种机制（有时称为执行器）将其传输回环境，最后智能体从环境中获得奖励（reward）。 此后新一轮循环开始，智能体接收后续观察，并选择后续操作，依此类推。 \n\n小结\n机器学习研究计算机系统如何利用经验（通常是数据）来提高特定任务的性能。它结合了统计学、数据挖掘和优化的思想。通常，它是被用作实现人工智能解决方案的一种手段。\n表示学习作为机器学习的一类，其研究的重点是如何自动找到合适的数据表示方式。深度学习是通过学习多层次的转换来进行的多层次的表示学习。\n深度学习不仅取代了传统机器学习的浅层模型，而且取代了劳动密集型的特征工程。\n最近在深度学习方面取得的许多进展，大都是由廉价传感器和互联网规模应用所产生的大量数据，以及（通过GPU）算力的突破来触发的。\n整个系统优化是获得高性能的关键环节。有效的深度学习框架的开源使得这一点的设计和实现变得非常容易。\n\n二. 预备知识2.1 数据操作","categories":["AI"],"tags":["学习"]},{"title":"linux深入了解","url":"/java4u/2023/02/01/linux%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/","content":"常用指令文件目录\ncat 查看文件内容\nmore 文本过滤器\nless 与more相似，大型文件具有较高效率\n**&gt;**覆盖 **&gt;&gt;**追加\nln 软链接 target linkname\nhistory 查看已经执行的历史命令 history 10 最近10个指令  !10 执行第10条指令\n\n时间日期\ndate 展示时间  date “+%Y-%m-%d %H:%M:%S”  定义格式\ndate -s “2022-02-04 11:19:20” 修改系统时间\ncal 查看日历 [2023] 展示整年日历\n\n查找\nfind [搜索范围] [选项] 从指定目录向下递归搜索\n-name 按照文件名查找\n-user  查找属于指定用户的文件\n-size 指定文件大小查找 (+n大于 -n小于 n等于)\n\n\nlocate 可以快速定位文件路径，第一次运行必须使用updatedb创建locate数据库\ngrep [选项] 查找内容 源文件, 过滤查询\n\n压缩和解压\ngzip&#x2F;gunzip   压缩成*.gz文件\n\nzip&#x2F;unzip   压缩文件或文件夹成*.zip\n\ntar  打包指令，打包文件是.tar.gz\n\n-c 产生.tar打包文件\n-v 显示详细信息\n-f 指定压缩后文件名\n-z 打包同时压缩\n-x 解包.tar文件\n\n压缩多个文件，将a.txt和b压缩成ab.tar.gz\ntar -zcvf ab.tar.gz a.txt b\n\n解压ab.tar.gz\ntar -zxvf ab.tar.gz\n\n组管理和权限管理\nchown 用户名 文件名    修改文件所有者\n\nchgrp 组名 文件名  修改文件所在组\n\nusermod -g 新组名 用户名   改变用户所在组\n\nchmod 修改权限\n\n+&#x2F;-&#x2F;&#x3D;变更权限\nu所有者 g所有组 o其他人 a所有人\nchmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件&#x2F;目录名\nchmod o+w 文件&#x2F;目录名  给其他人赋予写的权限\nchmod a-x 文件&#x2F;目录名 所有人去除执行的权限\n\n通过数字变更权限\nr&#x3D;4,w&#x3D;2,x&#x3D;1（1x,2w,3wx,4r,5rx,6rw,7rwx）\nchmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件&#x2F;目录名\n相当于 chmod 751 文件&#x2F;目录名\n\n\n\n\n权限说明drwxr-xr-x01234567891.第0位确认文件类型(d,-,l,c,b)\tl链接\td目录\tc字符设备，鼠标，键盘\tb块设备，硬盘\t-文件2.第1-3确认文件所有者拥有该文件的权限 --User3.第4-6确认文件所属组拥有该文件的权限 --Group4.第7-9确认其他用户拥有该文件的权限 --Otherrwx作用到文件1.[r]可读2.[w]可写，不代表可删，删除文件需要对所在目录有写的权限3.[x]可执行rwx作用到目录1.[r]可读，可以列出目录下的文件2.[w]可写，对目录内创建，删除，重命名3.[x]可执行，可以进入该目录\n\n定时任务调度\ncrontab [-e]编辑crontab定时任务 [-l]查询crontab 任务 [-r]删除当前用户所有的crontab 任务\n\ncron表达式第一个*  一小时中第几分钟  0-59第二个*  一天中第几小时    0-23第三个*  一个月中第几天    1-31第四个*  一年中第几月      1-12第五个*  一周中星期几      0-7（0/7都代表星期日）* 代表任何时间，代表不连续的时间- 代表连续的时间*/n  代表每隔多久执行一次\n\n\nat [选项] [时间] 一次性定时任务\n1.接受当天的hh:mm（小时：分钟），如果时间过去，明天执行2.midenight,non,teatime等模糊时间3.12小时制 12pm4.命令执行具体时间 5.相对计时 2天后下午5点  \tat 5pm + 2 days6.直接使用today/tomorrow   明天下午5点\tat 5pm tomorrow\n\n磁盘分区\nlsblk [-f] 查看设备挂载情况\n\nfdisk &#x2F;dev&#x2F;sdb   分区命令\n\nmkfs -t ext4 &#x2F;dev&#x2F;sdb1   格式化磁盘\n\nmount &#x2F;dev&#x2F;sdb1 &#x2F;newdisk  挂载文件系统\n\ndf -h 磁盘情况查询\n\ndu 查询指定目录磁盘占用情况\n\n-s 指定目录\n-h 带计量单位\n-a 带上文件\n-c 汇总\n–max-depth&#x3D;1 子目录深度\n\n查询/opt下文件的个数(过滤出以“-”开头的就是文件)ls -l /opt | grep &quot;^-&quot; | wc -l查询/opt文件个数包括子目录ls -lR /opt | grep &quot;^-&quot; | wc -l树型展示目录结构tree /opt\n\n进程管理\nps 查看系统中的进程\n-a 显示当前终端所有进程信息\n-u 以用户格式显示进程信息\n-x 显示后台进程运行的参数\n-e显示所有进程 -f 全格式。显示所有进程，可以查看进程的父进程\n\n\nkill [选项] 进程号  终止进程 -9 强制进程终止\nkillall  进程名  通过进程名杀死进程，支持通配，也会杀死子进程\npstree 更加直观展示进程\n-p 展示pid\n-u 显示进程所属用户\n\n\n\n服务管理\nservice [start|stop|restart|reload|status] 服务名\nsystemctl get-default 获取运行级别\nsystemctl [start|stop|restart|reload|status] 服务名\n管理的服务在&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system查看\nsystemctl list-unit-filessystemctl  查看服务自启动状态\nsystemctl enable(disable)  开启或关闭服务自启动\nsystemctl is-enabled 服务名   查看服务自启动状态\n\n\nfirewall 防火墙\n打开端口 firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;协议\n关闭端口 firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;协议\n重新载入才能生效 firewall-cmd –reload\n查询端口是否开放  firewall-cmd –query-port&#x3D;端口号&#x2F;协议\n\n\ntop 动态监控 [-p 监控指定进程ID] [-d 刷新间隔]\nP 以CPU使用率排序\nM 以内存使用率排序\nu 监控指定用户\nk 终止指定的进程\n\n\nnetstat 监控网络状态 [-p 展示那个进程在调用] [-an 按一定顺序排列]\n\n软件包管理\nrpm\n\n查询已安装的rpm  rpm -qa | grep xx\nfirefox-60.2.2-1.el7.centos.x86_64\nfirefox 名称\n60.2.2-1 版本号\nel7.centos.x86_64  适用操作系统 noarch适用通用版本\n\n\nrpm -q 软件包  查询软件包是否安装\nrpm -e 软件包   卸载\nrpm -ivh RPM包全路径名称\n\n\nyum 能够从指定服务器自动下载RPM包并安装\n\nyum list | grep xx软件列表   查询yum服务器是否有需要安装的软件\nyum install xxx   下载安装\n\n\napt \n\n&#x2F;etc&#x2F;apt&#x2F;sources.list  服务器地址\n\napt软件操作\nsudo apt-get update 更新源sudo apt-get install package  安装包sudo apt-get remove package 删除包sudo apt-cache show package 获取包相关信息，如说明/大小/版本等sudo apt-get source package 下载该包的源代码\n\n\n\nshell\n位置参数\n\n$n $0命令本身，$1-$9代表第一到第九个参数，十以上${10}\n$* 代表命令行中所有参数整体对待\ns@ 命令行中所有参数分别对待\ns# 命令行中参数个数\n\n\n预定义变量\n\n$$  当前进程的进程号\n$!   后台运行的最后一个进程的进程号\n$?  最后一次执行命令返回状态，返回0证明上一个命令正确执行\n\n\n运算符\n\n$((运算符)) 或 $[运算符] expr m + n\n\n\n条件判断\n\n判断语句 [ condition ] (condition前后要有空格)\n&#x3D; 字符串比较\n2个整数比较\n-lt 小于\nle 小于等于\neq 等于\ngt 大于\nge 大于等于 \nne 不等于\n\n\n按照文件权限进行判断\n-r 有读的权限\n-w 有写的权限\n-x 有执行的权限\n\n\n按照文件类型进程判断\n-f 文件存在并且是一个常规文件\n-e 文件存在\n-d 文件存在并是一个目录\n\n\n\n\ncase\n#!/bin/bashcase $1 in&quot;1&quot;)        echo &quot;monday&quot;;;&quot;2&quot;)        echo &quot;tusday&quot;;;*)        echo &quot;other&quot;;;esac\n\nfor循环\n\n基本语法1\nfor 变量 in 值1 值2 值3\ndo\n程序\ndone\n\n基本语法2\nfor (( 初始值;循环控制条件;变量变化 ))\ndo\n程序\ndone\n\n\n\nwhile循环\nwhile [ condition ]\ndo\n程序\ndone\n\nread 读取控制台输入\n-p 指定读取值时的提示符\n-t 指定读取时等待的时间\n\n函数\n\n系统函数 basename\n返回完整路径最后&#x2F;的部分，常用于获取文件名\ndirname 返回完整路径最后&#x2F;前面的部分，用于返回路径\n\n自定义函数\n#!/bin/bashfunction getSum()&#123;        SUM=$[$num1+$num2]        echo &quot;sum=$SUM&quot;&#125;read -p &quot;请输入第一个数num1=&quot; num1read -p &quot;请输入第二个数num2=&quot; num2getSum $num1 $num2\n\n\n\n日志\n查看内存日志\njournalctl -n 3 查看最新3条\njournalctl –since 19:00 –until 19:10:10 查看时间区间\njournalctl -p err 报错日志\njournalctl -o verbose 日志详细内容\njournalctl _PID&#x3D;1245 _COMM&#x3D;sshd  查看包含这些参数的日志\n\n\n备份与恢复\ndump 对分区支持增量备份\ndump -0j -f &#x2F;opt&#x2F;etc.bak.bz2 &#x2F;etc\n\nrestore 用来恢复已备份的文件\nrestore [模式选项] [选项]\n四种模式不能混用\n\n-C 对比模式，将备份文件与已存在文件相互对比\n-i 使用交互模式，进行还原时，restore 指令依序询问用户\n-r 还原模式：如果有增量备份，需要把增量文件也按照顺序进行恢复\n-t 查看模式，看备份文件有哪些文件\n\n选项\n\n-f 从指定文件中读取备份数据进行还原\n\n\n\n","categories":["linux"],"tags":["学习"]},{"title":"FastAPI","url":"/java4u/2023/01/22/FastAPI/","content":"FastAPI高性能的异步web框架，使用Pydantic作为数据模型，Uvicorn作为ASGI服务器\n请求参数的解析与验证路径参数与数字验证@app03.get(&quot;/path/&#123;parameters&#125;&quot;)  # 函数的顺序就是路由的顺序def path_prams02(parameters: str):    return &#123;&quot;message&quot;: parameters&#125;\n\n支持枚举类，使用Path作为路径参数的校验\n查询参数和字符串验证@app03.get(&quot;/query/validations&quot;)  # 长度+正则表达式验证，比如长度8-16位，以a开头。其它校验方法看Query类的源码def query_params_validate(    value: str = Query(..., min_length=8, max_length=16, regex=&quot;^a&quot;),  # ...换成None就变成选填的参数    values: List[str] = Query([&quot;v1&quot;, &quot;v2&quot;], alias=&quot;alias_name&quot;)):  # 多个查询参数的列表。参数别名    return value, values\n\nGET请求中不属于路径参数的就是查询参数，使用Query作为查询参数校验\n请求体和字段class CityInfo(BaseModel):    name: str = Field(..., example=&quot;Beijing&quot;)  # example是注解的作用，值不会被验证    country: str    country_code: str = None  # 给一个默认值    country_population: int = Field(default=800, title=&quot;人口数量&quot;, description=&quot;国家的人口数量&quot;, ge=800)    class Config:        schema_extra = &#123;            &quot;example&quot;: &#123;                &quot;name&quot;: &quot;Shanghai&quot;,                &quot;country&quot;: &quot;China&quot;,                &quot;country_code&quot;: &quot;CN&quot;,                &quot;country_population&quot;: 1400000000,            &#125;        &#125;@app03.post(&quot;/request_body/city&quot;)def city_info(city: CityInfo):    print(city.name, city.country)  # 当在IDE中输入city.的时候，属性会自动弹出    return city.dict()\n\npost&#x2F;put请求，可以直接设置传入的模型，Pydantic模型的字段使用Field校验\n响应及数据处理响应模型@app04.post(&quot;/response_model/&quot;, response_model=UserOut, response_model_exclude_unset=True)async def response_model(user: UserIn):    &quot;&quot;&quot;response_model_exclude_unset=True表示默认值不包含在响应中，仅包含实际给的值，如果实际给的值与默认值相同也会包含在响应中&quot;&quot;&quot;    print(user.password)  # password不会被返回    # return user    return users[&quot;user01&quot;]\n\n通过response_model设置响应模型\n响应状态码@app04.post(&quot;/status_attribute&quot;, status_code=status.HTTP_200_OK)async def status_attribute():    print(type(status.HTTP_200_OK))    return &#123;&quot;status_code&quot;: status.HTTP_200_OK&#125;\n\n单文件&#x2F;多文件上传及参数详解@app04.post(&quot;/upload_files&quot;)async def upload_files(files: List[UploadFile] = File(...)):  # 如果要上传单个文件 file: UploadFile = File(...)    &quot;&quot;&quot;    使用UploadFile类的优势:    1.文件存储在内存中，使用的内存达到阈值后，将被保存在磁盘中    2.适合于图片、视频大文件    3.可以获取上传的文件的元数据，如文件名，创建时间等    4.有文件对象的异步接口    5.上传的文件是Python文件对象，可以使用write(), read(), seek(), close()操作    &quot;&quot;&quot;    for file in files:        contents = await file.read()        print(contents)    return &#123;&quot;filename&quot;: files[0].filename, &quot;content_type&quot;: files[0].content_type&#125;\n\n错误处理@app04.get(&quot;/http_exception&quot;)async def http_exception(city: str):    if city != &quot;Beijing&quot;:        raise HTTPException(status_code=404, detail=&quot;City not found!&quot;, headers=&#123;&quot;X-Error&quot;: &quot;Error&quot;&#125;)    return &#123;&quot;city&quot;: city&#125;\n\n依赖注入作用：代码复用，共用数据库连接\n函数作为依赖async def common_parameters(q: Optional[str] = None, page: int = 1, limit: int = 100):    return &#123;&quot;q&quot;: q, &quot;page&quot;: page, &quot;limit&quot;: limit&#125;@app05.get(&quot;/dependency01&quot;)async def dependency01(commons: dict = Depends(common_parameters)):    return commons\n\n类作为依赖class CommonQueryParams:    def __init__(self, q: Optional[str] = None, page: int = 1, limit: int = 100):        self.q = q        self.page = page        self.limit = limit@app05.get(&quot;/classes_as_dependencies&quot;)# async def classes_as_dependencies(commons: CommonQueryParams = Depends(CommonQueryParams)):# async def classes_as_dependencies(commons: CommonQueryParams = Depends()):async def classes_as_dependencies(commons=Depends(CommonQueryParams)):    response = &#123;&#125;    if commons.q:        response.update(&#123;&quot;q&quot;: commons.q&#125;)    items = fake_items_db[commons.page: commons.page + commons.limit]    response.update(&#123;&quot;items&quot;: items&#125;)    return response\n\n带yield的依赖async def get_db():    db = DBSession()    try:        yield db    finally:        db.close()\n\nyield在发送响应之前，只执行包含该语句之前的代码,获取数据库连接,yield响应传递后执行语句后面的代码，使用finally确保执行退出步骤\n","categories":["框架"],"tags":["学习"]},{"title":"django Rest Framework","url":"/java4u/2022/12/17/DRF/","content":"Serializer将django的数据结构转化成json和xml，或将前端传来的json转化成django数据结构\n作用：\n\n对数据进行转换\n进行数据的校验\n同时序列化多个对象\n序列化的过程中添加上下文\n无效的数据异常处理\n\n序列化将模型转换成字典\nSerializer：serializers.PrimaryKeyRelatedField  将关联模型的id序列化serializers.StringRelatedField      将关联模型的__str__方法返回值序列化UserSerializer                      将关联模型对象的序列化器中所有字段序列化出来一关联序列化多  user_set &#x3D; UserSerializer(many &#x3D; true)  一关联多时，需要设定many&#x3D;true,多的数据默认放在 模型名小写_set 这个隐藏字段\n反序列化拿到前端传入的数据–》调用序列化器的is_valid()进行校验–》调用序列化器的save(),调用save()方法时会判断当初创建序列化器时是否传入instance–》反序列化最后会自动完成序列化（返回新增和修改操作的数据）\ns.is_valid(raise_exception&#x3D;True) 校验失败直接抛出异常\n定义自定义校验逻辑validate_字段名称(self, value)  单独校验字段valuevalidate(self, attrs)          对多个字段联合校验\n序列化器的create和update方法serializer.save()   #当调用序列化器的save()方法，会执行序列化器中的create或update方法\ndef create(self, validated_date):    book &#x3D; BookInfo.objects.create(**validated_date)     #将字典变成关键字参数    return book\n当调用序列化器的save方法时，没有给instance传参数，调用序列化器的create\ndef update(self, instance, validated_date):    instance.btitle &#x3D; validated_date.get(‘btitle’)    instance.bpub_date &#x3D; validated_date.get(‘bpub_date’)    instance.save()    return instance\n当调用序列化器的save方法时，给instance传参数，调用序列化器的update\nModelSerializer 模型序列化器\n序列化的字段一般与模型字段相对应，使用模型序列化器可以不写字段，会自动生成\nModelSerializer已经实现了create和update方法\n\nclass Meta:  model &#x3D; BookInfo  # 指定序列化器字段从那个模型去映射  fields &#x3D; ‘all‘  # 指定映射所有字段  fields &#x3D; [‘id’,’btitle’] # 指定映射指定字段  exclude &#x3D; [‘image’]  # 指定排除映射字段  extra_kwargs &#x3D; {  # 修改生成字段的选项参数    ‘bread’: {‘min_value’: 0, ‘write_only’: True}  }  read_only_fields &#x3D; [‘id’, ‘bread’] # 指定哪些字段只作序列化\nHyperlinkedModelSerializer  超链接模型序列化器返回数据带上请求该资源的url\n视图函数式编程 Function Based View类视图 Classed Based View （APIView，视图的view的基类，使用方法定义不同请求）通用类视图 Generic Classed Based View  提供序列化器使用的属性与方法    serializer_class 指明视图使用的序列化器    get_serializer_class()  返回序列化器类    get_serializer（）       获取序列化器对象  提供关于数据库查询的属性与方法    queryset   返回视图使用的查询集    get_object()  返回详情视图所需的模型类型数据对象  其他可以设置的属性    pagination_class  分页控制类    filter_backends   查询集过滤DRF的视图集 viewsets  可以将一系列逻辑相关的动作放到一个类中：    - list()提供一组数据    - retrieve()提供单个数据    - create()创建数据    - update()保存数据    - destory()删除数据\n前面3个视图都需要将list和实体类区分，视图集可以将List和实体类合在一块编写1.将所有接口写在一个类视图中（类试图中方法不再用请求方法小写 用行为&#x2F;动作代替）2.重写as_view({‘get’:’list’, ‘post’:’create’})\n使用router可以简写视图集的路由规则DefaultRouter会生成根路由\n其他功能过滤filter_fields &#x3D; [‘bread’]  配置过滤字段\n前端调用   xxxxxx?bread&#x3D;aaaa\n排序filter_backends &#x3D; [OrderingFilter]ordering_fields &#x3D; [‘id’,’bread’]\n前端调用   xxxxxx?ordering&#x3D;-bread\n分页配置分页类，pagination_class引用分页类\n","categories":["框架"],"tags":["学习","django"]},{"title":"django","url":"/java4u/2022/10/25/django/","content":"项目文件介绍mysite|- app01    |- __init__.py     |- admin.py    【默认提供了admin后台管理】    |- apps.py     【app启动类】    |- migrations  【数据库字段变更记录】    |- models.py   【**重要**对数据库操作】    |- tests.py    |- views.py    【**重要**视图】|- manage.py       【项目的管理，启动项目/创建app/数据管理】|- mysite    |- __init__.py    |- settings.py 【项目配置】    |- urls.py     【URL和函数的对应关系】    |- asgi.py     【接受网络请求】    |- wsgi.py     【接受网络请求】\n\n创建APPpython3.9 manage.py startapp app01\n快速入门\n确保APP注册INSTALLED_APPS &#x3D; [  ‘django.contrib.admin’,  ‘django.contrib.auth’,  ‘django.contrib.contenttypes’,  ‘django.contrib.sessions’,  ‘django.contrib.messages’,  ‘django.contrib.staticfiles’,  ‘app01.apps.App01Config’]\n编写URL和函数对应关系urlpatterns &#x3D; [  path(‘index&#x2F;‘, views.index)]\n编写视图函数\n启动django\npython3.9 manage.py runserver\n\n\n\n视图request对象GET  获取？参数POST 获取post提交的数据path 请求路径method 请求方法COOKIES 请求过来的cookiesuser  请求的用户对象，判断用户是否登录session 当前会话META  包含所有HTTP首部\n数据库操作1.django连接数据库在settings.py文件中进行配置和修改\nDATABASES &#x3D; {    ‘default’: {        ‘ENGINE’: ‘django.db.backends.mysql’,        ‘NAME’: ‘my_schema’,        ‘USER’: ‘root’,        ‘PASSWORD’: ‘root’,        ‘HOST’: ‘127.0.0.1’,        ‘PORT’: ‘3306’,    }}\n2.django操作表class UserInfo(models.Model):    name = models.CharField(max_length=32)    password = models.CharField(max_length=64)    age = models.IntegerField(default=2)  # 设置默认值    data = models.IntegerField(null=true,blank=true)  # 允许为空    &quot;&quot;&quot;create table app01_userinfo(    id bigint auto_increment primary key,    name varchar(32),    password varchar(64),    age int)&quot;&quot;&quot;\n\n执行命令：python manage.py makemigrationspython manage.py migrate\n3.django操作表中的数据# 新建数据 insert into app01.department(title) values(&quot;销售部&quot;)Department.objects.create(title=&quot;销售部&quot;)\n\n列属性\n字符串与数字类型\n时间类型\n文件类型\n特殊类型属性\n公共属性\n表关联方法\n\n多对多会创建中间表记录2张表的对应关系\n数据库查询基于ORM常用查询方法\nall()           所有数据get(**filter)   查询满足条件的数据(单条)filter(**filter)查询满足条件的数据(多条)exists()        返回是否有对象count()         返回对象的数量exclude(**filter) 返回数据排除distinct(&#x27;&#x27;)      去重\n","categories":["框架"],"tags":["学习","django"]},{"title":"openscenario","url":"/java4u/2022/10/15/openscenario/","content":"StandardScalar types and units\nlibrary-physical-length[] type length is SI(m: 1)  长度\nlibrary-physical-time[] type time is SI(s: 1)   时间\nlibrary-physical-speed[] type speed is SI(m: 1, s: -1)   速度\nlibrary-physical-acceleration[] type acceleration is SI(m: 1, s: -2)  加速度\nlibrary-physical-jerk[] type jerk is SI(m: 1, s: -3) 每单位时间的加速度变化率\nlibrary-physical-angle[]  type angle is SI(rad: 1)   角度\nlibrary-physical-angular_rate[] type angular_rate is SI(rad: 1, s: -1)  角速度\nlibrary-physical-angular_acceleration[]  type angular_acceleration is SI(rad: 1, s: -2)  角加速度\nlibrary-physical-mass[]  type mass is SI(kg: 1)  重量\nlibrary-physical-temperature[]  type temperature is SI(K: 1)  温度\nlibrary-physical-pressure[]  type pressure is SI(kg: 1, m: -1, s: -2) 压力\nlibrary-physical-luminous_intensity[]  type luminous_intensity is SI(cd: 1) 发光强度（光源在特定方向上每单位立体角发射的波长加权功率的量度）\nlibrary-physical-luminous_flux[]  type luminous_flux is SI(cd: 1, rad: 2)  光通量（表示光功率的物理量，是表示光源整体亮度的指标）\nlibrary-physical-illuminance[]  type illuminance is SI(cd: 1, rad: 2, m: -2)  照度（单位面积上入射在表面上的总光通量）\nlibrary-physical-electrical_current[]  type electrical_current is SI(A: 1) 电流\nlibrary-physical-amount_of_substance[] type amount_of_substance is SI(mol: 1)  物质的量(mole)\n\nStructs\nlibrary-position_3d[]\nlibrary-celestial_position_2d[]  天航struct celestial_position_2d:  azimuth: angle     方位角  elevation: angle   海拔（仰角）\nlibrary-geodetic_position_2d[]  地理坐标struct geodetic_position_2d:  latitude: angle  longitude: angle\nlibrary-orientation_3d[]  物理空间定位struct orientation_3d:  roll: angle  pitch: angle  yaw: angle\nlibrary-pose_3d[]struct pose_3d:  position: position_3d  orientation: orientation_3d\n\n","categories":["规范"],"tags":["学习","openscenario"]},{"title":"python","url":"/java4u/2022/10/01/python/","content":"基础语法\n字面量：固定值\n注释\n变量\n数据类型 type()\n数据类型转换 int() float() str()\n标识符 命名\n运算符\n字符串扩展\n使用单引号、双引号、三引号定义字符串\n字符串拼接\n字符串格式化 占位符（%s %d %f） 快速格式化 f”{变量}”\n格式化精度控制\n对表达式进行格式化\n\n\n数据输入 input()\n\n判断语句\n布尔类型和比较运算符\nif语句基本格式if age &gt;&#x3D; 18:  print(“我已经成年了”)\nif else语句\nif elif else语句\n判断语句嵌套\n\n循环语句\nwhile循环\nfor循环\n基础语法 for 临时变量 in 待处理数据集\nrange语句 获取数字序列 range(n1, n2, n3) 从n1开始到n2结束（不包含n2）,步长为n3\n变量域 需要访问临时变量，可以在循环外定义它\n\n\n循环中断\n\n函数\n函数基础定义 def 函数名(传入参数): 函数体 return 返回值\n函数的传入参数\n函数的返回值 在if判断中，None等同于False\n函数说明文档\n函数作用域 使用global关键字可以将函数内部变量变成全局变量\n\n数据容器\n列表list [元素1，元素2，…]\n列表的下标索引 可以反向索引\n列表的常用操作\n查找某元素下标 列表.index(元素)\n修改特定位置的元素值  列表[下标]&#x3D;值\n插入元素  列表.insert(下标，元素)\n追加元素  列表.append(元素)\n追加元素2 列表.extend(其他数据容器)\n删除元素  del 列表[下标]  列表.pop(下标)\n删除某元素在列表中第一个匹配项   列表.remove()\n列表清空  列表.clear()\n统计某元素在列表内数量  列表.count(元素)\n统计列表元素数量  len(列表)\n\n\n列表的遍历\n元组  元组一旦定义完成，就不可修改 （元素，元素……）  定义单个元素后面需要添加,  index  count  len\n字符串\n通过下标索引取值\nindex方法\nreplace(字符串1，字符串2)\nsplit方法\nstrip()   去前后空格\nstrip(字符串) 去前后指定字符串，按单个字符去移除\ncount\nlen(字符串)\n\n\n序列的切片 序列[起始下标:结束下标:步长]\nset 集合 {元素，元素…}\n添加元素 add\n移除元素 remove\n随机取元素,同时删除元素 pop\n清空集合\n取2个集合的差集  集合1.difference(集合2)  集合1有集合2没有\n消除2个集合的差集  集合1.difference_update(集合2)  删除和集合2相同的元素\n合并集合   集合1.union(集合2)\n\n\n字典 {key:value, key:value, …….}\n新增元素 字典[key]&#x3D;value\n更新元素 字典[key]&#x3D;value\n删除元素 字典.pop(key)\n清空元素\n获取全部key  字典.keys()\n遍历字典\n计算字典里元素数量\n通过in或not in 判断key是否存在\n\n\n通用操作  \n遍历\nlen 统计容器元素个数\nmax 最大元素\nmin 最小元素\nlist()  容器转列表\ntuple() 容器转元组\nstr()   容器转字符串\nset()   容器转集合\n排序   sorted(容器,[reverse&#x3D;True]) 排序结果会放入列表，会返回列表\nsort(key&#x3D;选择排序依据的函数,reverse&#x3D;True|False)   自定义排序规则\n\n\n\n\n\n函数进阶函数多返回值def test_return():  return 1,2x,y = test_return()\n\n按照返回值顺序，写对应顺序的多个变量接受即可\n函数多种传参方式\n位置参数    根据参数位置来传递参数\n关键字参数  通过“键&#x3D;值”形式传递参数，可以不按照参数定义顺序传参\n缺省参数    定义的函数设置默认值，默认参数必须放在最后\n不定长参数  不确定调用时传递多少个参数 位置不定长* 关键字不定长 **\n\n匿名函数\n函数作为参数传递  将计算逻辑进行传递\nlambda匿名函数   lambda 传入参数：函数体（一行代码）\n\n文件操作\n文件编码\n文件的读取\nopen(name,mode,encoding) 打开函数 name 要打开目标文件名的字符串 mode 设置打开文件模式（r 只读 w 写入 a 追加） encoding 编码格式\nread()  读取数据长度（字节）\nreadlines() 按照行把整个文件内容一次性读取\nreadline()  一次读取一行内容\nfor循环读取文件\n文件关闭\nwith open语法 操作完成自动关闭流\n\n\n文件的写入\n文件的追加\n\n异常try:  可能发生错误的代码except:  如果出现异常执行的代码else:  没有发生异常执行的代码finally:  最终执行的代码\n模块\n导入模块 [from 模块名] import [模块|类|变量|函数|*] [as 别名]\n自定义模块  if name &#x3D;&#x3D; ‘main‘:   右键运行可以运行，导入不会运行  all 只能导入all变量设置的\n\n包包就是文件夹，该文件夹下包含一个__init__.py文件\n类成员方法定义：def 方法名(self,………):  方法体\nself必须填写（传参的时候可以忽略），用来表示类对象自身，访问类的成员变量必须使用self\n构造方法init()方法，称之为构造方法，同时成员变量可以省略\n魔术方法Python类内置方法：\n\ninit 构造方法\nstr  字符串方法（相当于toString()）\nlt   小于、大于符号比较(相当于Comparator)\nle   小于等于、大于等于符号比较\neq   &#x3D;&#x3D;符号比较\n\n封装私有成员：定义私有成员只需变量和方法以__开头\n类型注解1.变量的类型注解基础语法：  变量：类型  注释 #type:类型容器类型详细注解my_list: list[int] &#x3D; [1,2,3]my_tuple: tuple[str, int, bool] &#x3D; (“”, 666, True)my_dict: dict[str, int] &#x3D; {“”: 666}\n2.函数（方法）形参和返回值类型注解\ndef 函数方法(形参：类型， 形参：类型)-&gt;返回值类型:\n3.union类型进行联合注解\nmyList: list[Union[int, str]] &#x3D; [1, 2, “itma”, “itcast”]def func2(data: Union[int, str]) -&gt; Union[int, str]:\n装饰器总结无参装饰器模板\ndef outter(func):    def wrapper(*args, **kwargs):        # 1、调用原函数        # 2、为其增加新功能        res = func(*args, **kwargs)        return res    return wrapper\n\n需求 ：写个认证功能（输入账号密码，进行认证），当然账号密码是要从文件中取出\ndef auth(func):    def wrapper(*args, **kwargs):        # 1、调用原函数        # 2、为其增加新功能        name = input(&#x27;your name&gt;&gt;: &#x27;).strip()        pwd = input(&#x27;your password&gt;&gt;: &#x27;).strip()        if name == &#x27;egon&#x27; and pwd == &#x27;123&#x27;:            res = func(*args, **kwargs)            return res        else:            print(&#x27;账号密码错误&#x27;)    return wrapper@authdef index():    print(&#x27;from index&#x27;)\n\n协程协程是一种用户态的上下文切换技术，就是通过线程实现代码块相互切换执行。\n1.异步编程1.1 事件循环理解成为一个死循环，去检测并执行某些代码\n# 伪代码任务列表 = [任务1， 任务2， 任务3...]while True:\t可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有任务，将‘可执行’和‘已完成’任务返回\tfor 就绪任务 in 可执行的任务列表:\t\t执行已就绪任务\tfor 已完成任务 in 已完成的任务列表:\t\t任务列表中移除 已完成任务\t如果任务列表中任务已完成，则终止循环\n\nimport asyncio# 去生成或获取一个事件循环loop = asyncio.get_event_loop()# 将任务放到任务列表loop.run_until_complete(任务)\n\n1.2 快速上手协程函数，定义函数 async def 函数名\n协程对象，执行 协程函数() 得到的协程对象\n执行协程函数创建协程对象，函数内部代码不会执行。\n如果想要运行协程函数内部代码，必须将协程对象交给事件循环来处理\nimport asyncioasync def func():    print(&quot;play with me!&quot;)result = func()# loop = asyncio.get_event_loop()# loop.run_until_complete(result)asyncio.run(result) # python3.7 本质上做上面的事\n\n1.3 awaitawait + 可等待的对象（协程对象，Future，Task对象）\n示例1：\nimport asyncioasync def other():    print(&quot;start&quot;)    await asyncio.sleep(2)    print(&quot;end&quot;)    return &#x27;返回值&#x27;async def func():    print(&quot;执行协程函数内部代码&quot;)    # 遇到IO操作挂起当前协程，等IO操作完成之后再继续往下执行，    # 当前协程挂起时，事件循环可以去执行其他任务    response = await other()    print(&quot;IO请求结束，结果为：&quot;, response)asyncio.run(func())\n\n示例2：\nimport asyncioasync def other():    print(&quot;start&quot;)    await asyncio.sleep(2)    print(&quot;end&quot;)    return &#x27;返回值&#x27;async def func():    print(&quot;执行协程函数内部代码&quot;)    # 遇到IO操作挂起当前协程，等IO操作完成之后再继续往下执行，    # 当前协程挂起时，事件循环可以去执行其他任务    response1 = await other()    print(&quot;IO请求结束，结果为：&quot;, response1)    response2 = await other()    print(&quot;IO请求结束，结果为：&quot;, response2)asyncio.run(func())\n\nawait就是等待对象的值得到结果之后再继续往下走\n1.4 task对象在事件循环中添加多个任务\ntask用于并发调度协程，通过asyncio.create_task(协程对象)的方式创建task对象，这样可以让协程加入事件循环中等待被调度执行。\n示例1：\nimport asyncioasync def func():    print(1)    await asyncio.sleep(2)    print(2)    return &quot;返回值&quot;async def main():    print(&quot;main开始&quot;)    # 创建task对象，将当前执行func函数任务添加到事件循环    task1 = asyncio.create_task(func())    task2 = asyncio.create_task(func())    print(&quot;main结束&quot;)    # 当执行某协程遇到IO操作时，会自动化切换执行其他任务    # 此时的await是等待相应的协程全部执行完毕并获取结果    ret1 = await task1    ret2 = await task2    print(ret1, ret2)asyncio.run(main())\n\n示例2：\nimport asyncioasync def func():    print(1)    await asyncio.sleep(2)    print(2)    return &quot;返回值&quot;async def main():    print(&quot;main开始&quot;)    task_list = [        asyncio.create_task(func()),        asyncio.create_task(func())    ]    print(&quot;main结束&quot;)    done, pending = await asyncio.wait(task_list)    print(done)asyncio.run(main())\n\n示例3：\nimport asyncioasync def func():    print(1)    await asyncio.sleep(2)    print(2)    return &quot;返回值&quot;# task_list = [#     asyncio.create_task(func()),#     asyncio.create_task(func())# ]# 直接放task列表会报错，create_task将task放到事件循环列表中，而事件循环还没有被创建# asyncio.run(asyncio.wait(task_list))task_list = [func(), func()]done, pending = asyncio.run(asyncio.wait(task_list))print(done)\n\n1.5 asyncio.Future对象task继承future，task对象内部await结果的处理基于future对象来的\n1.6 concurrent.futures.Future当出现第三方依赖不支持异步的时候\nimport timeimport asynciodef func():    time.sleep(2)    return &quot;xxx&quot;async def main():    loop = asyncio.get_running_loop()    # 第一步内部调用ThreadPoolExecutor的submit方法去线程池申请一个线程执行func函数，    # 并返回concurrent.futures.Future对象    # 第二步调用wrap_future将concurrent.futures.Future包装为asyncio.Future对象    # 进行使用    fut = loop.run_in_executor(None, func)    result = await fut\n\n1.7 异步上下文管理器此对象通过定义__aenter__()和__aexit____()方法来对async with语句中的环境进行控制\nimport asyncioclass AsyncContextManager:    def __init__(self):        self.conn = conn    async def do_something(self):        # 异步操作数据库        return 666    async def __aenter__(self):        # 异步链接数据库        self.conn = await asyncio.sleep(1)        return self    async def __aexit__(self, exc_type, exc_val, exc_tb):        # 异步关闭数据库链接        await asyncio.sleep(1)async def fun():    async with AsyncContextManager() as f:        result = await f.do_something()        print(result)asyncio.run(fun())\n\nuvloop是asyncio的事件循环替代方案，它的性能大于默认的asyncio\n#pip install uvloopimport asyncioimport uvloopasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())# 之后编写代码与之前的代码一致\n\n一个asgi（异步服务器网关接口） -&gt; uvicorn内部使用了uvloop\n","categories":["语言"],"tags":["学习","python"]},{"title":"docker","url":"/java4u/2022/09/07/docker/","content":"docker架构\n镜像：docker镜像就相当于一个root文件系统，相当容器的“源代码”\n容器：镜像和容器的关系就是类和对象的关系，用镜像创建的运行实例\n仓库：存放镜像\n\n命令镜像docker –helpdocker images 查看本地镜像docker search redis  搜索镜像docker pull redis 拉取镜像docker rmi images_id  删除镜像\nREPOSITORY和TAG都是none，虚悬镜像\n容器启动容器    保持运行（id后台运行）       选择镜像docker run -it –name&#x3D;c1 centos:7 &#x2F;bin&#x2F;bashexit   退出容器（容器会停止）ctrl+p+q   退出容器（容器不停止）docker ps [-a]  查看运行的容器(历史容器)docker exec -it c2 &#x2F;bin&#x2F;bash  进入容器docker attach 容器IDdocker stop name  停止容器docker rm c1   删除容器docker top [imageid]docker inspect c2   查看容器信息docker cp 容器ID:容器内路径 目的主机路径docker export 容器ID &gt; 文件名.tar     导出容器内容作为tar归档文件cat xxx.tar | docker import  镜像名称&#x2F;镜像版本：镜像版本\n数据卷\n数据卷是宿主机的一个目录或文件\n当容器目录和数据卷目录绑定后，对方的修改会立即同步\n一个数据卷可以被多个容器同时挂载\n一个容器也可以挂载多个数据卷\n–privileged&#x3D;true,扩大容器权限\n默认创建的挂载有读写权限，添加ro，给只读权限，限制容器内去写\n\ndocker run .. -v 宿主机目录（文件）:容器内目录（文件）docker run -it –name&#x3D;c1 -v &#x2F;home&#x2F;dave_cc&#x2F;data:&#x2F;root&#x2F;data_container centos:7:ro &#x2F;bin&#x2F;bash\n创建数据卷容器docker run -it –name&#x3D;c3 -v &#x2F;volume centos:7挂载数据卷容器（继承数据卷挂载规则）docker run -it –name&#x3D;c1 –volumes-from c3 centos:7\n常规软件安装部署mysqldocker run -d -p 3307:3306 –privileged&#x3D;true -v &#x2F;home&#x2F;dave_cc&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d -v &#x2F;home&#x2F;dave_cc&#x2F;mysql&#x2F;logs:&#x2F;var&#x2F;log&#x2F;mysql -v &#x2F;home&#x2F;dave_cc&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123456 –name&#x3D;c_mysql mysql:5.6\n进入mysqlmysql -uroot -p\n查看mysql编码show variables like ‘character%’;\n部署tomcatdocker run -id –name&#x3D;c_tomcat -p 8080:8080 tomcat\n将之前的webapps删除，将webapps.dist改名成webapps即可看到首页\n部署nginxuser  nginx;worker_processes  1;error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;events {    worker_connections  1024;}http {    include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;    default_type  application&#x2F;octet-stream;    log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘                      ‘$status $body_bytes_sent “$http_referer” ‘                      ‘“$http_user_agent” “$http_x_forwarded_for”‘;    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;    sendfile        on;    # tcp_nopush     on;    keepalive_timeout  65;\ninclude /etc/nginx/conf.d/*.conf;\n\n}\ndocker run -id –name&#x3D;c_nginx \\\n\n-p 80:80 -v $PWD&#x2F;conf&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf -v $PWD&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx -v $PWD&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx\n\n部署redis集群docker run -d –name&#x3D;redis-node-1 –net host –privileged&#x3D;true -v &#x2F;home&#x2F;dave_cc&#x2F;redis&#x2F;share&#x2F;redis-node-1:&#x2F;data redis –cluster-enabled yes –appendonly yes –port 6381docker run -d –name&#x3D;redis-node-2 –net host –privileged&#x3D;true -v &#x2F;home&#x2F;dave_cc&#x2F;redis&#x2F;share&#x2F;redis-node-2:&#x2F;data redis –cluster-enabled yes –appendonly yes –port 6382docker run -d –name&#x3D;redis-node-3 –net host –privileged&#x3D;true -v &#x2F;home&#x2F;dave_cc&#x2F;redis&#x2F;share&#x2F;redis-node-3:&#x2F;data redis –cluster-enabled yes –appendonly yes –port 6383docker run -d –name&#x3D;redis-node-4 –net host –privileged&#x3D;true -v &#x2F;home&#x2F;dave_cc&#x2F;redis&#x2F;share&#x2F;redis-node-4:&#x2F;data redis –cluster-enabled yes –appendonly yes –port 6384docker run -d –name&#x3D;redis-node-5 –net host –privileged&#x3D;true -v &#x2F;home&#x2F;dave_cc&#x2F;redis&#x2F;share&#x2F;redis-node-5:&#x2F;data redis –cluster-enabled yes –appendonly yes –port 6385docker run -d –name&#x3D;redis-node-6 –net host –privileged&#x3D;true -v &#x2F;home&#x2F;dave_cc&#x2F;redis&#x2F;share&#x2F;redis-node-6:&#x2F;data redis –cluster-enabled yes –appendonly yes –port 6386\n构建主从关系\nredis-cli –cluster create 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385 127.0.0.1:6386 –cluster-replicas 1\n查看集群状态redis-cli -p 6381cluster infocluster nodes\n连接redis集群方式redis-cli -p 6381 -c\n集群检查redis-cli –cluster check 127.0.0.1:6381\nredis集群扩容1.新建6387 6388 两个节点docker run -d –name&#x3D;redis-node-7 –net host –privileged&#x3D;true -v &#x2F;home&#x2F;dave_cc&#x2F;redis&#x2F;share&#x2F;redis-node-7:&#x2F;data redis –cluster-enabled yes –appendonly yes –port 6387docker run -d –name&#x3D;redis-node-8 –net host –privileged&#x3D;true -v &#x2F;home&#x2F;dave_cc&#x2F;redis&#x2F;share&#x2F;redis-node-8:&#x2F;data redis –cluster-enabled yes –appendonly yes –port 6388\n2.将新增的6387节点作为master节点加入原集群进入6387容器redis-cli –cluster add-node 127.0.0.1:6387 127.0.0.1:6381\n3.重新分配槽号redis-cli –cluster reshard 127.0.0.1:6381\n4.为6387分配6388的从节点redis-cli –cluster add-node 127.0.0.1:6388 127.0.0.1:6387 –cluster-slave –cluster-master-id 4a15b5abc41f3a73baa1fd5875007ad9405a4b6a\nredis集群缩容1.将6388（从节点）从集群中删除redis-cli –cluster del-node 127.0.0.1:6388 6c1cf259c2eb0b06bf7f4dafe2470c0d383bd98d\n2.将6387的槽号清空，重新分配（选择需要分配槽的数量，目标节点和来源节点）redis-cli –cluster reshard 127.0.0.1:6381\n3.将6387从集群中删除redis-cli –cluster del-node 127.0.0.1:6387 4a15b5abc41f3a73baa1fd5875007ad9405a4b6a\ndockerfiledocker镜像原理\ndocker镜像是由特殊文件系统叠加而成\n最底端是bootfs,并使用宿主机的bootfs\n第二层是root文件系统rootfs\n然后可以往上叠加其他的镜像文件\n统一文件系统技术能够将不同层整合成一个文件系统，为这些层提供一个统一的视角\n一个镜像可以放在另一个镜像上面\n\n镜像制作1.容器转为镜像docker commit -m&#x3D;”注释” -a&#x3D;”作者” 容器id 镜像名称：版本号docker save -o 压缩文件名称 镜像名称：版本号docker load -i 压缩文件名称  (还原成镜像)\n2.dockerfile\n\ndockerfile是一个文本文件\n包含了一条条指令\n每一条指令构建一层，基于基础镜像，最终构建一个新的镜像\n对于开发人员：可以为开发团体提供一个完全一致的开发环境\n对于测试人员：可以直接拿开发时构建的镜像或者通过dockerfile构建一个新的镜像\n对于运维人员：在部署时，可以实现应用的无缝移植\n\ndockerfile关键字\n\n\n\n关键字\n作用\n备注\n\n\n\nFROM\n指定父镜像\n指定dockerfile基于那个image构建\n\n\nMAINTAINER\n作者信息\n用来标明这个dockerfile谁写的\n\n\nLABEL\n标签\n标明dockerfile标签\n\n\nRUN\n执行命令\n执行一段命令默认是&#x2F;bin&#x2F;sh，RUN在构建时运行\n\n\nCMD\n容器启动命令\n提供容器启动时的默认命令，CMD会被docker run之后的参数替换\n\n\nENTRYPOINT\n入口\n指定容器启动时要运行的命令，但ENTRYPOINT不会被docker run后面的命令覆盖\n\n\nCOPY\n复制文件\nbuild的时候复制文件到image中\n\n\nADD\n添加文件\n将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包\n\n\nENV\n环境变量\n指定build时候的环境变量 可以在启动容器的时候通过-e覆盖\n\n\nARG\n构建参数\n构建参数只在构建的时候使用的参数\n\n\nVOLUME\n定义外部可以挂载的数据卷\n\n\n\nEXPOSE\n暴露端口\n\n\n\nWORKDIR\n工作目录\n指定容器内部的工作目录\n\n\nUSER\n指定执行用户\n\n\n\nENTRYPOINT和CMD一起使用，实际运行ENTRYPOINT,CMD就是给ENTRYPOINT传递参数相当于： ““\n构建镜像docker build -f Dockerfile -t centos:1.5 .\n没有仓库名和TAG是虚悬镜像，查看虚悬镜像docker image ls -f dangling&#x3D;true删除虚悬镜像docker image prune\n私有仓库私有仓库搭建1.拉取私有仓库镜像docker pull registry2.启动私有仓库容器docker run -d –name&#x3D;registry -p 5000:5000 -v &#x2F;home&#x2F;dave_cc&#x2F;myregistry:&#x2F;tmp&#x2F;registry –privileged&#x3D;true registryhttp://localhost:5000/v2/_catalog 看到{“repositories”:[]}表示搭建成功3.修改daemon.json 取消docker不允许http的推送方式vim &#x2F;etc&#x2F;docker&#x2F;daemon.json{“insecure-registries”:[“127.0.0.1:5000”]}4.重启dockersystemctl restart docker\n将镜像上传至私有仓库1.标记镜像为私有仓库镜像docker tag  镜像:Tag Host:Port&#x2F;Repository:Tagdocker tag centos:7 127.0.0.1:5000&#x2F;centos:72.上传标记的镜像docker push 127.0.0.1:5000&#x2F;centos:7\n从私有仓库拉取镜像docker pull 127.0.0.1:5000&#x2F;myubuntu:1.3\n分布式存储哈希取余通过hash算法和计算台数，计算出数据落在哪台机器 hash(key)%n\n优点：简答有效缺点：集群扩容或缩容都会导致数据混淆\n一致性哈希\n算法构建一致性哈希环\n服务器IP节点映射根据服务器IP将每台服务器映射到环上\nkey落到服务器的落键规则key使用相同的hash规则计算出环上的位置，从此位置延环顺时针移动，第一台遇到的服务器就是应该定位到的服务器\n\n优点：解决了哈希取余的一致性和扩缩的问题缺点：一致性哈希算法的数据倾斜问题（大部分数据可能会被分配到一台或某几台机器上）\n哈希槽分区解决均匀分配的问题，在数据和节点之间加入了一层（增大数据分配的粒度），把这层称之哈希槽，用于管理数据和节点之间的关系，相当于节点上放的是槽，槽里放的是数据\ndocker网络网络模式：\n\nbridge:为每一个容器分配&#x2F;设置IP等，并将容器连接到一个docker0虚拟网桥,默认为该模式\nhost:使用宿主机的IP和端口\nnone:容器有独立的network，但并没有对其进行任何网络设置\ncontainer:和一个指定的容器共享IP&#x2F;端口范围\n自定义网络，维护好主机名和IP的对应关系，让IP和服务名都可以PING通\n\ndocker-compose对服务进行编排，可以同时批量进行服务启动\n常用命令：\n\n-h 帮助\nup 启动所有docker-compose服务\nup -d 启动所有docker-compose服务并后台运行\ndown 停止并删除容器&#x2F;网络&#x2F;卷&#x2F;镜像\nexec 服务id  进入容器内部\nps  展示当前docker-compose编排过的运行的所有容器\nconfig 检查配置\n\nPortainerdocker管理图形化工具\ndocker run -d -p 8000:8000 -p 9000:9000 –name portainer –restart&#x3D;always -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v portainer_data:&#x2F;data portainer&#x2F;portainer-ce:latest\nCIG重量级监控系统CAdvisor监控收集+InfluxDB存储数据+Granfana展示图表\nCAdvisor是容器资源监控工具，针对单物理机，提供数据集接口，将数据发往数据库储存功能：展示HOST和容器的监控数据；展示历史变化数据InfluxDB开源分布式时序&#x2F;事件和指标数据库功能：基于时间序列；可度量性，可以实时对大量数据进行计算；基于事件Granfana开源数据监控分析可视化平台\n","categories":["容器"],"tags":["学习","docker"]},{"title":"kubernetes","url":"/java4u/2022/09/07/kubernetes/","content":"kubernetes介绍kubernetes本质是一组服务器集群，主要提供：\n\n自我修复\n弹性伸缩\n服务发现\n负载均衡\n版本回退\n存储编排\n\nkubernetes组件master:集群控制平面，负责集群的决策(管理)\nApiserver:资源操作唯一入口，接收用户命令Scheduler:集群资源调度ControllerManager:负责维护集群的状态，比如程序部署安排Etcd:负责储存集群各种资源对象的信息\n\nnode:集群数据平面，负责为容器提供运行环境(干活)\nKuberlet:维护容器生命周期，通过docker来创建、更新、销毁容器KuberProxy:负责提供集群内部的服务发现和负载均衡Docker:负责节点上容器的各种操作\n\nkubernetes概念Master: 集群控制节点Node: 工作负载节点Pod: k8s最小控制单元，容器运行在pod中，一个pod可以有1个或多个容器deployment: pod控制器，确保pod资源符合预期的状态，当pod资源出现故障，会尝试进行重启或重建Controller: 控制器，通过它实现对pod的管理，启停&#x2F;伸缩podService: pod对外服务的统一入口，可以维护同一类多个podLabel: 标签，用对pod进行分类NameSpace: 命名空间，用来隔离pod的运行环境\nPod资源一级属性\n\napiVersion\nkind  资源类型  [kubectl api-resource]\nmetadata  元数据\nspec   描述，资源配置的详细描述\nstatus   状态信息，k8s自动生成\n\nspec主要配置，查看它的常见子属性：\ncontainers  容器列表，定义容器详细信息\ncontainers:    name &lt;string&gt;  #容器名称    image &lt;string&gt; #容器需要的镜像地址    imagePullPolicy &lt;string&gt; #镜像拉去策略 Always总是从远程仓库拉取 IfNotPresent 本地有则使用本地的，本地没有远程下载  Never 只使用本地镜像    command &lt;[]string&gt; #容器启动命令    args &lt;[]string&gt;  #容器启动命令需要的参数列表    env &lt;[]string&gt;  #容器环境变量的配置    ports      #容器需要暴露的端口列表    resources &lt;Object&gt; #资源限制和资源请求的设置，他有2个子选项 limits:限制运行时容器最大占用资源  requests:用于设置容器需要的最小资源\n\ncontainers的ports选项\nKIND: PodVERSION: v1RESOURCE: ports &lt;[]object&gt;FIELDS:  name  &lt;string&gt;  #端口名称，如果指定必须保证唯一  containerPort&lt;integer&gt; #容器要监听的端口  hostPort  &lt;integer&gt;  #容器在主机上公开的端口,如果设置，主机只能运行容器一个副本  hostIP  &lt;string&gt;  #外部端口绑定到主机IP  protocol &lt;string&gt; #端口协议，必须是UDP/TCP或SCTP,默认TCP\n\n测试样例\napiVersion: v1kind: Podmetadata:  name: podname  namespace: devspec:  containers:  - name: nginx    image: nginx:1.17.1\n\n详细样例\napiVersion: v1kind: Podmetadata:  name: pod-base  namespace: dev  labels:    user: heimaspec:  containers:  - name: nginx    image: nginx:1.17.1    imagePullPolicy: Always    ports:    - name: nginx-port      containerPort: 80      protocol: TCP    volumeMounts:  #将logs-volume挂载到nginx容器，对应目录为/var/log/nginx    - name: logs-volume      mountPath: /var/log/nginx    resources:      limits:        cpu: &quot;2&quot;        memory: &quot;10Gi&quot;      requests:        cpu: &quot;1&quot;        memory: &quot;10Mi&quot;    livenessProbe:      exec:        command: [&quot;/bin/cat&quot;,&quot;/tmp/hello.txt&quot;]      initialDelaySeconds: 30  # 容器启动后30s开始探测      timeoutSeconds: 5  # 探测超时时间5s  # nodeName: node1  # 指定调度到node1节点  # nodeSelector:  #   nodeenv: pro  # 指定调度到具有nodeenv=pro标签的节点上  affinity:  # 亲和性设置    nodeAffinity:  # 设置node亲和性      requireDuringSchedulingIgnoreDuringExecution:  # 硬限制        nodeSelectorTerms:        - matchExpressions:  # 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签          - key: nodeenv            operator: In            value: [&quot;xxx&quot;,&quot;yyy&quot;]      preferredDuringSchedulingIgnoreDuringExecution:  # 软限制      - weight: 1        preference:          matchExpressions:          - key: nodeenv            operator: In            value: [&quot;xxx&quot;,&quot;yyy&quot;]    podAffinity:  # 设置pod亲和性      requireDuringSchedulingIgnoreDuringExecution:      - labelSelector:          matchExpressions:          - key: podenv            operator: In            value: [&quot;xxx&quot;,&quot;yyy&quot;]        topologyKey: kubernetes.io/hostname   # 作用域 调度到一个目标节点  tolerations:  # 添加容忍  - key: &quot;tag&quot;  # 要容忍的污点的key    operator: &quot;Equal&quot;  # 操作符    value: &quot;heima&quot;     # 容忍的污点的value    effect: &quot;NoExecute&quot; # 添加容忍的规则，这里必须和标记的污点规则相同  restartPolicy: Never  # 重启策略  Always,自动重启  OnFailure,异常时重启  Never不重启  - name: busybox    image: busybox:1.30    command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt;sleep 3;done;&quot;]    volumeMounts:    - name: logs-volume      mountPath: /logs    env:    - name: &quot;username&quot;      value: &quot;admin&quot;    - name: &quot;password&quot;      value: &quot;123456&quot;    lifecycle:      postStart:        exec:  # 容器启动前执行命令，修改nginx默认页面          command: [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;echo postStart... &gt; /usr/share/nginx/html/index/html&quot;]      preStop:        exec:  # 容器停止前停止nginx服务          command: [&quot;/usr/sbin/nginx&quot;,&quot;-s&quot;,&quot;quit&quot;]  initContainers:  # 初始化容器，能连接上mysql和redis才会启动容器  - name: test-mysql    image: busybox:1.30    command: [&#x27;sh&#x27;,&#x27;-c&#x27;,&#x27;until ping 192.168.109.201 -c 1 ; do echo waiting for mysql...; sleep 2;done;&#x27;]  - name: test-redis    image: busybox:1.30    command: [&#x27;sh&#x27;,&#x27;-c&#x27;,&#x27;until ping 192.168.109.202 -c 1 ;do echo waiting for redis...; sleep 2; done;&#x27;]  volumes:  #声明volume,name为logs-volume,类型为emptyDir  - name: logs-volume    emptyDir: &#123;&#125;\n\npod生命周期\npod创建过程\n运行初始化容器过程\n运行主容器过程\n容器启动后钩子(post start)&#x2F;容器终止前钩子（pre stop）\n容器存活性探测&#x2F;就绪探测\n\n\npod终止过程\n\n钩子处理器支持下面三种方式定义动作：\n\nExec命令：在容器中执行一次命令\n\nlifecycle:  postStart:    exec:      command:      - cat      - /tmp/healthy\n\n\nTCPSocket:将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常\n\nlifecycle:  postStart:    tcpSocket:      port: 8080\n\n\nHTTPGet:在当前容器中向某url发起http请求\n\nlifecycle:  postStart:    httpGet:      path: /      port: 80      host: 192.168.109.100      scheme: HTTP\n\n容器探测liveness probes:存活性探针，检测应用实例是否处于正常运行状态readiness probes:就绪性探针，检测应用实例是否可以接受请求\npod调度kubernetes提供四大类调度方式：\n\n自动调度\n定向调度:NodeName,NodeSelector\n亲和性调度：NodeAffinity,PodAffinity,PodAntAffinity\n污点（容忍）调度：Taints,Toleration\n\n亲和性调度分为三类：\n\nNodeAffinity(node亲和性):以node为目标，将Pod调度到目标node上\nPodAffinity(pod亲和性)：以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中\nPodAntAffinity(pod反亲和性):以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题\n\n亲和性使用场景：亲和性：如果2个应用频繁交互，有必要让2个应用尽可能靠近，减少网络通信带来的性能损耗反亲和性：当应用采用多副本部署时，有必要采用反亲和性让应用实例打散分布在各个node上。可以提供服务的高可用性\nPod控制器常见的pod控制器：\n\nReplicationController:比较原始的pod控制器\nReplicaSet: 保证指定数量的pod运行，并支持pod数量变更，镜像版本变更\nDeployment:通过控制ReplicaSet来控制pod，并支持滚动升级，版本回退\nHorizontal Pod Autoscaler:可以根据集群负载自动调整pod数量，实现削峰填谷\nDaemonSet: 在集群中指定NODE上都运行一个副本，一般用于守护进程类的任务\njob: 它创建出来的pod只要完成任务就立即退出，用于执行一次性任务\nCronjob:它创建的pod会周期性的执行，用于执行周期性任务\nStatefulSet:管理有状态应用\n\nReplicaSet(rs)保证一定数量的pod能正常运行，一旦pod发生故障就会重启或重建\napiVersion: apps/v1  #版本号kind: ReplicaSet  #类型metadata:  name:  namespace  labels:    controller: rsspec:  replicas: 3 #副本数量  selector:   #选择器，通过它指定该控制器管理哪些pod    matchLabels:   #labels匹配规则      app: nginx-pod    matchExpressions:      - &#123;key: app, operator: In, values: [nginx-pod]&#125;  template: #模板，当副本数量不足时，会根据下面的模板创建pod副本    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1        ports:        - containerPort: 80\n\nDeployment(deploy)通过管理ReplicaSet来间接管理pod，功能更强大，主要功能：\n\n支持ReplicaSet所有功能\n支持发布的停止&#x2F;继续\n支持版本滚动更新和版本回退\n\napiVersion: apps/v1  #版本号kind: Deployment  #类型metadata:  name:  namespace:  labels:    controller: deployspec:  replicas: 3 #副本数量  revisionHistoryLimit: 3  #保留历史版本,默认是10  paused: false  #暂停部署，默认是false  progressDeadlineSecond: 600  #部署超时时间，默认600  strategy:  #策略 Recreate 重建更新  RollingUpdate 滚动更新    type: RollingUpdate   #滚动更新策略    RollingUpdate:  #滚动更新      maxSurge: 30%  #最大额外可以存在的副本数，可以为百分比或整数      maxUnavailable: 30%  #最大不可用状态的pod最大值,可以为百分比或整数  selector:   #选择器，通过它指定该控制器管理哪些pod    matchLabels:   #labels匹配规则      app: nginx-pod    matchExpressions:      - &#123;key: app, operator: In, values: [nginx-pod]&#125;  template: #模板，当副本数量不足时，会根据下面的模板创建pod副本    metadata:      labels:        app: nginx-pod    spec:      containers:      - name: nginx        image: nginx:1.17.1        ports:        - containerPort: 80\n\nkubectl rollout:版本升级相关功能：\n\nstatus：显示当前升级状态\nhistory：显示升级历史记录\npause：暂停版本升级过程\nresume：继续已经暂停的版本升级过程\nrestart：重启版本升级过程\nundo：回滚到上一级版本（可以使用–to-revision回滚到指定版本）\n\n金丝雀发布deploy支持更新过程中的控制，如暂停和继续更新操作比如有一批新的pod资源创建完成后立即暂停更新过程，此时仅存在一部分新版本的应用，主体部分还是旧版本。然后筛选一小部分用户请求路由到新的pod应用，继续观察能否稳定运行。确定没问题后在继续完成余下的pod滚动更新，否则立即回滚更新操作。这就是金丝雀发布\nkubectl set image deploy pc-deployment nginx=nginx:1.17.4 -n dev &amp;&amp; kubectl rollout pause deploy pc-deployment -n dev\n\nHorizontal Pod AutoscalerHPA可以获取每个pod的利用率，然后和定义的指标进行对比，最后实现pod的数量调整\nmetrics-server可以用来收集集群中资源使用情况\n部署HPA\napiVersion: autoscaling/v1kind: HorizontalPodAutoscalermetadata:  name: pc-hpa  namespace: devspec:  minReplicas: 1  #最小pod数量  maxReplicas: 10 #最大pod数量  targetCPUUtilizationPercentage: 3   #cpu使用率指标  scaleTargetRef:   #指定要控制的nginx信息    apiVersion: apps/v1    kind: Deployment    name: nginx\n\njobjob主要负责批量处理短暂的一次性任务，job特点：\n\n当job创建的pod执行成功时，job将记录成功结束的pod数量\n当成功结束的pod到达指定的数量，job将完成执行\n\napiVersion: batch/v1kind: Jobmetadata:  name:  namespace:  labels:    controller: jobspec:  completions: 1 #指定job需要成功运行pods的次数，默认1  parallelism: 1 #指定job在任一时刻应该并发运行的pods数量，默认1  activeDeadlineSecond: 30 #指定job可运行的时间期限，超过时间还未结束，系统会尝试终止  backoffLimit: 6  #指定job失败后进行重试的次数，默认6  manualSelector: true  # 是否可以使用selector选择器选择pod,默认false  selector:      matchLabels:      app: counter-pod    matchExpressions:      - &#123;key: app, operator: In, values: [counter-pod]&#125;  template:    metadata:      labels:        app: counter-pod    spec:      restartPolicy: Never #重启策略只能设置为Never或OnFailure      containers:      - name: counter        image: busybox:1.30\n\nCronJob(cj)CronJob以job控制器为其管控对象，并借助它管理pod资源对象，CronJob可以在特点时间点反复运行job任务\napiVersion: batch/v1beta1kind: CronJobmetadata:  name:  namespace:  labels:    controller: cronjobspec:  schedule:      #crom格式的作业调度运行时间点  concurrencyPolicy:  #并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次作业  Allow 允许jobs并发运行（默认） Forbid 禁止并发运行，上一次尚未完成，则跳过下一次运行   Replace 替换，取消当前作业并用新作业替换它  failedJobHistoryLimit:  #为失败的任务执行保留的历史记录数，默认1  successfulJobHistoryLimit:  #为成功的任务执行保留的历史记录数，默认3  startingDeadlineSecond: #启动作业错误的超时时长  jobTemplate:  #job控制器    metadata:    spec:      completions: 1 #指定job需要成功运行pods的次数，默认1      parallelism: 1 #指定job在任一时刻应该并发运行的pods数量，默认1      activeDeadlineSecond: 30 #指定job可运行的时间期限，超过时间还未结束，系统会尝试终止      backoffLimit: 6  #指定job失败后进行重试的次数，默认6      manualSelector: true  # 是否可以使用selector选择器选择pod,默认false      selector:          matchLabels:          app: counter-pod        matchExpressions:          - &#123;key: app, operator: In, values: [counter-pod]&#125;      template:        metadata:          labels:            app: counter-pod        spec:          restartPolicy: Never #重启策略只能设置为Never或OnFailure          containers:          - name: counter            image: busybox:1.30\n\nServiceservice很多情况下只是一个概念，真正起作用的是kube-proxy,kube-proxy会将最新的service信息转换成对应的访问规则\napiVersion: v1kind: Servicemetadata:  name:  namespace:spec:  selector:   #确定当前service代理哪些pod    app: nginx  type:  #service类型  clusterIP:  #虚拟服务的ip地址  sessionAffinity:  #session亲和性，支持clusterIP/None2个选项  ports:    - protocol: TCP      port: 3017        #service端口      targetPort: 5003  #pod端口      nodePort: 31122   #主机端口\n\nservice类型\n\nclusterIP：默认值，k8s系统自动分配的虚拟IP，只能在集群内部访问\nHeadLiness:这类service不会分配ClusterIP，如果想要访问service,只能通过service的域名进行查询\nNodePort: 将service通过指定node上的端口暴露给外部\nLoadBalancer: 使用外接负载均衡器(集群外)完成服务的负载分发，此模式需要外部云环境支持\nExternalName: 把集群外部的服务引入集群内部，直接使用\n\napiVersion: v1kind: Servicemetadata:  name: service-clusterip  namespace: devspec:  selector:    app: nginx-pod  clusterIP: 10.97.97.97   #service的ip地址，设为None可以启动HeadLinessService  type: ClusterIP  ports:  - port: 80    targetPort: 80\n\n查看ipvs的映射规则ipvsadm -Ln\nNodePort类型的ServiceNodePort工作原理就是将service的端口映射到Node的一个端口上，通过NodeIp:NodePort来访问service\n数据存储Volume是pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个pod的多个容器挂载到具体文件目录下，Volume支持多种类型：\n\n简单存储：EmptyDir&#x2F;HostPath&#x2F;NFS\n高级存储：PV&#x2F;PVC\n配置存储：ConfigMap&#x2F;Secret\n\n简单存储EmptyDirEmptyDir就是宿主机上的空目录，当pod被分配到Node时创建，当pod销毁，EmptyDir中的数据也会被永久删除，它的用途：\n\n临时空间，某应用程序运行时的临时目录\n一个容器需要从另一个容器获取数据（同一个pod多容器共享目录）\n\nHostPathHostPath将node主机中实际的目录挂在Pod中，这样pod销毁了，数据依据可以存在主机上\nNFSHostPath可以解决数据持久化的问题，但一旦node节点故障了，pod如果转移到别的节点，又会出现问题，此时需要单独的网络存储系统，比较常用的NFS&#x2F;CIFS\n高级存储存储系统有很多，要求用户全部掌握不现实，为了屏蔽底层实现，k8s引入PV和PVC2种资源对象\nPV（Persistent Volume）是对底层共享的抽象\nPVC（Persistent Volume Claim）持久化卷声明，用户对存储需求的声明，即用户向系统发起资源需求申请\nPVPV是存储资源的抽象\napiVersion: v1kind: PersistentVolumemetadata:  name: pv2spec:  nfs:   #存储类型，与底层存储对应  capacity:  \tstorage: 2Gi  accessModes:\t  #访问模式  storageClassName:   #存储类型  PersistentVolumeReclaimPolicy:  #回收策略\n\nPVCPVC是资源的申请，用来声明对存储空间&#x2F;访问方式&#x2F;存储类别需求信息\napiVersion: v1kind: PersistentVolumeClaimmetadata:  name: pvc  namespace: devspec:  accessModes:\t  #访问模式  storageClassName:   #存储类型  selector:    #采用标签对PV选择  resources:   #请求空间  \trequests:  \t  storage: 5Gi\n\nConfigMapConfigMap主要用来存储配置信息\napiVersion: v1kind: ConfigMapmetadata:  name: configmap  namespace: devdata:  info:  \tusername: admin  \tpassword: 123456\n\nSecretSecret主要用来存储敏感信息，例如：密码&#x2F;密匙&#x2F;证书\n","categories":["容器"],"tags":["学习","kubernetes"]},{"title":"Reactor 3 Guide","url":"/java4u/2022/08/12/Reactor%203%20Guide/","content":"参考地址：projectreactor\n1.反应式编程简介Reactive programming is an asynchronous programming paradigm concerned with data streams and the propagation of change. This means that it becomes possible to express static (e.g. arrays) or dynamic (e.g. event emitters) data streams with ease via the employed programming language(s).\n为什么需要异步响应库？\n阻塞可能是浪费阻塞会浪费资源，一旦程序涉及延迟，就会浪费资源，因为线程（可能多线程）会处于空闲状态，等待数据\n救援的异步性？Java提供2种异步编程模型：\n\n回调：需要一个callback参数，当结果可用时调用该参数\nFutures：异步方法立即返回future，该值不是立即可用，可以轮询对象，直到该值可用\n\n两者都有局限性，回调很难组合，很快导致代码难以阅读和维护（回调地狱）；Future通过调用get()方法容易导致对象的另一种阻塞，不支持惰性计算，缺乏对多个值和高级错误处理的支持\n2.反应堆核心特点Flux，一个0-N项的异步序列Mono，异步0-1结果","categories":["文档总结"],"tags":["Reactor","参考资料"]},{"title":"spring技术栈","url":"/java4u/2022/08/10/spring%E6%8A%80%E6%9C%AF%E6%A0%88/","content":"spring技术栈描述\n1.Reactor Core&#x2F;Reactor Project  反应式编程，开发webflux项目\n\n2.Spring Batch  批处理架构，执行job的调度任务和与job交互，一个job可以分为多个step进行处理数据  \n\n3.Spring Data JPA  持久化框架\n\n4.Spring Security  安全框架，为 Java 应用程序提供身份验证和授权的框架\n\n5.Spring Boot  用最小的配置轻松创建spring程序\n\n6.Spring Cloud Task  允许用户将几乎任何 Spring Boot 应用程序作为短期任务执行  Spring Cloud Task可以在平台环境中执行短生命周期的应用，并记录这些应用的结果，  经由通过消息通知的机制来集成各个tasks。通过这特性就可以实现让短生命周期的应用像长生命周期的应用一样组成微服务架构。\n\n7.Spring AMQP  将核心 Spring 概念应用于基于 AMQP 的消息传递解决方案的开发\n\n8.Spring Cloud Stream  为了解决系统中不同中间件的适配问题，出现了cloud stream，采用适配绑定的方式，自动给不同的MQ之间进行切换。  目前仅仅支持RabbitMQ和Kafka\n\n9.Spring Data REST  Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现  只需编写实体类和dao层接口就会自动隐藏式生成相关的restful增删改查和分页查询等也可以自定义接口\n\n10.Spring Cloud Data Flow  基于微服务的，专门用于流式和批式数据处理的框架（相当于Spring Batch 和 Spring Cloud Task的控制台）\n\n11.Spring HATEOAS  创建遵循 HATEOAS 原则的 REST 表示，在资源的表达中包含了链接信息。客户端可以根据链接来发现可以执行的动作\n\n12 Spring LDAP  简化 Java 中的 LDAP 编程的库\n\n13 Spring XD  Spring XD 是一个统一的，分布式，可扩展的系统用于数据摄取，实时分析，批量处理和数据导出。该项目的目标是简化大数据应用的开发\n\n14 Spring Cloud Consul  Consul是 HashiCorp 公司推出的开源工具，用于实现分布式系统的服务发现与配置\n\n15 Spring Session  解决分布式系统session共享问题\n\n16 Spring Statemachine  供应用程序开发人员在 Spring 应用程序中使用状态机概念\n\n\n","categories":["文档总结"],"tags":["参考资料","spring"]},{"title":"80. 删除有序数组中的重复项 II","url":"/java4u/2022/08/01/80.%20%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20II/","content":"80. 删除有序数组中的重复项 II给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n说明：\n为什么返回数值是整数，但输出的答案是数组呢？请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len &#x3D; removeDuplicates(nums);&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) {    print(nums[i]);}\n示例 1：\n输入：nums &#x3D; [1,1,1,2,2,3]输出：5, nums &#x3D; [1,1,2,2,3]解释：函数应返回新长度 length &#x3D; 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。\n示例 2：\n输入：nums &#x3D; [0,0,1,1,1,1,2,3,3]输出：7, nums &#x3D; [0,0,1,1,2,3,3]解释：函数应返回新长度 length &#x3D; 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 10^4-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^4nums 已按升序排列\n刷leetcode正好到200道了，纪念下\n/** * 因为给定数组是有序的，所以相同元素必然连续。我们可以使用双指针解决本题，遍历数组检查每一个元素是否应该被保留， * 如果应该被保留，就将其移动到指定位置。具体地，我们定义两个指针 slow 和 fast 分别为慢指针和快指针，其中慢指针表示处理出的数组的长度， * 快指针表示已经检查过的数组的长度，即 nums[fast] 表示待检查的第一个元素，nums[slow−1] 为上一个应该被保留的元素所移动到的指定位置。 * 因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 nums[slow−2] 是否和当前待检查元素 nums[fast] 相同。 * 当且仅当 nums[slow−2]=nums[fast] 时，当前待检查元素 nums[fast] 不应该被保留（因为此时必然有 nums[slow−2]=nums[slow−1]=nums[fast]）。 * 最后，slow 即为处理好的数组的长度。 * * 特别地，数组的前两个数必然可以被保留，因此对于长度不超过 2 的数组，我们无需进行任何处理，对于长度超过 2 的数组，我们直接将双指针的初始值设为 2 即可。 * * @param nums * @return */public int removeDuplicates(int[] nums) &#123;    int n = nums.length;    if (n &lt;= 2) &#123;        return n;    &#125;    //慢指针表示处理完的位置，它出现的元素最多出现两次    //快指针表示被检查的元素    int slow = 2, fast = 2;    while (fast &lt; n) &#123;        if (nums[slow - 2] != nums[fast]) &#123;            nums[slow] = nums[fast];            ++slow;        &#125;        ++fast;    &#125;    return slow;&#125;//保留几个相同数字的通用解法public int removeDuplicates2(int[] nums) &#123;    return process(nums, 2);&#125;private int process(int[] nums, int k)&#123;    int slow = k;    int fast = k;    while (fast &lt; nums.length)&#123;        if(nums[slow-k]!=nums[fast])&#123;            nums[slow]=nums[fast];            slow++;        &#125;        fast++;    &#125;    return slow;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"592. 分数加减运算","url":"/java4u/2022/07/27/592.%20%E5%88%86%E6%95%B0%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97/","content":"592. 分数加减运算给定一个表示分数加减运算的字符串 expression ，你需要返回一个字符串形式的计算结果。这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2&#x2F;1。\n示例 1:\n输入: expression &#x3D; “-1&#x2F;2+1&#x2F;2”输出: “0&#x2F;1”\n示例 2:\n输入: expression &#x3D; “-1&#x2F;2+1&#x2F;2+1&#x2F;3”输出: “1&#x2F;3”\n示例 3:\n输入: expression &#x3D; “1&#x2F;3-1&#x2F;2”输出: “-1&#x2F;6”\n提示:\n输入和输出字符串只包含 ‘0’ 到 ‘9’ 的数字，以及 ‘&#x2F;‘, ‘+’ 和 ‘-‘。输入和输出分数格式均为 ±分子&#x2F;分母。如果输入的第一个分数或者输出的分数是正数，则 ‘+’ 会被省略掉。输入只包含合法的最简分数，每个分数的分子与分母的范围是  [1,10]。 如果分母是1，意味着这个分数实际上是一个整数。输入的分数个数范围是 [1,10]。最终结果的分子与分母保证是 32 位整数范围内的有效整数。  \n很久没有记录做的题了，今天记录下“分数加减运算”。看到题目想到数学模拟，直接模拟运算步骤。先将表达式进行解析，将所有正数放入正数集合，负数放入负数集合（去掉“-”），之后分别对2个集合进行求和可以不用考虑“-”的情况。最后用正数和减去负数和即可得到结果。相加和相减的流程大致相同，其实可以考虑使用一个函数。以求和举例：\n\n获取2数分母的最小公倍数cm\n求和的分子为（cm&#x2F;分母 * 分子）之和\n对得到的分数进行约分，即分子、分母都除以最大公约数\n\n得到的代码不算优雅，不过耗时和内存消耗都相当不错\npublic String fractionAddition(String expression) &#123;    //如何分割字符串    String[] split = expression.split(&quot;\\\\+&quot;);    //负数    List&lt;String&gt; negative = new ArrayList&lt;&gt;();    //正数    List&lt;String&gt; positive = new ArrayList&lt;&gt;();    for (String s : split) &#123;        if (s.contains(&quot;-&quot;)) &#123;            if (s.startsWith(&quot;-&quot;)) &#123;                if (s.substring(1).contains(&quot;-&quot;)) &#123;                    //-a-b-c                    String[] ss = s.split(&quot;-&quot;);                    negative.addAll(Arrays.asList(ss));                &#125; else &#123;                    //-a                    negative.add(s.substring(1));                &#125;            &#125; else &#123;                // a-b-c                String[] ss = s.split(&quot;-&quot;);                positive.add(ss[0]);                negative.addAll(Arrays.asList(ss).subList(1, ss.length));            &#125;        &#125; else &#123;            positive.add(s);        &#125;    &#125;    String p = &quot;&quot;;    for (String s : positive) &#123;        p = add(p, s);    &#125;    String n = &quot;&quot;;    for (String s : negative) &#123;        n = add(n, s);    &#125;    return subtract(p, n);&#125;private String subtract(String a, String b) &#123;    if (a.equals(&quot;&quot;)) return &quot;-&quot; + b;    if (b.equals(&quot;&quot;)) return a;    StringBuilder stringBuilder = new StringBuilder(&quot;&quot;);    String[] sa = a.split(&quot;/&quot;);    int ma = Integer.parseInt(sa[0]);    int da = Integer.parseInt(sa[1]);    String[] sb = b.split(&quot;/&quot;);    int mb = Integer.parseInt(sb[0]);    int db = Integer.parseInt(sb[1]);    int cm = getCM(da, db);    ma = (cm / da) * ma;    mb = (cm / db) * mb;    int m = ma - mb;    if (m == 0) return &quot;0/1&quot;;    boolean nf = false;    if (m &lt; 0) &#123;        nf = true;        m = -m;    &#125;    int d = cm;    int gcd = gcd(m,d);    stringBuilder.append(nf ? &quot;-&quot; : &quot;&quot;)            .append(m / gcd)            .append(&quot;/&quot;)            .append(d / gcd);    return stringBuilder.toString();&#125;private String add(String a, String b) &#123;    if (a.equals(&quot;&quot;)) return b;    if (b.equals(&quot;&quot;)) return a;    StringBuilder stringBuilder = new StringBuilder(&quot;&quot;);    String[] sa = a.split(&quot;/&quot;);    int ma = Integer.parseInt(sa[0]);    int da = Integer.parseInt(sa[1]);    String[] sb = b.split(&quot;/&quot;);    int mb = Integer.parseInt(sb[0]);    int db = Integer.parseInt(sb[1]);    int cm = getCM(da, db);    ma = (cm / da) * ma;    mb = (cm / db) * mb;    int m = ma + mb;    int d = cm;    int gcd = gcd(m,d);    stringBuilder.append(m / gcd)            .append(&quot;/&quot;)            .append(d / gcd);    return stringBuilder.toString();&#125;//最大公因数gcd(a,b)private int gcd(int a, int b) &#123;    if (a == 0) return b;    return gcd(b % a, a);&#125;//最小公倍数=a*b/gcd(a,b)private int getCM(int a, int b)&#123;    return a*b/gcd(a,b);&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","数学"]},{"title":"Elasticsearch","url":"/java4u/2022/06/26/Elasticsearch/","content":"Elasticsearch简介Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful 接口\nElasticsearch功能\n分布式的搜索引擎和数据分析引擎搜索：互联网搜索、电商网站站内搜索、OA系统查询数据分析：电商网站查询近一周哪些品类的图书销售前十；新闻网站，最近3天阅读量最高的十个关键词，舆情分析\n全文检索，结构化检索，数据分析\n对海量数据进行近实时的处理\n\n使用脚本更新，获取原值的同时进行更新\nPOST /test_index/_doc/6/_update&#123;  &quot;script&quot;: &quot;ctx._source.num+=1&quot;&#125;\n\nES内部的主从和并发控制基于乐观锁version来控制\n倒排索引什么是文档和词条？\n\n每一条数据就是一个文档\n对文档中的内容分词，得到的词语就是词条\n\n什么是正向索引？\n\n基于文档id创建索引。查询词条时必须先找到文档，而后判断是否包含词条\n\n什么是倒排索引？\n\n对文档内容分词，对词条创建索引，并记录词条所在文档的信息。查询时先根据词条查询到文档id,而后获取到文档\n\nes与mysql概念对比\n\n\n\nmysql\nelasticsearch\n说明\n\n\n\ntable\nindex\n索引就是文档集合，类似数据库的表\n\n\nrow\ndocument\n文档就是一条条数据，类似数据库的行，文档都是JSON格式\n\n\ncolumn\nfield\n字段，就是文档中的字段，类似数据库中的列\n\n\nschema\nmapping\n映射是索引中文档的约束，例如字段类型约束。类似数据库的表结构\n\n\nSQL\nDSL\nDSL是elasticsearch提供的JSON风格的请求语句，实现CRUD\n\n\n分词器分词器的作用是什么？\n\n创建倒排索引时对文档分词\n用户搜索时，对输入的内容分词\n\nIK分词器有几种模式？\n\nik_smart:智能切分，粗粒度\nik_max_work；最细切分，细粒度\n\nIK分词器如何扩展词条？如何停用词条\n\n利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典\n在词典中添加拓展词条或者停用词条\n\n索引库操作mapping属性mapping是对索引库中文档的约束，常见的mapping属性包括：\n\ntype:字段数据类型，常见简单类型：\n字符串：text(可分词文本)、keyword(精确值，例如：品牌、国家、ip地址)\n数值：long&#x2F;integer&#x2F;short&#x2F;byte&#x2F;double&#x2F;float\n布尔：boolean\n日期：date\n对象：object\n\n\nindex:是否创建索引，默认为true\nanalyzer:使用哪种分词器\nproperties:该字段子字段\nstore:是否在source外在储存一份\n\n索引库操作：\n\n创建索引库：PUT&#x2F;索引名\n查询索引库：GET&#x2F;索引名\n删除索引库：DELETE&#x2F;索引名\n添加字段：PUT&#x2F;索引名&#x2F;_mapping\n\nPUT book/_mapping&#123;  &quot;properties&quot;: &#123;    &quot;name&quot;: &#123;      &quot;type&quot;: &quot;text&quot;    &#125;,    &quot;description&quot;: &#123;      &quot;type&quot;: &quot;text&quot;,      &quot;analyzer&quot;: &quot;english&quot;,      &quot;search_analyzer&quot;: &quot;english&quot;    &#125;,    &quot;pic&quot;: &#123;      &quot;type&quot;: &quot;keyword&quot;    &#125;,    &quot;studymodel&quot;: &#123;      &quot;type&quot;: &quot;text&quot;    &#125;,    &quot;timestamp&quot;: &#123;      &quot;type&quot;: &quot;date&quot;,      &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd&quot;    &#125;,    &quot;price&quot;: &#123;      &quot;type&quot;: &quot;scaled_float&quot;,      &quot;scaling_factor&quot;: 100    &#125;  &#125;&#125;\n\n文档操作：\n\n新增文档：POST&#x2F;索引库名&#x2F;_doc&#x2F;文档id {JSON文档}\n查询文档：GET&#x2F;索引库名&#x2F;_doc&#x2F;文档id\n删除：DELETE&#x2F;索引库名&#x2F;_doc&#x2F;文档id\n修改文档：\n全量修改，删除旧文档，添加新文档 PUT&#x2F;索引库名&#x2F;_doc&#x2F;文档id {JSON文档}\n增量修改，修改指定字段  POST&#x2F;索引库名&#x2F;_update&#x2F;文档id {“doc”:{字段}}\n\n\n\nES支持2种地理坐标数据类型：\n\ngeo_point:由经度纬度确定的一个点 “32.8752, 120.2981”\ngeo_shape:多个geo_point组成的复杂几何图形\n\n字段拷贝可以使用copy_to属性将当前字段拷贝到指定字段：“all”: {  “type”：”text”,  “analyzer”: “ik_max_word”},“brand”: {  “type”: “keyword”,  “copy_to”: “all”}\nDSL查询文档DSL查询分类，常见查询类型：\n\n查询所有：查询所有数据\n全文检索：利用分词器对用户输入内容分词，然后去倒排索引库匹配\nmatch_query\nmulti_match_query\n\n\n精确查询；一般查询keyword、数值、日期等，例如：\nids\nrange\nterm\n\n\n地理查询：根据经纬度查询，例如：\ngeo_distance\ngeo_bounding_box\n\n\n复合查询：复合查询可以将上述查询条件组合起来，合并查询\n\nES支持多索引搜索\nGET &#x2F;book1,book2&#x2F;_searchGET &#x2F;book*&#x2F;_search\n可以直接将book开头的索引一起搜索出来，应用场景：生产环境的log索引可以按日期分开log_to_es_20190910log_to_es_20190911log_to_es_20180910可以查询所有或单个日期的日志\n全文检索match查询\nGET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;FIELD&quot;: &quot;TEXT&quot;    &#125;  &#125;&#125;\n\nmulti_match:与match查询类似，只不过允许同时查询多个字段\nGET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;multi_match&quot;: &#123;      &quot;query&quot;: &quot;TEXT&quot;,      &quot;fields&quot;: [&quot;FIELD1&quot;,&quot;FIELD2&quot;]    &#125;  &#125;&#125;\n\n各类查询#term查询,精确查询GET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;term&quot;: &#123;      &quot;FIELD&quot;: &#123;        &quot;value&quot;: &quot;VALUE&quot;      &#125;    &#125;  &#125;&#125;#range查询GET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;range&quot;: &#123;      &quot;FIELD&quot;: &#123;        &quot;gte&quot;: 10,        &quot;lte&quot;: 20      &#125;    &#125;  &#125;&#125;#Fuzzy query#返回包含与搜索词类似词的文档，编辑距离更改 box -&gt; fox删除 aple -&gt; apple插入 sick -&gt; sic调换字符 ACT -&gt; CATGET /book/_search&#123;  &quot;query&quot;: &#123;    &quot;fuzzy&quot;: &#123;      &quot;description&quot;: &#123;        &quot;value&quot;: &quot;jave&quot;      &#125;    &#125;  &#125;&#125;#正则查询GET /book/_search&#123;  &quot;query&quot;: &#123;    &quot;regexp&quot;: &#123;      &quot;description&quot;: &#123;        &quot;value&quot;: &quot;j.*a&quot;,        &quot;flags&quot;: &quot;ALL&quot;,        &quot;max_determinized_states&quot;: 10000,        &quot;rewrite&quot;: &quot;constant_score&quot;      &#125;    &#125;  &#125;&#125;\n\n地理查询geo_bounding_box:查询geo_point落在某个矩形范围的所有文档\nGET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;geo_bounding_box&quot;: &#123;      &quot;FIELD&quot;: &#123;        &quot;top_left&quot;: &#123;          &quot;lat&quot;: 31.1,          &quot;lon&quot;: 121.5        &#125;,        &quot;bottom_right&quot;: &#123;          &quot;lat&quot;: 30.9,          &quot;lon&quot;: 121.7        &#125;      &#125;    &#125;  &#125;&#125;\n\ngeo_distance:查询到指定中心点小于某个距离值的所有文档\nGET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;geo_distance&quot;: &#123;      &quot;distance&quot;: &quot;15km&quot;,      &quot;FIELD&quot;: &quot;31.21,121.5&quot;    &#125;  &#125;&#125;\n\n复合查询相关性算分：TF（词条频率）&#x3D; 词条出现次数&#x2F;文档中词条总数\nTF-IDF算法IDF（逆文档频率）&#x3D; log(文档总数&#x2F;包含词条的文档总数)score &#x3D; TF * IDF(1–n)\nBM25算法score(Q,d)&#x3D;log(1+(N-n+0.5)&#x2F;(n+0.5))fi&#x2F;(fi+k1(1-b+b*dl&#x2F;avgdl));\nFunction Score Query可以修改文档的相关性算分，根据新得到的算分排序\nGET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;function_score&quot;: &#123;      &quot;query&quot;: &#123;&quot;match&quot;: &#123;&quot;all&quot;: &quot;外滩&quot;&#125;&#125;,       //原始查询条件，搜索文档并 根据相关性打分      &quot;function&quot;: [        &#123;          &quot;filter&quot;: &#123;&quot;term&quot;: &#123;&quot;id&quot;: &quot;1&quot;&#125;&#125;,      //过滤条件，符合文档才会被重新算分          &quot;weight&quot;: 10                          //算分函数，将来与query score运算        &#125;      ],      &quot;boot_mode&quot;: &quot;multiply&quot;                   //加权模式，定义function score与query score运算方式    &#125;  &#125;&#125;\n\nBoolean Query布尔查询是一个或多个查询子句的组合，组合方式：\n\nmust:必须匹配每个子查询，&amp;&amp;\nshould:选择性匹配子查询，||\nmust_not:必须不匹配，不参与算分，！\nfilter:必须匹配，不参与算分\n\n需求：搜索名字包含“如家”，价格不高于400，在坐标31.21，121.5周围10KM范围的酒店\n查询计划(定位错误语法)\nGET &#x2F;book&#x2F;_validate&#x2F;query?explain{  “query”: {    “match”: {      “description”: “java程序员”    }  }}\nGET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123;          &quot;match&quot;: &#123;&quot;name&quot;: &quot;如家&quot;&#125;        &#125;      ],      &quot;must_not&quot;: [        &#123;          &quot;range&quot;: &#123;&quot;price&quot;: &#123;&quot;gt&quot;: 400&#125;&#125;        &#125;      ],      &quot;filter&quot;: [        &#123;          &quot;geo_distance&quot;: &#123;            &quot;distance&quot;: &quot;10km&quot;, &quot;location&quot;: &#123;&quot;lat&quot;: 31.21, &quot;lon&quot;: 121.5&#125;          &#125;        &#125;      ]    &#125;  &#125;&#125;\n\n搜索结果处理排序elasticsearch默认根据相关度排序。可以排序字段类型：keyword、数值类型、地理坐标类型、日期类型\nGET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;: &#123;&#125;  &#125;,  &quot;sort&quot;: [    &#123;      &quot;FIELD&quot;: &quot;desc&quot;    &#125;  ]&#125;#地理排序GET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;: &#123;&#125;  &#125;,  &quot;sort&quot;: [    &#123;      &quot;_geo_distance&quot;: &#123;        &quot;FIELD&quot;: &quot;纬度，经度&quot;,        &quot;order&quot;: &quot;asc&quot;,        &quot;unit&quot;: &quot;km&quot;      &#125;    &#125;  ]&#125;\n\n分页elasticsearch默认只返回top10数据\nGET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;: &#123;&#125;  &#125;,  &quot;from&quot;: 990,     //分页开始位置，默认为0  &quot;size&quot;: 10,      //期望获取的文档总数  &quot;sort&quot;: [    &#123;&quot;price&quot;: &quot;asc&quot;&#125;  ]&#125;\n\n深度分页问题：ES是分布式的，在ES集群里数据会被分到多个分片上，如果需要排序，需要获取所有分片的结果，重新排序取前几位的数据比如:需要9990-10000的数据需要从每个节点获取前10000条数据给协调节点，协调节点汇总所有数据在进行排序，如果3个主节点就30000条数据排序，浪费机器性能和带宽尽量减少深度分页\n高亮GET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;FIELD&quot;: &quot;TEXT&quot;    &#125;,    &quot;hightlight&quot;: &#123;      &quot;fields&quot;: &#123;         //指定要高亮的字段        &quot;FIELD&quot;: &#123;          &quot;require_field_match&quot;: &quot;true&quot; //默认情况ES搜索字段必须与高亮字段一致          &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;,   //用来标记高亮字段前置标签          &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot;  //用来标记高亮字段后置标签        &#125;      &#125;    &#125;  &#125;&#125;\n\n数据聚合聚合可以实现对文档数据的统计、分析、运算，常见聚合有：\n\n桶（Bucket）聚合：用来对文档做分组\ntermAggregation:按照文档字段值分组\nDate Histogram:按照日期阶梯分组，例如一周为一组，或者一月为一组\n\n\n度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等\n管道（pipeline）聚合：其他聚合的结果为基础做聚合\n\n统计酒店品牌有几种，根据酒店品牌的名称做聚合，Bucket聚合\nGET /hotel/_search&#123;  &quot;size&quot;: 0,   //设置size为0，结果中不包含文档，只包含聚合结果  &quot;aggs&quot;: &#123;   //定义聚合    &quot;brandAgg&quot;: &#123;   //给聚合起个名字      &quot;terms&quot;: &#123;    //聚合类型，按照品牌值聚合        &quot;field&quot;: &quot;brand&quot;,   //参与聚合的字段        &quot;size&quot;: 20     //希望获取的聚合数量      &#125;    &#125;  &#125;&#125;\n\n获取每个品牌的用户评分min&#x2F;max&#x2F;avg  Metrics聚合我们可以利用stats聚合：\nGET /hotel/_search&#123;  &quot;size&quot;: 0,  &quot;aggs&quot;: &#123;    &quot;brandAgg&quot;: &#123;      &quot;term&quot;: &#123;        &quot;field&quot;: &quot;brand&quot;,        &quot;size&quot;: 20      &#125;,      &quot;aggs&quot;: &#123;  //是brands聚合的子聚合，也就是分组后对每组分别计算        &quot;score_stats&quot;: &#123;          &quot;stats&quot;: &#123;   //聚合类型，这里stats可以计算min/max/avg            &quot;field&quot;: &quot;score&quot;          &#125;        &#125;      &#125;    &#125;  &#125;&#125;\n\n自动补全拼音分词器通过拼音对词组进行分词\n自定义分词器\n在创建索引库时，通过settings来配置自定义analyzer\nPUT /test&#123;  &quot;settings&quot;: &#123;    &quot;analysis&quot;: &#123;      &quot;analyzer&quot;: &#123;  //自定义分词器        &quot;my_analyzer&quot;: &#123;  //分词器名称          &quot;tokenizer&quot;: &quot;ik_max_word&quot;,          &quot;filter&quot;: &quot;py&quot;        &#125;      &#125;,      &quot;filter&quot;: &#123;  //自定义tokenizer filter        &quot;py&quot;: &#123;    //过滤器名称          &quot;type&quot;: &quot;pinyin&quot;,   //过滤器类型，这里是pinyin          &quot;keep_full_pinyin&quot;: false,          &quot;keep_joined_full_pinyin&quot;: true,          &quot;keep_original&quot;: true,          &quot;limit_first_letter_length&quot;: 16,          &quot;remove_duplicated_term&quot;: true,          &quot;none_chinese_pinyin_tokenize&quot;: false        &#125;      &#125;    &#125;  &#125;,  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;: &#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;my_analyzer&quot;,      //创建索引使用自定义分词        &quot;search_analyzer&quot;: &quot;ik_smart&quot;   //字段搜索使用ik_smart分词器      &#125;    &#125;  &#125;&#125;\n\n自动补全：字段类型是completion类型，字段值是多词条的数组\nGET /test/_search&#123;  &quot;suggest&quot;: &#123;    &quot;title_suggest&quot;: &#123;      &quot;text&quot;: &quot;s&quot;,   //关键字      &quot;completion&quot;: &#123;        &quot;field&quot;: &quot;title&quot;,   //补全查询的字段        &quot;skip_duplicates&quot;: true,   //跳过重复的        &quot;size&quot;: 10     //获取前10条结果      &#125;    &#125;  &#125;&#125;\n\n数据同步elasticsearch中的数据来自mysql数据库，因此mysql数据发生改变，es必须跟着改变，这就是数据同步\n方案一：同步调用  写数据库时同步调用es修改方案二：异步通知  通过mq发布消息方案三：监听binlog   canal监听binlog通知服务\nelasticsearch集群单机es做数据存储，必然面临2个问题：海量数据存储问题、单点故障问题：\n\n海量数据存储问题：将索引库从逻辑上拆分成N个分片，存储到多个节点\n单点故障问题：将分片数据在不同节点备份\n\nES集群的节点角色\n\n\n\n节点类型\n配置参数\n默认值\n节点职责\n\n\n\nmaster eligible\nnode.master\ntrue\n备选主节点：主节点可以管理和记录集群状态、决定分片在哪个节点、处理创建和删除索引库的请求\n\n\ndata\nnode.data\ntrue\n数据节点：存储数据、搜索、聚合、CRUD\n\n\ningest\nnode.ingest\ntrue\n数据存储之前的预处理\n\n\ncoordinating\n上面3个参数都为false则为coordinating节点\n无\n路由请求到其他节点合并其他节点处理的结果，返回给用户\n\n\nES集群的分布式查询分成2个阶段：\n\nscatter phase:分散阶段，协调者会把请求分发到每一个分片\ngather phase:聚集阶段，协调者汇总data node的搜索结果，并处理为最终结果集返回给用户\n\nES集群的故障转移\n集群的master节点会监控集群中的节点状态，如果发现节点宕机，会立即将宕机节点的分片数据\nES分布式基础ES对复杂分布式机制的透明隐藏特性\n分布式机制\n分片机制\n集群发现机制\nshard负载均衡\nshard副本\n\n扩容方案（1）垂直扩容 买入性能更强的机器替换掉原来的机器（2）水平扩容 新增机器加入集群\nrebalance某些服务器负载重或轻。ES集群将某些分片转移到此机器或移走\nmaster节点（1）管理ES集群的元数据：创建删除索引，维护索引的元数据。节点的增加或减少（2）默认情况ES会自动选择一台机器作为master\n节点对等的分布式架构每个节点都能接受所有请求，自动路由\n横向扩容\n分片自动负载均衡，分片向空闲机器转移\n每个节点存储更少分片，系统给与每个分片的资源更多，整体集群性能提高\n扩容极限：节点数大于整体分片数，则必有空闲机器\n超过扩容极限，可以增加副本数，存储和搜索性能更强，容错性更好\n容错性：只要一个索引的所有主分片在，集群就可以运行\n\nES容错机制 master选举，replica容错\nmaster node宕机，自动进行master选举，集群为red\nreplica容错，新master将replica提升为primary shard，集群为yellow\n重启宕机node，新master将缺失的副本分片copy到该节点（增量数据），集群为green\n\n","categories":["分布式搜索"],"tags":["学习"]},{"title":"微服务保护","url":"/java4u/2022/06/13/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/","content":"初始Sentinel雪崩问题及解决方案微服务调用链路中的某个服务故障，引起整个链路中所有微服务都不可用，这就是雪崩\n解决雪崩问题方案：\n\n超时处理：设定超时时间，请求超过一定时间没有响应就返回错误信息，不会无休止等待（CSF处理方式）\n舱壁模式：限定每个业务使用的线程数，避免耗尽整个tomcat资源，因此也叫线程隔离\n熔断降级：由断路器统计业务执行的异常比例，如果超出阙值则会熔断业务，拦截访问该业务的一切请求\n流量控制：限制业务访问的QPS，避免服务因流量突增而故障\n\n服务保护技术对比\n\n\n\n\nSentinel\nHystrix\n\n\n\n隔离策略\n信号量隔离\n线程池隔离、信号量隔离\n\n\n熔断降级策略\n基于慢调用比例或异常比例\n基于失败比率\n\n\n限流\n基于QPS，支持基于调用关系的限流\n有限的支持\n\n\n流量整形\n支持慢启动、匀速排队模式\n不支持\n\n\n控制台\n开箱即用，可配置规则、查看秒级监控、机器发现等\n不完善\n\n\n限流规则流控模式：\n\n直接：统计当前资源的请求，触发阈值时对当前资源直接限流\n关联，统计当前资源相关的另一个资源，触发阈值时对当前资源直接限流\n链路：统计从指定链路访问到本资源的请求，触发阈值，对指定链路限流\n\n关联模式使用场景：用户支付需要更新订单，同时会有查询订单，支付请求更新订单的优先级更高，当支付请求过高时，限制查询\n链路模式使用场景：查询订单和创建订单业务，两者都需要查询商品。针对查询订单进入查询商品的请求统计并限流（防止查询影响创建业务）\n流控效果：\n\n快速失败：达到阈值，新的请求会被立即拒绝并抛出异常\nwarm up：预热模式，对超出阈值的请求同样拒绝并抛出异常。但这种模式阈值会动态变化，从一个较小值逐渐增加到最大阈值\n排队等待：让所有请求按照先后次序排队执行，2个请求间隔不能小于指定时长(CSF的请求队列)将波动的流量变成均匀的流量\n\n热点参数限流：统计参数值相同的请求，判断是否超过QPS\n隔离和降级sentinel支持的雪崩解决方案：\n\n线程隔离（舱壁模式）\n降级熔断\n\n线程隔离有2中实现方式：线程池隔离；信号量隔离\n线程池隔离：\n\n优点：支持主动超时，支持异步调用\n缺点：线程的额外开销比较大\n场景：低扇出\n\n信号量隔离：\n\n优点：轻量，无额外开销\n缺点：不支持主动超时，不支持异步调用\n场景：高频调用，高扇出\n\n熔断降级由断路器统计服务调用的异常比例、慢请求比例，如果超出阈值则熔断该服务，一段时间后，断路器会半开放，尝试放行，如果成功则重新放开服务的访问\n熔断策略：慢调用、异常比例、异常数\n授权规则对请求来源进行判断能否访问\nsentinel三种配置管理模式：\n\n原始模式：保存在内存（不支持持久化）\npull模式：保存在本地文件或数据库（定时轮询，可能数据不一致）\npush模式：保存在nacos,监听变更实时更新\n\n","categories":["微服务保护"],"tags":["学习"]},{"title":"多级缓存","url":"/java4u/2022/06/01/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/","content":"多级缓存就是充分利用请求处理的每个环节，分别添加缓存，减轻tomcat压力，提升服务性能\n1.浏览器客户端缓存2.nginx反向代理 –》 nginx本地缓存（openresty）3.redis缓存4.进程缓存(tomcat)5.数据库\nJVM进程缓存分布式缓存，例如redis:\n\n优点：存储容量更大、可靠性更好、可以在集群间共享\n缺点：访问缓存有网络开销\n\n进程本地缓存，例如Hashmap&#x2F;GuavaCache\n\n优点：读取本地内存，没有网络开销\n缺点：存储容量有限、可靠性较低、无法共享\n\nCaffeine基于Caffeine可以先查询本地缓存，在查询数据库\nCaffeine缓存驱逐策略：\n\n基于大小设置驱逐策略\n基于时间设置驱逐策略\n弱引用（性能不好）\n\nLuaprint(&quot;Hello World!&quot;)local arr = &#123;&#x27;java&#x27;,&#x27;lua&#x27;,&#x27;python&#x27;&#125;local map = &#123;name=&#x27;jack&#x27;,age=21&#125;local function printArr(arr)        if(not arr)then                print(&#x27;数组不能为空&#x27;)                return nil        end        for i,value in ipairs(arr) do                print(value)        endendprintArr(arr)local arr2 = &#123;100,200,300&#125;printArr(arr2)printArr(nil)for index,value in ipairs(arr) do        print(index,value)endfor key,value in pairs(map) do        print(key,value)end\n\nOpenResty1.请求参数的获取\n&#x2F;item&#x2F;1001正则匹配： location ~ &#x2F;item&#x2F;(\\d+) {content_by_lua_file lua&#x2F;item.lua}如何获取请求参数：local id &#x3D; ngx.var[1]  匹配的数据会存入ngx.var数组中\n2.封装http请求\n-- 导入common函数库local common = require(&#x27;common&#x27;)local read_http = common.read_http-- 导入cjson库local cjson = require(&#x27;cjson&#x27;)--获取路径参数local id = ngx.var[1]--查询商品信息local itemJSON = read_http(&quot;/item/&quot; .. id, nil)--查询库存信息local stockJSON = read_http(&quot;/item/stock/&quot; .. id, nil)-- JOSN转化成对象local item = cjson.decode(itemJSON)local stock = cjson.decode(stockJSON)--组合数据item.stock = stock.stockitem.sold=stock.sold-- 返回假数据--ngx.say(&#x27;&#123;&quot;id&quot;:&#x27; .. id ..&#x27;,&quot;name&quot;:&quot;SALSA AIR&quot;&#125;&#x27;)--把item序列化成json返回ngx.say(cjson.encode(itemJSON))\n\nredisredis缓存预热（项目启动时，加载缓存）项目启动时加载各类缓存类，预加载缓存数据\n--导入redislocal redis = require(&#x27;resty.redis&#x27;)--初始化redislocal red = redis::new()red:set_timeouts(1000, 1000, 1000)--关闭redis连接的工具方法，其实是放入连接池local function close_redis(red)\tlocal pool_max_idle_time = 10000 --连接的空闲时间\tlocal pool_size = 100  --连接池大小\tlocal ok, err = red:set_keepalive(pool_max_idle_time,pool_size)\tif not ok then\t\tngx.log(ngx.ERR, &quot;放入redis连接池失败：&quot;+err)\tendend--查询redis方法local function read_redis(ip,port,key)\t--获取一个连接\tlocal ok,err = red:connect(ip,port)\tif not ok then\t\tngx.log(ngx.ERR, &quot;连接redis失败：&quot;+err)\t\treturn nil\tend\t--查询redis\tlocal resp,err=red:get(key)\t--查询失败处理\tif not resp then\t\tngx.log(ngx.ERR,&quot;查询redis失败：&quot;,err,&quot;,key=&quot;,key)\tend\tclose_redis(red)\treturn respend--封装函数，先查询redis,在查询httplocal function read_data(key, expire, path, params)\t-- 查询本地缓存\tlocal val = item_cache:get(key)\tif not val then\t\tngx.log(ngx.ERR, &quot;本地缓存查询失败&quot;)\t\t--查询redis\t\tval = read_redis(&quot;127.0.0.1&quot;,6379,key)\t\t--判断redis是否命中\t\tif not val then\t\t\t--redis查询失败，查询http\t\t\tval = read_http(path, params)\t\tend\tend\t--查询成功，把数据存入本地缓存\titem_cache:set(key, val, expire)\treturn valend\n\n缓存同步缓存同步策略：\n\n设置有效期，到期自动删除\n优势：简单、方便\n缺点：时效性差，缓存可能不一致\n场景：更新频率较低，时效性要求低的业务\n\n\n同步双写，修改数据库的同时，直接修改缓存\n优势：时效性强，缓存与数据库强一致\n缺点：有代码侵入，耦合度高\n场景：对一致性、时效性要求较高的缓存数据\n\n\n异步通知，修改数据库时发送事件通知\n优势：低耦合，可以通知多个缓存\n缺点：时效性一般，存在中间不一致状态\n场景：时效性要求一般，有多个服务需要同步\n\n\n\n监听canal实现缓存同步","categories":["缓存"],"tags":["学习"]},{"title":"高性能队列--Disruptor","url":"/java4u/2022/05/10/%E9%AB%98%E6%80%A7%E8%83%BD%E9%98%9F%E5%88%97--Disruptor/","content":"背景Disruptor是英国外汇交易公司LMAX开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与I&#x2F;O操作处于同样的数量级）\njava内置队列常用的线程安全的内置队列如下：\n\n\n\n队列\n有界性\n锁\n数据结构\n\n\n\nArrayBlockingQueue\nbounded\n加锁\narraylist\n\n\nLinkedBlockingQueue\noptionally-bounded\n加锁\nlinkedlist\n\n\nConcurrentLinkedQueue\nunbounded\n无锁\nlinkedlist\n\n\nLinkedTransferQueue\nunbounded\n无锁\nlinkedlist\n\n\nPriorityBlockingQueue\nunbounded\n加锁\nheap\n\n\nDelayQueue\nunbounded\n加锁\nheap\n\n\n队列底层一般分为三种：数组、链表、堆，堆一般为了实现带有优先级特性的队列，暂时不考虑通过不加锁的方式实现的队列都是无界的（无法保证队列的长度在确定的范围内）；而加锁的方式，可以实现有界队列。在稳定性要求特别高的系统中，为了防止生产者速度过快，导致内存溢出，只能选择有界队列；同时，为了减少Java的垃圾回收对系统性能的影响，会尽量选择array&#x2F;heap格式的数据结构。这样筛选下来，符合条件的队列就只有ArrayBlockingQueue。\nArrayBlockingQueue的问题加锁加锁影响性能,下面是ArrayBlockingQueue通过加锁的方式实现的offer方法，保证线程安全\npublic boolean offer(E e) &#123;    checkNotNull(e);    final ReentrantLock lock = this.lock;    lock.lock();    try &#123;        if (count == items.length)            return false;        else &#123;            insert(e);            return true;        &#125;    &#125; finally &#123;        lock.unlock();    &#125;&#125;\n\n现实编程过程中，加锁通常会严重地影响性能。线程会因为竞争不到锁而被挂起，等锁被释放的时候，线程又会被恢复，这个过程中存在着很大的开销，并且通常会有较长时间的中断，因为当一个线程正在等待锁时，它不能做任何其他事情。如果一个线程在持有锁的情况下被延迟执行，例如发生了缺页错误、调度延迟或者其它类似情况，那么所有需要这个锁的线程都无法执行下去。如果被阻塞线程的优先级较高，而持有锁的线程优先级较低，就会发生优先级反转。\n伪共享ArrayBlockingQueue有三个成员变量： - takeIndex：需要被取走的元素下标 - putIndex：可被元素插入的位置的下标 - count：队列中元素的数量\n这三个变量很容易放到一个缓存行中，但是之间修改没有太多的关联。所以每次修改，都会使之前缓存的数据失效，从而不能完全达到共享的效果。\n\n如上图所示，当生产者线程put一个元素到ArrayBlockingQueue时，putIndex会修改，从而导致消费者线程的缓存中的缓存行无效，需要从主存中重新读取。\n这种无法充分使用缓存行特性的现象，称为伪共享。\nDisruptor的设计方案Disruptor通过以下设计来解决队列速度慢的问题：\n\n环形数组结构为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。\n元素位置定位数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。\n无锁设计每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。\n\n多个生产者多个生产者的情况下，会遇到“如何防止多个线程重复写同一个元素”的问题。Disruptor的解决方法是，每个线程获取不同的一段数组空间进行操作。这个通过CAS很容易达到。只需要在分配元素的时候，通过CAS判断一下这段空间是否已经分配出去即可。\n但是会遇到一个新问题：如何防止读取的时候，读到还未写的元素。Disruptor在多个生产者的情况下，引入了一个与Ring Buffer大小相同的buffer：available Buffer。当某个位置写入成功的时候，便把availble Buffer相应的位置置位，标记为写入成功。读取的时候，会遍历available Buffer，来判断元素是否已经就绪。\n下面分读数据和写数据两种情况介绍。\n读数据1.申请读取到序号n；2.若writer cursor &gt;&#x3D; n，这时仍然无法确定连续可读的最大下标。从reader cursor开始读取available Buffer，一直查到第一个不可用的元素，然后返回最大连续可读元素的位置；3.消费者读取元素。\n如下图所示，读线程读到下标为2的元素，三个线程Writer1&#x2F;Writer2&#x2F;Writer3正在向RingBuffer相应位置写数据，写线程被分配到的最大元素下标是11。\n读线程申请读取到下标从3到11的元素，判断writer cursor&gt;&#x3D;11。然后开始读取availableBuffer，从3开始，往后读取，发现下标为7的元素没有生产成功，于是WaitFor(11)返回6。\n然后，消费者读取下标从3到6共计4个元素。\n\n写数据1.申请写入m个元素；2.若是有m个元素可以写入，则返回最大的序列号。每个生产者会被分配一段独享的空间；3.生产者写入元素，写入元素的同时设置available Buffer里面相应的位置，以标记自己哪些位置是已经写入成功的。\n如下图所示，Writer1和Writer2两个线程写入数组，都申请可写的数组空间。Writer1被分配了下标3到下表5的空间，Writer2被分配了下标6到下标9的空间。\nWriter1写入下标3位置的元素，同时把available Buffer相应位置置位，标记已经写入成功，往后移一位，开始写下标4位置的元素。Writer2同样的方式。最终都写入完成。\n\n防止不同生产者对同一段空间写入的代码，如下所示：\npublic long tryNext(int n) throws InsufficientCapacityException&#123;    if (n &lt; 1)    &#123;        throw new IllegalArgumentException(&quot;n must be &gt; 0&quot;);    &#125;     long current;    long next;     do    &#123;        current = cursor.get();        next = current + n;         if (!hasAvailableCapacity(gatingSequences, n, current))        &#123;            throw InsufficientCapacityException.INSTANCE;        &#125;    &#125;    while (!cursor.compareAndSet(current, next));     return next;&#125;\n\n通过do&#x2F;while循环的条件cursor.compareAndSet(current, next)，来判断每次申请的空间是否已经被其他生产者占据。假如已经被占据，该函数会返回失败，While循环重新执行，申请写入空间。\n总结Disruptor通过精巧的无锁设计实现了在高并发情形下的高性能。\n代码样例：\n/** * @description disruptor代码样例。每10ms向disruptor中插入一个元素，消费者读取数据，并打印到终端 */import com.lmax.disruptor.*;import com.lmax.disruptor.dsl.Disruptor;import com.lmax.disruptor.dsl.ProducerType;import java.util.concurrent.ThreadFactory;public class DisruptorMain&#123;    public static void main(String[] args) throws Exception    &#123;        // 队列中的元素        class Element &#123;            private int value;            public int get()&#123;                return value;            &#125;            public void set(int value)&#123;                this.value= value;            &#125;        &#125;        // 生产者的线程工厂        ThreadFactory threadFactory = new ThreadFactory()&#123;            @Override            public Thread newThread(Runnable r) &#123;                return new Thread(r, &quot;simpleThread&quot;);            &#125;        &#125;;        // RingBuffer生产工厂,初始化RingBuffer的时候使用        EventFactory&lt;Element&gt; factory = new EventFactory&lt;Element&gt;() &#123;            @Override            public Element newInstance() &#123;                return new Element();            &#125;        &#125;;        // 处理Event的handler        EventHandler&lt;Element&gt; handler = new EventHandler&lt;Element&gt;()&#123;            @Override            public void onEvent(Element element, long sequence, boolean endOfBatch)            &#123;                System.out.println(&quot;Element: &quot; + element.get());            &#125;        &#125;;        // 阻塞策略        BlockingWaitStrategy strategy = new BlockingWaitStrategy();        // 指定RingBuffer的大小        int bufferSize = 16;        // 创建disruptor，采用单生产者模式        Disruptor&lt;Element&gt; disruptor = new Disruptor(factory, bufferSize, threadFactory, ProducerType.SINGLE, strategy);        // 设置EventHandler        disruptor.handleEventsWith(handler);        // 启动disruptor的线程        disruptor.start();        RingBuffer&lt;Element&gt; ringBuffer = disruptor.getRingBuffer();        for (int l = 0; true; l++)        &#123;            // 获取下一个可用位置的下标            long sequence = ringBuffer.next();              try            &#123;                // 返回可用位置的元素                Element event = ringBuffer.get(sequence);                 // 设置该位置元素的值                event.set(l);             &#125;            finally            &#123;                ringBuffer.publish(sequence);            &#125;            Thread.sleep(10);        &#125;    &#125;&#125;\n","categories":["进程"],"tags":["Disruptor","队列"]},{"title":"分布式事务","url":"/java4u/2022/05/09/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","content":"CAP定理分布式系统有三个指标：\n\n一致性 用户访问分布式系统任意节点，得到的数据必须一致\n可用性 用户访问集群任意健康节点，必须得到响应\n分区容错 因为网络故障或其他原因导致分布式系统中部分节点与其他节点失去连接，形成独立分区。在集群出现分区时，整个系统也要持续对外提供服务\n\n分布式系统通过网络连接，一定会出现分区问题（P），系统的一致性（C）和可用性（A）无法同时满足\nBASE理论BASE理论对CAP的一种解决思路：\n\n基本可用 系统出现故障时，允许损失部分可用性，保证核心可用\n软状态 一定时间内，允许出现中间状态，临时的不一致状态\n最终一致性 在软状态结束后，最终达到数据一致\n\n分布式事务最大问题是各个子事务的一致性问题，借鉴CAP定理和BASE理论：\n\nAP模式：子事务分别执行和提交，采用补偿机制恢复数据，实现最终一致\nCP模式：子事务执行后相互等待，同时执行，同时回滚，达成强一致（Appframe采用方式）\n\nSeata架构seata事务管理中重要的角色：\n\nTC事务协调者：维护全局和分支事务状态，协调全局事务提交或回滚\nTM事务管理器：定义全局事务范围、开始全局事务、提交或回滚全局事务\nRM资源管理器：管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚\n\nXA模式\nseata的XA模式做了调整（数据库支持，seata只做简单的封装），但大体相似：RM一阶段工作：\n\n注册分支事务到TC\n执行分支业务sql但不提交\n报告执行状态到TC\n\nTC二阶段工作：\n\nTC检测各分支事务执行状态（都成功则通知所有RM提交事务，如果有失败，就通知所有RM回滚事务）\n\nRM二阶段工作：\n\n接受TC指令，提交或回滚事务\n\nXA模式优点：\n\n事务强一致性，满足ACID原则\n常用数据库都支持，实现简单，没有业务代码入侵\n\nXA模式缺点：\n\n第一阶段需要锁定数据库资源，等待二阶段才释放，性能较差\n依赖关系型数据库实现事务\n\nAT模式\nAT同样是分阶段提交事务模型，不过弥补了XA模式中资源锁定周期过长的缺陷\nRM一阶段工作：\n\n注册分支事务\n记录undo-log（数据快照，用于数据恢复和回滚）\n执行业务sql并提交\n报告事务状态\n\nRM二阶段提交时工作：\n\n删除undo-log即可\n\nRM二阶段回滚时工作：\n\n根据undo-log恢复数据到更新前\n\nAT模式与XA模式区别：\n\nXA模式一阶段不提交事务，会锁定资源；AT模式直接提交事务，不锁定资源\nXA模式依赖数据库机制实现；AT模式利用数据快照实现数据回滚\nXA模式强一致；AT模式最终一致\n\nAT模式优点：\n\n一阶段完成直接提交事务，释放资源，性能比较好\n利用全局锁实现读写隔离\n没有代码侵入，框架自动完成回滚和提交\n\nAT模式缺点：\n\n两阶段之间属于软状态，属于最终一致\n框架快照会影响性能，但比XA模式要好得多\n\nTCC模式\nTCC通过人工编码实现数据恢复\n\nTry:资源检测和预留\nConfirm:完成资源操作业务；要求try成功confirm一定能成功\nCancel:预留资源释放，可以理解未try的反向操作\n\nTCC优化：\n\n一阶段完成直接提交事务，性能好\n相比AT模型，无需生成快照，无需使用全局锁\n不依赖数据库事务，可以用于非事务型数据库\n\nTCC缺点：\n\n有代码侵入，需要人为编写\n软状态，事务最终一致\n需要考虑confirm和cancel失败情况，做好幂等处理\n\nTCC空回滚和业务悬挂当某分支事务try阶段阻塞时，可能导致全局事务超时而触发二阶段的cancel操作。对于未执行try操作的分支，此时cancel不能回滚，就做一个空回滚\n对于已经空回滚的业务，如果之后又可以继续执行try，但整个事务已经回滚了，那之后的confirm和cancel就不会执行了，就是业务悬挂。应当阻止执行空回滚后的try操作，避免悬挂\nSaga模式Saga是seata提供的长事务解决方案：\n\n一阶段：直接提交本地事务\n二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚\n\nsaga模式优点：\n\n事务参与者可以基于事件驱动实现异步调用，吞吐高\n一阶段直接提交事务，无锁，性能好\n不用编写TCC中三个阶段，实现简单\n\n缺点：\n\n软状态持续时间不确定，时效性差\n没有锁，没有事务隔离，会有脏写\n\n","categories":["事务"],"tags":["分布式"]},{"title":"将数据库从oracle更换为antDB遇到的问题","url":"/java4u/2022/04/27/%E5%B0%86%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BB%8Eoracle%E6%9B%B4%E6%8D%A2%E4%B8%BAantDB%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","content":"需要变更的地方做下记录：\n1.不使用rowid，antdb不支持rowid\n2.修改配置连接，变更driver\n3.获取SEQ时报错修改批量获取SEQ包中获取SEQ的方式select SEQ_BUSINESS_ID.nextval from generate_series(1,50);\n4.查询缓存时报错第一次查询缓存时，在查询表数据的同时会查询表的字段与主键和同义词里面会用到user这个oracle的特殊词，pg不支持，需要修改获取SQL修改前：\nSELECT C.COLUMN_NAME　  FROM ALL_CONS_COLUMNS C, ALL_CONSTRAINTS KWHERE K.CONSTRAINT_TYPE = &#x27;P&#x27;    \tAND (K.OWNER, K.TABLE_NAME) = (\t\tSELECT USER TABLE_OWNER, TABLE_NAME  \t\tFROM USER_TABLES          \t\tWHERE TABLE_NAME = &#x27;BS_ENTITY_TAG_REL&#x27;        \t\tUNION         \t\tSELECT TABLE_OWNER, TABLE_NAME           \t\tFROM USER_SYNONYMS          \t\tWHERE SYNONYM_NAME = &#x27;BS_ENTITY_TAG_REL&#x27;)    \tAND K.CONSTRAINT_NAME = C.CONSTRAINT_NAME    \tAND K.TABLE_NAME = C.TABLE_NAME    \tAND K.OWNER = C.OWNER  ORDER BY COLUMN_NAME ;\n修改后：\nSELECT c.column_nameFROM ALL_CONS_COLUMNS C, ALL_CONSTRAINTS KWHERE K.CONSTRAINT_TYPE = &#x27;P&#x27;      AND (K.OWNER, K.TABLE_NAME) = (    SELECT owner TABLE_OWNER, TABLE_NAME      FROM USER_TABLES              WHERE TABLE_NAME = &#x27;BS_ENTITY_TAG_REL&#x27; )      AND K.CONSTRAINT_NAME = C.CONSTRAINT_NAME      AND K.TABLE_NAME = C.TABLE_NAME      AND K.OWNER = C.OWNER  ORDER BY COLUMN_NAME ;\n 使用owner代替，同时不使用同义词\n5.修改oracle特定用法\n\n（+）表示外连接，并且总是放在非主表的一方（+）替换为标准SQL  LEFT JOIN 或 RIGHT JOIN\n不使用dblink,使用外部表查询其他中心的数据\n\n","categories":["数据库"],"tags":["更换数据库"]},{"title":"MQ","url":"/java4u/2022/04/24/MQ/","content":"MQ初始MQ同步调用的优点：时效性高\n同步调用存在的问题：\n\n1.耦合度高，每次新加需求需要修改原来的代码（加入短信，积分。。）\n2.性能下降，调用链过长则响应时间变长\n3.资源浪费，调用方在等待响应的时候不能释放请求，高并发场景下浪费系统资源\n4.级联失败，服务提供者出现问题，所有调用方都会出现问题\n\n异步通信的优点：\n\n耦合度降低，修改需求不影响代码，只需要取消订阅即可\n吞吐量提升，可以马上返回调用结果\n故障隔离，服务出现异常不会相互影响\n流量削峰，大量请求由broker缓存\n\n异步通信的缺点：\n\n依赖broker的可靠性、安全性、吞吐能力\n没有明显的流程线，不好追踪管理\n\nRabbitmq如何windows启动rabbitmq\n安装RabbitMQ管理插件：rabbitmq-plugins enable rabbitmq_management 命令进行安装\n紧接着输入 rabbitmq-server.bat 进行启动RabbitMQ服务\nSpringAMQPSpringAMQP默认使用rabbitmq使用@RabbitListener指定队列的名称让spring去接受消息\n分布订阅模式：fanout exchange:发送到绑定的每个queue\ndirect exchange:根据规则将消息路由到指定的queue,因此称之路由模式(根据routingkey进行路由)\ntopic exchange:topic的routingkey必须是多个单词的列表并以.分割（可以使用通配符路由）\n使用MessageConverter使用消息的序列化和反序列化,发送方和接收方的converter必须相同\nRocketMQrocketmq角色\nproducer:消息发送者\nconsumer:消息接收者\nbroker:暂存和传输消息\nnameserver:管理broker\ntopic:区分消息的种类\nmessage queue:相当于topic的分区\n\n","categories":["中间件"],"tags":["MQ"]},{"title":"SpringCloud","url":"/java4u/2022/04/21/SpringCloud/","content":"微服务技术对比\n\n\n\nDubbo\nSpringCloud\nSpringCloudAlibaba\n\n\n\n注册中心\nzookeeper&#x2F;redis\nEureka\nNacos&#x2F;Eureka\n\n\n服务远程调用\nDubbo协议\nFeign(http协议)\nDubbo&#x2F;Feign\n\n\n配置中心\n无\nSpringCloudConfig\nSpringCloudConfig&#x2F;Nacos\n\n\n服务网关\n无\nSpringCloudGateway&#x2F;zuul\nSpringCloudGateway&#x2F;zuul\n\n\n服务监控和保护\ndubbo-admin\nHystrix\nSentinel\n\n\nEurekaSpringCloud使用http协议发起远程调用请求比如   restTemplate.getForObject(“localhost:8081&#x2F;user&#x2F;“+user.getId(), User.class)\n使用Eureka提供服务的注册和发现，使用服务名调用            restTemplate.getForObject(“UserService&#x2F;user”+user.getId(), User.class)\nRibbonRibbon负载均衡流程\norderService  --1.发起请求 http://userservice/user/1--&gt;   4.轮询到某台机 userservice 8001                        |                   |                            |                   |                      2.拉取userservice     3.返回服务列表                        |                   |                        |                   |                            eureka-service\n\nRibbon使用IRule进行负载均衡规则的选择    可以通过bean或修改配置文件修改负载均衡策略\nRibbon是懒加载，第一次访问才会创建loadbalanceClient,请求时间很长，配置饥饿加载可以在项目启动时创建，降低第一次访问的时间（服务预热）\nNacosNacos集群服务管理\n服务的注册与发现（CSF控制台）nacos会展示服务对应的实例及实例地址（关注实例的状态可以给实例设置权重），csf主要展示服务的配置信息（路由策略，负载类型，降级策略，超时设定）\n服务分级存储以机房划分集群，比如：杭州集群、上海集群（CSF的租户概念）\nnacos使用namespace做环境隔离，不同环境无法相互访问\nNacos和Eureka区别1.nacos有临时实例和非临时实例，临时实例心跳监测（失效会被直接剔除），非临时实例nacos主动询问（会一直保持实例）2.nacos主动推送变更消息\nNacos统一配置管理（K8S统一配置）\n统一配置管理，可以进行热更新配置\nFeign使用feign代替resttemplate，声明式远程调用（http客户端）\nFeign底层客户端实现：    URLConnection     默认不支持连接池    Apache HttpClient    OKHttp\nFeign性能优化    1.使用带连接池的替换URLConnection    2.修改日志级别为BASIC和NONE\nFeign的最佳实现：    1.让controller和feignclient继承相同接口    2.Feign抽取调用模块，提供给所有消费者使用\nGateWay网关功能：  1.身份认证和权限校验  2.服务路由和负载均衡  3.请求限流\nzuul基于servlet，属于阻塞式编程，gateway属于响应式编程，具有更好的性能\n路由断言工厂：（满足断言才会路由）path  请求路径必须符合指定规则before  在某个时间点前请求after  在某个时间点后请求\n路由过滤器对进入网关的请求和微服务的响应进行过滤\n针对部分路由的过滤器针对所有路由的过滤器处理一切进入网关的请求和响应（全局过滤器）逻辑自定义\n网关CORS（浏览器询问服务器能否跨域）跨域跨域配置\nwww.taobao.com  www.taobao.org   miaosha.taobao  域名不同的跨域请求\n","categories":["框架"],"tags":["学习"]},{"title":"REDIS深入了解","url":"/java4u/2022/04/20/REDIS%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/","content":"redis数据对象字符串对象（string）、列表对象（list）、哈希对象（hash）、集合（set）对象和有序集合对象（zset）\n\n1.redisObjectredis是以键值对存储数据的，所以对象又分为键对象和值对象，即存储一个key-value键值对会创建两个对象，键对象和值对象。键对象总是一个字符串对象，而值对象可以是五大对象中的任意一种。\n#define REDIS_LRU_BITS 24#define REDIS_LRU_CLOCK_MAX ((1&lt;&lt;REDIS_LRU_BITS)-1) /* Max value of obj-&gt;lru */#define REDIS_LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */typedef struct redisObject &#123;    // 类型    //类型属性存储的是对象的类型，也就是我们说的 string、list、hash、set、zset中的一种    unsigned type:4;    // 编码    unsigned encoding:4;    // 对象最后一次被访问的时间    unsigned lru:REDIS_LRU_BITS; /* lru time (relative to server.lruclock) */    // 引用计数    int refcount;    // 指向实际值的指针    void *ptr;&#125; robj;\n\n2.String字符串对象底层数据结构实现为简单动态字符串（SDS）和直接存储，但其编码方式可以是int、raw或者embstr，区别在于内存结构的不同。\n1)int编码，直接保存在ptr属性中\n\n2）raw编码\n在长度特别短时，使用 emb 形式存储 (embedded)，当长度超过 44 时，使用 raw 形式存储\nembstr 存储形式是这样一种存储形式，它将 RedisObject 对象头和 SDS 对象连续存在一起，使用 malloc 方法一次分配。而 raw 存储形式不一样，它需要两次 malloc，两个对象头在内存地址上一般是不连续的。\n 字符串保存的大于32字节的字符串值，则使用简单动态字符串（SDS）结构，并将编码设置为raw，此时内存结构与SDS结构一致，内存分配次数为两次，创建redisObject对象和sdshdr结构，如图：\n\n3）embstr编码\n\n3.list列表对象的编码可以是ziplist和linkedlist之一，当字符串长度较小且元素数量也较小时，会转换成压缩列表，否则都是双端列表\n1）linkedlistlinkedlist编码底层采用双端链表实现，每个双端链表节点都保存了一个字符串对象，在每个字符串对象内保存了一个列表元素。\n\n2）ziplistziplist是list键、hash键以及zset键的底层实现之一\nZiplist 是为了尽可能地节约内存而设计的特殊编码双端链表。Ziplist 可以储存字符串值和整数值，其中，整数值被保存为实际的整数，而不是字符数组。\nZiplist 的整体布局：\n&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;&lt;entry&gt;&lt;zlend&gt;\n\n\nzlbytes 是一个无符号整数，保存着 ziplist 使用的内存数量。通过这个值，程序可以直接对 ziplist 的内存大小进行调整，而无须为了计算 ziplist 的内存大小而遍历整个列表。\nzltail保存着到达列表中最后一个节点的偏移量。这个偏移量使得对表尾的 pop 操作可以在无须遍历整个列表的情况下进行。\nzllen保存着列表中的节点数量。当 zllen 保存的值大于 2**16-2 时，程序需要遍历整个列表才能知道列表实际包含了多少个节点。\nZIPLIST 节点：每个 ziplist 节点的前面都带有一个 header ，这个 header 包含两部分信息：\n\n1)前置节点的长度，在程序从后向前遍历时使用。2)当前节点所保存的值的类型和长度。\n/* 空白 ziplist 示例图area        |&lt;---- ziplist header ----&gt;|&lt;-- end --&gt;|size          4 bytes   4 bytes 2 bytes  1 byte            +---------+--------+-------+-----------+component   | zlbytes | zltail | zllen | zlend     |            |         |        |       |           |value       |  1011   |  1010  |   0   | 1111 1111 |            +---------+--------+-------+-----------+                                       ^                                       |                               ZIPLIST_ENTRY_HEAD                                       &amp;address                        ZIPLIST_ENTRY_TAIL                                       &amp;                               ZIPLIST_ENTRY_END非空 ziplist 示例图area        |&lt;---- ziplist header ----&gt;|&lt;----------- entries -------------&gt;|&lt;-end-&gt;|size          4 bytes  4 bytes  2 bytes    ?        ?        ?        ?     1 byte            +---------+--------+-------+--------+--------+--------+--------+-------+component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |            +---------+--------+-------+--------+--------+--------+--------+-------+                                       ^                          ^        ^address                                |                          |        |                                ZIPLIST_ENTRY_HEAD                |   ZIPLIST_ENTRY_END                                                                  |                                                        ZIPLIST_ENTRY_TAIL*/\n\n/* \\* 保存 ziplist 节点信息的结构 */typedef struct zlentry &#123;  // prevrawlen ：前置节点的长度  // prevrawlensize ：编码 prevrawlen 所需的字节大小  unsigned int prevrawlensize, prevrawlen;  // len ：当前节点值的长度  // lensize ：编码 len 所需的字节大小  unsigned int lensize, len;  // 当前节点 header 的大小  // 等于 prevrawlensize + lensize  unsigned int headersize;  // 当前节点值所使用的编码类型  unsigned char encoding;  // 指向当前节点的指针  unsigned char *p;&#125; zlentry;\n\n4.hash哈希对象的编码可以是ziplist和hashtable之一。\n1）ziplistziplist编码的哈希对象底层实现是压缩列表，在ziplist编码的哈希对象中，key-value键值对是以紧密相连的方式放入压缩链表的，先把key放入表尾，再放入value；键值对总是向表尾添加。\n\n2）hashtable/* \\* 哈希表节点 */typedef struct dictEntry &#123;  // 键  void *key;  // 值  union &#123;​    void *val;​    uint64_t u64;​    int64_t s64;  &#125; v;  // 指向下个哈希表节点，形成链表  struct dictEntry *next;&#125; dictEntry;\n\n/* \\* 哈希表 * \\* 每个字典都使用两个哈希表，从而实现渐进式 rehash 。 */typedef struct dictht &#123;  // 哈希表数组  dictEntry **table;  // 哈希表大小  unsigned long size;  // 哈希表大小掩码，用于计算索引值  // 总是等于 size - 1  unsigned long sizemask;  // 该哈希表已有节点的数量  unsigned long used;&#125; dictht;\n\n/* \\* 字典 */typedef struct dict &#123;  // 类型特定函数  dictType *type;  // 私有数据  void *privdata;  // 哈希表  dictht ht[2];  // rehash 索引  // 当 rehash 不在进行时，值为 -1  int rehashidx; /* rehashing not in progress if rehashidx == -1 */  // 目前正在运行的安全迭代器的数量  int iterators; /* number of iterators currently running */&#125; dict;\n\nht[0]:字典使用的dictht哈希表，ht[1]哈希表进行rehash时使用。\nrehash步骤：\n为字典的ht[1]哈希表分配空间，大小就是ht[0].used。将ht[0]中所有的键值对rehash到ht[1]上面。当ht[0]包含的所有键都迁移到ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新建一个空白哈希表，为下次rehash准备。\n5.set集合对象的编码可以是intset和hashtable之一。\n1）intset编码intset编码的集合对象底层实现是整数集合，所有元素都保存在整数集合中。\n\n1.zset有序集合的编码可以是ziplist和skiplist之一。\n1）ziplist编码ziplist编码的有序集合对象底层实现是压缩列表，其结构与哈希对象类似，不同的是两个紧密相连的压缩列表节点，第一个保存元素的成员，第二个保存元素的分值，而且分值小的靠近表头，大的靠近表尾。\n\n2）skiplist编码skiplist编码的有序集合对象底层实现是跳跃表和字典两种；\n每个跳跃表节点都保存一个集合元素，并按分值从小到大排列；节点的object属性保存了元素的成员，score属性保存分值；\n字典的每个键值对保存一个集合元素，字典的键保存元素的成员，字典的值保存分值。\n跳跃表解决数据查询问题\n\n/* ZSETs use a specialized version of Skiplists *//* * 跳跃表节点 */typedef struct zskiplistNode &#123;    // 成员对象    robj *obj;    // 分值    double score;    // 后退指针    struct zskiplistNode *backward;    // 层    struct zskiplistLevel &#123;        // 前进指针        struct zskiplistNode *forward;        // 跨度        unsigned int span;    &#125; level[];&#125; zskiplistNode;\n\n/* * 跳跃表 */typedef struct zskiplist &#123;    // 表头节点和表尾节点    struct zskiplistNode *header, *tail;    // 表中节点的数量    unsigned long length;    // 表中层数最大的节点的层数    int level;&#125; zskiplist;\n\n/* * 有序集合 */typedef struct zset &#123;    // 字典，键为成员，值为分值    // 用于支持 O(1) 复杂度的按成员取分值操作    dict *dict;    // 跳跃表，按分值排序成员    // 用于支持平均复杂度为 O(log N) 的按分值定位成员操作    // 以及范围操作    zskiplist *zsl;&#125; zset;\n\n3.redisClient/* With multiplexing we need to take per-client state. * Clients are taken in a liked list. * * 因为 I/O 复用的缘故，需要为每个客户端维持一个状态。 * * 多个客户端状态被服务器用链表连接起来。 */typedef struct redisClient &#123;    // 套接字描述符    int fd;    // 当前正在使用的数据库    redisDb *db;    // 当前正在使用的数据库的 id （号码）    int dictid;    // 客户端的名字    robj *name;             /* As set by CLIENT SETNAME */    // 查询缓冲区    sds querybuf;    // 查询缓冲区长度峰值    size_t querybuf_peak;   /* Recent (100ms or more) peak of querybuf size */    // 参数数量    int argc;    // 参数对象数组    robj **argv;    // 记录被客户端执行的命令    struct redisCommand *cmd, *lastcmd;    // 请求的类型：内联命令还是多条命令    int reqtype;    // 剩余未读取的命令内容数量    int multibulklen;       /* number of multi bulk arguments left to read */    // 命令内容的长度    long bulklen;           /* length of bulk argument in multi bulk request */    // 回复链表    list *reply;    // 回复链表中对象的总大小    unsigned long reply_bytes; /* Tot bytes of objects in reply list */    // 已发送字节，处理 short write 用    int sentlen;            /* Amount of bytes already sent in the current                               buffer or object being sent. */    // 创建客户端的时间    time_t ctime;           /* Client creation time */    // 客户端最后一次和服务器互动的时间    time_t lastinteraction; /* time of the last interaction, used for timeout */    // 客户端的输出缓冲区超过软性限制的时间    time_t obuf_soft_limit_reached_time;    // 客户端状态标志    int flags;              /* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */    // 当 server.requirepass 不为 NULL 时    // 代表认证的状态    // 0 代表未认证， 1 代表已认证    int authenticated;      /* when requirepass is non-NULL */    // 复制状态    int replstate;          /* replication state if this is a slave */    // 用于保存主服务器传来的 RDB 文件的文件描述符    int repldbfd;           /* replication DB file descriptor */    // 读取主服务器传来的 RDB 文件的偏移量    off_t repldboff;        /* replication DB file offset */    // 主服务器传来的 RDB 文件的大小    off_t repldbsize;       /* replication DB file size */        sds replpreamble;       /* replication DB preamble. */    // 主服务器的复制偏移量    long long reploff;      /* replication offset if this is our master */    // 从服务器最后一次发送 REPLCONF ACK 时的偏移量    long long repl_ack_off; /* replication ack offset, if this is a slave */    // 从服务器最后一次发送 REPLCONF ACK 的时间    long long repl_ack_time;/* replication ack time, if this is a slave */    // 主服务器的 master run ID    // 保存在客户端，用于执行部分重同步    char replrunid[REDIS_RUN_ID_SIZE+1]; /* master run id if this is a master */    // 从服务器的监听端口号    int slave_listening_port; /* As configured with: SLAVECONF listening-port */    // 事务状态    multiState mstate;      /* MULTI/EXEC state */    // 阻塞类型    int btype;              /* Type of blocking op if REDIS_BLOCKED. */    // 阻塞状态    blockingState bpop;     /* blocking state */    // 最后被写入的全局复制偏移量    long long woff;         /* Last write global replication offset. */    // 被监视的键    list *watched_keys;     /* Keys WATCHED for MULTI/EXEC CAS */    // 这个字典记录了客户端所有订阅的频道    // 键为频道名字，值为 NULL    // 也即是，一个频道的集合    dict *pubsub_channels;  /* channels a client is interested in (SUBSCRIBE) */    // 链表，包含多个 pubsubPattern 结构    // 记录了所有订阅频道的客户端的信息    // 新 pubsubPattern 结构总是被添加到表尾    list *pubsub_patterns;  /* patterns a client is interested in (SUBSCRIBE) */    sds peerid;             /* Cached peer ID. */    /* Response buffer */    // 回复偏移量    int bufpos;    // 回复缓冲区    char buf[REDIS_REPLY_CHUNK_BYTES];&#125; redisClient;\n\n4.zskiplist  跳跃表像这种链表加多级索引的结构，就是跳跃表！\n/* ZSETs use a specialized version of Skiplists *//* * 跳跃表节点 */typedef struct zskiplistNode &#123;    // 成员对象    robj *obj;    // 分值    double score;    // 后退指针    struct zskiplistNode *backward;    // 层    struct zskiplistLevel &#123;        // 前进指针        struct zskiplistNode *forward;        // 跨度        unsigned int span;    &#125; level[];&#125; zskiplistNode;/* * 跳跃表 */typedef struct zskiplist &#123;    // 表头节点和表尾节点    struct zskiplistNode *header, *tail;    // 表中节点的数量    unsigned long length;    // 表中层数最大的节点的层数    int level;&#125; zskiplist;\n\nredis持久化（数据丢失问题）RDBredis数据备份文件，也叫redis数据快照，将内存中所有数据记录到磁盘中。当redis实例故障重启后，从磁盘读取快照文件，恢复数据\nbgsave开始会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入RDB文件\nfork流程：进程不直接操作物理内存，而由操作系统获取物理内存映射的页表。子进程直接fork主进程的页表就获得了主进程的内存数据\nfork采用copy-on-write技术：\n\n当主进程执行读操作，访问共享内存\n当主进程执行写操作，则会拷贝一份数据，执行写操作\n\nRDB缺点：\n\nRDB执行间隔时间长，两次RDB之间写数据有丢失的风险\nfork子进程、压缩、写出RDB文件都比较耗时\n\nAOFAppend Only File(追加文件)。redis处理的每一个写的命令都会记录在AOF文件\nredis主从集群（并发能力问题）启动多个实例，执行 slaveof 主节点地址，即可完成主从集群的搭建\n数据同步原理主从第一次同步是全量同步bgsave将内存生成RDB快照，发送RDB文件给从节点\n全量同步流程：\n\nslave节点请求增量同步replid和偏移量offset\nmaster节点判断replid，发现不一致，拒绝增量同步\nmaster将完整内存数据生成RDB，发送RDB到slave\nslave清空本地数据，加载master的RDB\nmaster将RDB期间的命令记录在repl_baklog，并持续将log中命令发送给slave\nslave执行接收到的命令，保持与master之间的同步\n\nrepl_baklog大小有上限（环状的数组），写满后会覆盖最早的数据。如果slave断开时间过久，导致数据被覆盖，则无法实现增量同步，只能再次全量同步\nredis哨兵（故障恢复问题）哨兵的作用：\n\n监控：sentinel会不断检查master和slave是否按预期工作（心跳机制监测）\n自动故障恢复：如果master故障，sentinel会将一个slave提升为master。当故障恢复后也以新的master为主\n通知：sentinel充当redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送到redis客户端\n\n故障转移步骤：\n\n首先选定一个slave作为新的master，执行 slaveof no one（成为master）\n让所有节点执行slaveof 新master\n修改故障节点配置，添加slaveof新master\n\nredis分片集群（存储能力问题）散列插槽redis会把每一个master节点映射到0-16383共16384个插槽数据key与插槽绑定，redis根据key的有效部分计算插槽值访问集群内任意节点，都会计算出插槽值，之后重定向到对应节点\n","categories":["中间件"],"tags":["学习","源码"]},{"title":"国网发票业务规则整理","url":"/java4u/2022/04/20/%E5%9B%BD%E7%BD%91%E5%8F%91%E7%A5%A8%E4%B8%9A%E5%8A%A1%E8%A7%84%E5%88%99%E6%95%B4%E7%90%86/","content":"功能概述任何费用产生的业务或收费动作都要产生发票。国网暂定只有月结发票和一次性发票，一次性发票由购买物品产生，月结发票在月末时统一生成月结发票发送给客户。\n业务流程1.发票预生成流程1.1一次性发票预生成1.查询一次性费用信息2.查询票据打印信息3.判断该流水能否打印发票4.插票据打印日志5.插票据信息6.记录发票项目信息表\n\n1.2月结发票预生成按账户生成月结发票时，一条打印记录，按照用户生成多条票据明细\n1.按照账户、账期查询欠费账单2.查询销账轨迹\n\n\n\n2.发票开具流程1.根据外部传入的票据打印时间获取分表字段2.获取票据打印信息3.校验票据：发票总金额为0时，不允许申请电子发票            收据不允许申请电子发票4.查询票据详细信息5.获取发票税收编码明细6.组织发票需要的信息  1）生成请求流水号  2）生成票据其他信息7.发送税控系统开具发票8.开具成功回写发票号码、代码等信息\n\n3.发票冲红流程可以看作冲红发票的预生成过程\n1.查询原票据打印信息和票据信息2.校验原票信息，原票尚未开具的不允许冲红3.更新原票状态信息4.生成红票打印信息、票据信息和票据项目信息\n","categories":["项目流程"],"tags":["业务"]},{"title":"账管业务流程","url":"/java4u/2022/04/20/%E8%B4%A6%E7%AE%A1%E6%B5%81%E7%A8%8B/","content":"整理记录账管主要业务流程\n1.查欠功能：查询客户的欠费，账单/账本信息以及虚销信息。步骤：    1.查询往月、实时账单    2.查询历史账单，实时账单和历史账单合并    3.查询所有账本信息    4.调用虚销接口，冲销该账户下所有账本和账单    涉及表：    AM_BILL_ITEM     账单未销账欠费表    AM_BALANCE       通信账本月表    AM_ACCT_DEBT     欠费表\n\n2.账户充值功能：展示客户的账户余额以及欠费情况。支持给客户指定的账本进行缴费步骤：    1.入账：写账本表，来源表，缴费日志    2.判断是否销账（是否欠费）    3.如果欠费，根据冲销的账单计算欠费情况，更新账本和欠费账单表    4.资产上发    主要服务：asset_IPaymentCSV_asyncPayment   异步缴费接口        调用 RechargeLogic 入账逻辑层的 doRecharge（）缴费入账方法                setPayTrade（）设置交易信息                生成缴费工单\n\n资产上发    功能：写资产上发表，上发计费帐处    逻辑：\n3.缴费返销功能：撤销充值，回退账本和账单步骤：        1.更新之前的AM_BUSI数据，记录返销信息        2.新插入AM_BUSI一条返销信息\n\n4.信控管理1.账务停开机    对客户下的用户分业务级别停开机操作    逻辑：        营业员或运维人员定位需要做账务停开机的客户。        营业员选择用户后，会加载用户下对应的分业务停开机状态，营业员对其进行停开机动作。        已开/停机的分业务不允许再次开/停机，开机操作会自动触发新增免催免停，起始时间为操作时间，结束时间可选，默认为一个星期。        账管系统记录操作日志并将信控动作上发CRM操作。        涉及表：        AM_OWE_NO_PRESS_STOP    免催免停操作记录表        AM_ACCT_FORCE_STOP_OPEN_REC   停开机操作记录表        2.信用度查询、修改    逻辑：        选择客户后通过ACCTID参数自动调用账处查询信用度接口返回账户级信用度。（查询信用度接口具体的消息号QUERY_Credit_UP(858)）        返回信用度并返回assetId,后面用户可选择查询的信用度通过acctid以及assetId查询到对应的信用度进行修改然后直接上发账处表。            涉及表：        CA_CREDIT     信用度表        CA_ASSET_SYN_XX  同步通知表\n\n5.综合查询1.账单查询    逻辑：        账单信息查询，通过选择的客户信息，账单所在日期区间，调用查欠接口查询客户账单信息，        并根据账期由近到远进行汇总展示，在双击某一条账期汇总账单时，展示每一个账期的详细账单信息。\n\n6.帐务稽核一.预存清退（退账本上的钱）            1.查询可清退存折                    查询存折                    扣减欠费（默认不扣减）                    过滤掉无法清退的存折            2.设置清退或者转出存折            3.更新存折以及日志                    获取账本                    过滤押金账本                    计算需要清退的金额                    更新存折                    记录账本支出                    插缴费接口表                    更新业务日志            4.更新统计busi表            5.资产上发            二.转账        1.获取可转出存折        2.设置转出存折        3.更新转出存折        4.设置转入存折        5.更新转入存折        三.账单调账（帐前调账，账单还在MDB  账后调账，账单在账管）    账单预调账（账前调账）            1.更新调账主表                       AM_ADJUST            2.更新调账子表                         AM_ADJUST_BILL            3.写计费外部数据导入表    CA_EXT_DATA            4.写调账接口表                    I_ADJUST                账单调账（账后调账）            1.查询账单            2.判断账单金额与调账金额            3.调高调低                欠费调低  &quot;R&quot;                        计算调账金额                        修改账单金额                欠费调高  &quot;A&quot;                        添加应收数据    AM_BILL_AR                                    4.调低的时候更新欠费表                调改的时候新增欠费信息            5.更新欠费金额       AM_ACCT_DEBT            6.调账主表、子表更新\n\n7.销账这里的销账系统特指异步销账或者补销账，针对用户当前账单和历史账单的销账，一般通过接口调用或者工单处理系统触发。涉及表：    AM_SPE_PAYMENT     专款专用表    AM_BILL_TYPE       账单科目表    AM_BILL_TYPE_CLASS 账单科目分类表        AM_ASSET_SPE_DEF    账本默认专款标识    AM_SPE_PAYMENT      专款专用详情    AM_ASSET_TYPE       账本科目    AM_ASSET_TYPE_CLASS 账本科目分类    步骤：    1.查找账本    2.查询欠费信息（月结应收）        当前账期            不销账        不是当前账期        查询历史应收明细    3.按照优先级销账\n\n异步销账现在批销后的数据，进入批量异步工单处理\n\nBatchCalc类中调用singleCalc()在有往月欠费并且抵扣后有剩余的预存的情况下，写入异步销账表（先改为batch表）\n\n批量销账    1.程序入口   WriteoffMain  配置 通道号    2.执行顺序                 produce              initCalc            初始化通道信息              changeCycleFlag   修改账期状态,进入抵扣期间              calcBatchNo       计算该通道每个批次的开始值和结束值              batchWriteOffCalc 按批次加载数据进行抵扣计算                  3.batchRanges 计算批次        4.batchWriteOffCalc            batchWriteOffCalc   加载抵扣所需账务数据            startId   endId     分区ID            bizEntryTl  作用,客户账本、账单、销账数据        Monitor.addAllCount(entrys.size());   监视？        dispatch调用哪个方法  execute函数        BatchWriteOffCalculator  账本、账单预先排序（设置账本时同时排序）        销账完发异步销账通知（有往月欠费并且抵扣后有剩余的预存）        WFileUtil InDB写入文件，写入文件如果是多线程混合写入，会加锁    BalOutFormater 与  writeoff-indb.xml 配置的字段需要一致        当月账单（S文件）  账本    销账  ---》 销账轨迹什么情况上发？    需要        欠费增加                欠费减少，账本冲销完    不需要        欠费减少  账本还有钱（异步冲销）    上发什么数据？    账本数据        OweQueueTask  批量上发\n\n8.托收一、托收签约客户-》银行-》签约     将要托收        am_entrust_relation      签约关系表          am_entrust_relation_his                    1.参数校验和初始化（客户信息、客户信用度等级、委托关系）2.支付用户  删除之前的签约关系，新建签约关系  普通用户  更新签约关系  3.通知CRM修改支付方式4.预付费账户需要通知账处修改信用度\n\n二、托收解约1.判断是否托收在途，正在托收不解约 （查询托收生成明细）2.更新原托收关系为作废\n\n三、托收发起（落表）        am_entrust_create_notify     托收发起通知表（ EntrustCreateTask 进程扫描） （来源：前台页面导入或支付发起进程）                am_entrust_create_dtl         托收生成明细表(年月表)  验证托收信息    （托收发起进程生成的，按批次生成具体的托收信息）                am_entrust_payboss_notify    第三方通知表   支付宝        1.支付宝发送文件或BOSS前台发起托收请求2.插入托收发起通知表3.托收生成进程 EntrustCreateTask 扫描托收通知表，生成托收明细数据（根据1条通知表数据，查询签约表，去生成所有客户的明细表数据，生成明细表数据状态为5）    \n\n四、托收算费   EntrustQryFeeTask算费进程    am_entrust_create_dtl   更新明细表，计算出费用托收算费    1）查询托收关系数据    2）查询托收生成明细数据    3）根据账户ID查询是否有未申请停机用户    4）托收算费计算金额            1.查询业务类型对应的分业务            2.查欠，然后计算数字基本和互动基本费用（计算欠费金额）            3.账本按照分业务汇总            4.分业务计算账本金额               \n\n五、托收文件发送  -》银行    EntrustCreateFileTask 进程生成托收文件            查询托收发起通知表 AM_ENTRUST_CREATE_NOTIFY 状态为2 处理中的数据            查询明细表数据为6 算费成功的数据            根据托收明细生成发送文件            新增托收生成总表（1个文件1条记录）            更新明细表数据    am_enrtust_create       托收生成总表    生成文件（前台发送）托收发盘（操作员审核文件，点击文件发送）1.查询生成总表数据   am_enrtust_create2.查询明细表数据   多线程处理                                获取am_enrtust_create总表中的托收总数TOTAL_NUM,设置查询数量                                计算出查询次数time                                创建线程池，将查询任务放入线程池处理                                每次查询使用ThredQuery实现Callable进行查询                                3.获取FTP地址4.生成文件5.上传本地6.上传FTP7.通知UPG接口8.更新托收生成总表\n\n六、托收入账  （回盘文件，入表，入账）        am_entrust_deal       托收处理总表                am_entrust_deal_dtl   托收处理明细表(年月表)                常州清算中心  回盘文件按银行（一个银行一个文件）                      FTP路径根据分公司，分了3个地址    银行回调过程    1.银行返回回盘文件，调接口通知BOSS，调接口asset_ICRMServiceCSV_doEntrustDealNotifyCom\t\t写入数据到select *  from  cen.am_file_batch_info where source=&#x27;ENTRUST_DEALNOTIFYCOM&#x27;  AND STATE=0 \t2、AsynEntrustDealNotifyTask 做回盘处理（解析回盘文件），往 AM_ENTRUST_DEAL_DTL，AM_ENTRUST_DEAL 表写入数据           AsynEntrustDealNotifyTask托收回盘异步处理进程       \t1）下载文件，解析文件，插入托收处理明细表（状态为1）    \t2）如果是常州清算中心会有多个文件，需要处理到最好一个文件再更新为处理结束\t\t3）写入托收处理总表（状态为1）\t3.EntrustDealThreadTask 进行入账处理       \t查询处理明细表的数据    \t调用预存进行入账                      托收分业务入账：    业务分为：基本业务和增值业务    页面操作      0   增值                    增值分业务，其他进通款                1    数字+互动基本            基本分业务，其他进通款                2    基本+增值                全部业务                5    基本业务和增值业务        全部合并进通款                    算费后：按照业务分为多条数据        入账时：   比如     1002        基本1       如果是增值，分为1008，1009，100（1002，1003合并）                        1003        基本2        如果是基本，分为1002，1003，700（1008，1009合并）                                                如果是基本+增值，分为1002，1003，1008，1009                        1008        增值1        如果是基本业务和增值业务，分为100（1002，1003，1008，1009全合并）                        1009        增值2\n\n七、苏州托收永不停机永不停机规则：永不停机是与银联进行对接，用户通过提供银行卡号、姓名、身份证信息，在我方营业厅柜台签订代扣协议进行签约绑定，签约时用户可自行设置不足额度（如5元、30元、50元）和每次代扣额度（如50元、100元、300元）。永不停机每日发起一次代扣，当用户账户额度不足预设限额后，自动向银联发起扣款请求，从用户银行卡中进行扣款并充值，扣款金额为用户签约时预设金额，如代扣后余额仍不足限额，可一次发起多笔扣款直至余额满足限额。代扣任务实时扣款后，将扣款成功与否信息发给我方，我方根据扣款情况进行BOSS入账。改造点：1.新增永不停机进程，每天定时调度\t查询出签约表中签约了永不停机的客户，每个客户进行查欠，判断客户金额是否小于不足额度，小于则发起一笔托收，新增一条数据进入托收发起通知表（根据银行、签约类型），同时需要判断该用户之前的数据被处理完了嘛？如果没有处理则不生成新的明细数据 IEntrustAppBC.checkEntrustBank()2.托收发起进程改造\t生成托收明细的时候是根据业务类型BUSI_TYPE，分公司CORP_ORG_ID，签约类型src_type，银行bank_id来从签约表中获取数据，永不停机生成托收明细的时候可能会获取到之前送托的数据，造成重复发送。添加查询条件3.算费进程改造\t之前算费根据分业务汇总欠费金额，在发起托收。现在直接判断是否为永不停机的托收，直接发起设置的代扣金额4.送托改造\t永不停机的数据不在页面上点击送托，直接在后台处理添加自动送托进程\n\n托收状态am_entrust_relation      签约关系表   state  0有效，1无效 （解约变成无效）am_entrust_create_notify     托收发起通知表（扫描）     state   1 未处理   刚插入通知表的数据              2 处理中   发起进程处理后            3 处理结束                    AM_ENTRUST_CREATE       托收生成总表 state    2    处理中（发送托收文件）am_entrust_create_dtl         托收生成明细表(年月表)       state   1 未处理    \t\t2 处理中    \t\t3 处理结束            5 托收生成初始状态（托收发起进程生成托收明细表）            6 算费进程算费成功后            9 算费进程处理开始（入账处理）                    AM_ENTRUST_DEAL_DTL   托收处理总表    state   1   未处理    托收入账时写入            3   处理结束\n\n9.活动划拨一.活动办理  提供CRM接口办理活动1.查询用户三户信息\n2.有TRANS_AMOUNT说明需要从账户上扣钱\n    1）查询活动转出账本科目配置\n    2）查欠获取客户虚销后账本\n    3）计算从配置的可转出账本一共需要转出多少钱\n    4）满足转出条件，走清退流程\n3.根据传入的定价计划编码\n    查询活动计划定义表 AM_PRICE_PLAN 返回amPricePlan\n    查询活动计划组成表 AM_PRICE_PLAN_COMP 返回planComps\n4.beforeExecuteComp 校验规则与配置\n    判断是否有预存类活动\n        1）有预存类规则\n            查询活动计划属性定义表 AM_PRICE_PLAN_ATTR\n            校验每条属性规则\n        2）非预存类活动且ACCEP_AMOUNT不为0时，为客户做ACCEP_AMOUNT的缴费（ACCEP_AMOUNT被覆盖成0，暂时不走该分支）\n5.遍历活动组成executeComp\n    1)查询活动属性，有2个属性的ATTR_CODE相同，表示存在两个立即到账(预存/赠送)，或者两个分月返款(预存，赠送)。\n    2）构建活动属性\n        2.1 计算返回金额从入参、表配置、不限制\n        2.2 如果属性从外部传入，如果不全，则需要额外计算\n    3）判断属性是否是用户级账本\n    划拨类型：\n        1）立即到账：\n                获取立即到账总金额 totalMoney\n                PAY_TYPE为预存类、赠送类计算划拨金额\n                PAY_TYPE为账本划拨直接调用转账服务进行转账\n                \n                除了账本划拨调用预存服务立即到账\n                记录返款日志return表\n        2）分月返还：\n                计算金额 （预存按月返还总额RETURN_AMOUNT 预存本金总额CAPITAL_AMOUNT  赠送总额REWARD_AMOUNT）\n                获取账户账期\n                活动生效开始时间（如果有传入： 1、 传入时间月份大于当前时间月份：取START_DATE所在账期开始时间+AMONTH-1作为活动开始时间 2、 传入时间月分小于等于当前时间月份：取当前时间所在账期开始时间+AMONTH-1作为活动开始时间 3、 未传入则取当前时间所在账期开始时间+AMONTH-1作为活动开始时间）\n                查询活动计划规则定义表 AM_PRICE_PLAN_APP_RULE\n                写分摊计划表 AM_APPORTION_PLAN\n    6.afterExecuteComp  剩余金额缴费以及生成受理总表  AM_APPORTION\n\n二.活动取消     提供CRM接口取消活动三.后台任务1.查询活动计划工单AM_APPORTION_PLAN2.转换返款金额3.写入文件\n\n10.积分一、积分调整1.查询积分账本  SC_BALANCE2.校验用户积分是否够扣3.新增积分业务日志记录 SC_BUSI4.记录统计需要的积分核心业务日志 I_SC_BUSI_BAL5.积分入账6.短信提醒\n\n二、积分返回1.生成积分活动受理表 SC_APPORTION2.生成积分返还工单表 SC_APPORTION_PLAN\n\n三、积分清零1.记录积分业务日志记录2.记录统计需要的积分核心业务日志3.积分入账（清零所有积分）\n\n四、积分计算实时销账积分计算（销账时产生积分）\t1.获取销账金额 刨除不产生积分的账本\t2.获取系统默认的积分计划\t3.计算消费积分\t4.记录积分业务日志\t5.积分入账\n\n五、积分兑换1.查询符合积分兑换规则的积分账本（加载可用和不可用的礼物，过滤积分账本）2.校验积分是否足够3.查询此笔交易是否已经成功(对事物不一致的容错处理)4.记录积分业务日志5.积分入账（减扣）\n\n六、积分冻结、解冻七、积分促销（赠送）八、积分充值九、积分返销十、积分转赠11.发票一、月结发票查询月结发票\n1.根据账户标识和起始终止月份获取账期列表2.遍历账期查询月结发票3.按照账户和账单查询欠费账单bills4.查询该账期下可用的月结发票5.根据打印方式（预打印、正常打印）6.正常打印方式7.账期内有未销完的账单 不允许打印8.根据账单月份查询销账日志 witeoffLogs9.没有销账日志的账期不打印月结发票10.按照用户记录销账记录 logMap11.按照用户分别计算月结发票金额\n\n12.分账国网收入都暂时统一收到国网，由国网来统一根据分账比例进行分账\n","categories":["项目流程"],"tags":["业务"]},{"title":"Zookeeper","url":"/java4u/2022/04/11/zookeeper/","content":"zookeeper动物管理员  管理 hadoop(大象)hive(蜜蜂)\nzk是开源的分布式应用程序的协调服务\n功能：    配置管理 （服务配置）    分布式锁    集群管理\n树型的目录结构，每个节点ZNODE，每个节点会保存自己的数据和节点信息\nzookeeper分布式锁原理核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点1.客户端获取锁时，在lock节点下创建临时顺序节点2.然后获取Lock下所有子节点，客户端获取到所有子节点后，如果发现自己创建的序号最小，    则客户端获取到锁。使用完锁后，删除该节点3.如果发现自己创建的节点并非lock中最小的，说明没有获取到锁，客户端需要找到比自己小的    那个节点，同时对其注册事件监听器，监听删除事件。（触发删除事件时，只需要唤醒一个，不需要全部提醒）4.如果发现比自己小的那个节点被删除，则客户端的    watcher会收到通知，再次判断自己创建的节点是否是    lock子节点中序号最小的，如果是获取到锁，    如果不是则重复以上步骤继续获取到比自己小的一个节点    并注册监听\nzookeeper集群    leader选举        serverid   服务器ID\n    Zxid     数据ID    获取超过半数的选票，就可以成为leader集群角色        leader:处理事务请求（增删改）                        集群内部各服务器的调度者        follower:处理非事务请求，转发事务请求给leader                         参与leader选举投票        observer:    处理非事务请求，转发事务请求给leader\n","categories":["中间件"],"tags":["学习"]},{"title":"1179.重新格式化部门表","url":"/java4u/2022/02/10/1179.%20%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%83%A8%E9%97%A8%E8%A1%A8/","content":"部门表 Department：\n+---------------+---------+| Column Name   | Type    |+---------------+---------+| id            | int     || revenue       | int     || month         | varchar |+---------------+---------+\n(id, month) 是表的联合主键。这个表格有关于每个部门每月收入的信息。月份（month）可以取下列值 [“Jan”,”Feb”,”Mar”,”Apr”,”May”,”Jun”,”Jul”,”Aug”,”Sep”,”Oct”,”Nov”,”Dec”]。\n \n编写一个 SQL 查询来重新格式化表，使得新的表中有一个部门 id 列和一些对应 每个月 的收入（revenue）列。\n查询结果格式如下面的示例所示：\nDepartment 表：\n+------+---------+-------+| id   | revenue | month |+------+---------+-------+| 1    | 8000    | Jan   || 2    | 9000    | Jan   || 3    | 10000   | Feb   || 1    | 7000    | Feb   || 1    | 6000    | Mar   |+------+---------+-------+\n查询得到的结果表：\n+------+-------------+-------------+-------------+-----+-------------+| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |+------+-------------+-------------+-------------+-----+-------------+| 1    | 8000        | 7000        | 6000        | ... | null        || 2    | 9000        | null        | null        | ... | null        || 3    | null        | 10000       | null        | ... | null        |+------+-------------+-------------+-------------+-----+-------------+\n注意，结果表有 13 列 (1个部门 id 列 + 12个月份的收入列)。\n解答：\nselect id,\tsum(case month when &#x27;Jan&#x27; then revenue end) as &#x27;Jan_Revenue&#x27;,\tsum(case month when &#x27;Feb&#x27; then revenue end) as &#x27;Feb_Revenue&#x27;,\tsum(case month when &#x27;Mar&#x27; then revenue end) as &#x27;Mar_Revenue&#x27;,\tsum(case month when &#x27;Apr&#x27; then revenue end) as &#x27;Apr_Revenue&#x27;,\tsum(case month when &#x27;May&#x27; then revenue end) as &#x27;May_Revenue&#x27;,\tsum(case month when &#x27;Jun&#x27; then revenue end) as &#x27;Jun_Revenue&#x27;,\tsum(case month when &#x27;Jul&#x27; then revenue end) as &#x27;Jul_Revenue&#x27;,\tsum(case month when &#x27;Aug&#x27; then revenue end) as &#x27;Aug_Revenue&#x27;,\tsum(case month when &#x27;Sep&#x27; then revenue end) as &#x27;Sep_Revenue&#x27;,\tsum(case month when &#x27;Oct&#x27; then revenue end) as &#x27;Oct_Revenue&#x27;,\tsum(case month when &#x27;Nov&#x27; then revenue end) as &#x27;Nov_Revenue&#x27;,\tsum(case month when &#x27;Dec&#x27; then revenue end) as &#x27;Dec_Revenue&#x27;from department group by id;\n列出部门的月份收入，即以id作为分组查询select id from department group by id\n分组后按照月份汇总收入，使用case when判断月份sum(case month when ‘Jan’ then revenue end) as Jan_Revenue,\n","categories":["SQL"],"tags":["学习"]},{"title":"窗口函数","url":"/java4u/2022/02/10/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/","content":"窗口函数的基本语法如下：&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;                order by &lt;用于排序的列名&gt;)那么语法中的&lt;窗口函数&gt;都有哪些呢？&lt;窗口函数&gt;的位置，可以放以下两种函数：1） 专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。2） 聚合函数，如sum. avg, count, max, min等因为窗口函数是对where或者group by子句处理后的结果进行操作，所以窗口函数原则上只能写在select子句中。\n1.rank专业窗口函数  对一份成绩表排序，按照班级排序select *,   rank() over (partition by 班级                 order by 成绩 desc) as rankingfrom 班级表\ngroup by会减少原表数据，窗口函数在不减少原表数据的情况下，对数据进行分组和排序\n2.聚合窗口函数，对自身及以上数据进行运算select *,   sum(成绩) over (order by 学号) as current_sum,   avg(成绩) over (order by 学号) as current_avg,   count(成绩) over (order by 学号) as current_count,   max(成绩) over (order by 学号) as current_max,   min(成绩) over (order by 学号) as current_minfrom 班级表\n","categories":["SQL"],"tags":["学习"]},{"title":"627.变更性别","url":"/java4u/2022/02/09/627.%20%E5%8F%98%E6%9B%B4%E6%80%A7%E5%88%AB/","content":"Salary 表：\n+-------------+----------+| Column Name | Type     |+-------------+----------+| id          | int      || name        | varchar  || sex         | ENUM     || salary      | int      |+-------------+----------+\nid 是这个表的主键。sex 这一列的值是 ENUM 类型，只能从 (‘m’, ‘f’) 中取。本表包含公司雇员的信息。\n \n请你编写一个 SQL 查询来交换所有的 ‘f’ 和 ‘m’ （即，将所有 ‘f’ 变为 ‘m’ ，反之亦然），仅使用 单个 update 语句 ，且不产生中间临时表。注意，你必须仅使用一条 update 语句，且 不能 使用 select 语句。\n查询结果如下例所示：\n \nSalary 表：\n+----+------+-----+--------+| id | name | sex | salary |+----+------+-----+--------+| 1  | A    | m   | 2500   || 2  | B    | f   | 1500   || 3  | C    | m   | 5500   || 4  | D    | f   | 500    |+----+------+-----+--------+\nResult 表：\n+----+------+-----+--------+| id | name | sex | salary |+----+------+-----+--------+| 1  | A    | f   | 2500   || 2  | B    | m   | 1500   || 3  | C    | f   | 5500   || 4  | D    | m   | 500    |+----+------+-----+--------+\n(1, A) 和 (3, C) 从 ‘m’ 变为 ‘f’ 。(2, B) 和 (4, D) 从 ‘f’ 变为 ‘m’ 。\n答案：使用CASE…WHEN表达式\nupdate\tsalaryset\tsex =\tcase\t\tsex        when &#x27;m&#x27; then &#x27;f&#x27;\t\telse &#x27;m&#x27;\tend;\n\n\n","categories":["SQL"],"tags":["学习"]},{"title":"626.换座位","url":"/java4u/2022/02/09/626.%20%E6%8D%A2%E5%BA%A7%E4%BD%8D/","content":"小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。\n其中纵列的 id 是连续递增的\n小美想改变相邻俩学生的座位。\n你能不能帮她写一个 SQL query 来输出小美想要的结果呢？\n \n示例：\n+---------+---------+|    id   | student |+---------+---------+|    1    | Abbot   ||    2    | Doris   ||    3    | Emerson ||    4    | Green   ||    5    | Jeames  |+---------+---------+\n假如数据输入的是上表，则输出结果如下：\n+---------+---------+|    id   | student |+---------+---------+|    1    | Doris   ||    2    | Abbot   ||    3    | Green   ||    4    | Emerson ||    5    | Jeames  |+---------+---------+\n注意：\n如果学生人数是奇数，则不需要改变最后一个同学的座位。\n解答：\nSELECT    (CASE        WHEN MOD(id, 2) != 0 AND counts != id THEN id + 1        WHEN MOD(id, 2) != 0 AND counts = id THEN id        ELSE id - 1    END) AS id,    studentFROM    seat,    (SELECT        COUNT(*) AS counts    FROM        seat) AS seat_countsORDER BY id ASC;\n对于所有座位 id 是奇数的学生，修改其 id 为 id+1，如果最后一个座位 id 也是奇数，则最后一个座位 id 不修改。对于所有座位 id 是偶数的学生，修改其 id 为 id-1\n(SELECT    COUNT(*) AS countsFROM    seat) AS seat_counts  查询座位数量","categories":["SQL"],"tags":["学习"]},{"title":"596.超过5名学生的课","url":"/java4u/2022/02/08/596.%20%E8%B6%85%E8%BF%875%E5%90%8D%E5%AD%A6%E7%94%9F%E7%9A%84%E8%AF%BE/","content":"有一个courses 表 ，有: student (学生) 和 class (课程)。\n请列出所有超过或等于5名学生的课。\n例如，表：\n+---------+------------+| student | class      |+---------+------------+| A       | Math       || B       | English    || C       | Math       || D       | Biology    || E       | Math       || F       | Computer   || G       | Math       || H       | Math       || I       | Math       |+---------+------------+\n应该输出:\n+---------+| class   |+---------+| Math    |+---------+\n\n提示：\n学生在每个课中不应被重复计算。\n解答：select class from courses group by class having count(class)&gt;&#x3D;5;\n","categories":["SQL"],"tags":["学习"]},{"title":"620.有趣的电影","url":"/java4u/2022/02/08/620.%20%E6%9C%89%E8%B6%A3%E7%9A%84%E7%94%B5%E5%BD%B1/","content":"某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列。\n \n例如，下表 cinema:\n+---------+-----------+--------------+-----------+|   id    | movie     |  description |  rating   |+---------+-----------+--------------+-----------+|   1     | War       |   great 3D   |   8.9     ||   2     | Science   |   fiction    |   8.5     ||   3     | irish     |   boring     |   6.2     ||   4     | Ice song  |   Fantacy    |   8.6     ||   5     | House card|   Interesting|   9.1     |+---------+-----------+--------------+-----------+\n对于上面的例子，则正确的输出是为：\n+---------+-----------+--------------+-----------+|   id    | movie     |  description |  rating   |+---------+-----------+--------------+-----------+|   5     | House card|   Interesting|   9.1     ||   1     | War       |   great 3D   |   8.9     |+---------+-----------+--------------+-----------+\n\n解答：\nselect * from cinema where \tdescription &lt;&gt; &#x27;boring&#x27; and id%2 = 1order by rating desc;\n","categories":["SQL"],"tags":["学习"]},{"title":"262.行程和用户","url":"/java4u/2022/02/07/262.%20%E8%A1%8C%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7/","content":"表：Trips\n+-------------+----------+| Column Name | Type     |+-------------+----------+| id          | int      || client_id   | int      || driver_id   | int      || city_id     | int      || status      | enum     || request_at  | date     |     +-------------+----------+\nid 是这张表的主键。这张表中存所有出租车的行程信息。每段行程有唯一 id ，其中 client_id 和 driver_id 是 Users 表中 users_id 的外键。status 是一个表示行程状态的枚举类型，枚举成员为(‘completed’, ‘cancelled_by_driver’, ‘cancelled_by_client’) 。\n \n表：Users\n+-------------+----------+| Column Name | Type     |+-------------+----------+| users_id    | int      || banned      | enum     || role        | enum     |+-------------+----------+\nusers_id 是这张表的主键。这张表中存所有用户，每个用户都有一个唯一的 users_id ，role 是一个表示用户身份的枚举类型，枚举成员为 (‘client’, ‘driver’, ‘partner’) 。banned 是一个表示用户是否被禁止的枚举类型，枚举成员为 (‘Yes’, ‘No’) 。\n \n取消率 的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) &#x2F; (非禁止用户生成的订单总数)。写一段 SQL 语句查出 “2013-10-01” 至 “2013-10-03” 期间非禁止用户（乘客和司机都必须未被禁止）的取消率。非禁止用户即 banned 为 No 的用户，禁止用户即 banned 为 Yes 的用户。返回结果表中的数据可以按任意顺序组织。其中取消率 Cancellation Rate 需要四舍五入保留 两位小数 。\n查询结果格式如下例所示。\n \n示例：\n输入：Trips 表：\n+----+-----------+-----------+---------+---------------------+------------+| id | client_id | driver_id | city_id | status              | request_at |+----+-----------+-----------+---------+---------------------+------------+| 1  | 1         | 10        | 1       | completed           | 2013-10-01 || 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 || 3  | 3         | 12        | 6       | completed           | 2013-10-01 || 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 || 5  | 1         | 10        | 1       | completed           | 2013-10-02 || 6  | 2         | 11        | 6       | completed           | 2013-10-02 || 7  | 3         | 12        | 6       | completed           | 2013-10-02 || 8  | 2         | 12        | 12      | completed           | 2013-10-03 || 9  | 3         | 10        | 12      | completed           | 2013-10-03 || 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |+----+-----------+-----------+---------+---------------------+------------+\nUsers 表：\n+----------+--------+--------+| users_id | banned | role   |+----------+--------+--------+| 1        | No     | client || 2        | Yes    | client || 3        | No     | client || 4        | No     | client || 10       | No     | driver || 11       | No     | driver || 12       | No     | driver || 13       | No     | driver |+----------+--------+--------+\n输出：\n+------------+-------------------+| Day        | Cancellation Rate |+------------+-------------------+| 2013-10-01 | 0.33              || 2013-10-02 | 0.00              || 2013-10-03 | 0.50              |+------------+-------------------+\n解释：2013-10-01：\n\n共有 4 条请求，其中 2 条取消。\n然而，id&#x3D;2 的请求是由禁止用户（user_id&#x3D;2）发出的，所以计算时应当忽略它。\n因此，总共有 3 条非禁止请求参与计算，其中 1 条取消。\n取消率为 (1 &#x2F; 3) &#x3D; 0.332013-10-02：\n共有 3 条请求，其中 0 条取消。\n然而，id&#x3D;6 的请求是由禁止用户发出的，所以计算时应当忽略它。\n因此，总共有 2 条非禁止请求参与计算，其中 0 条取消。\n取消率为 (0 &#x2F; 2) &#x3D; 0.002013-10-03：\n共有 3 条请求，其中 1 条取消。\n然而，id&#x3D;8 的请求是由禁止用户发出的，所以计算时应当忽略它。\n因此，总共有 2 条非禁止请求参与计算，其中 1 条取消。\n取消率为 (1 &#x2F; 2) &#x3D; 0.50\n\n解答:client_id 和 driver_id 各自关联的 users_id，同时检测是否被禁止。\nif (client_id &#x3D; users_id_1 且 users_id_1没被禁止 并且 client_id &#x3D; users_id_2 且 users_id_2没被禁止){    此条记录没被禁止。}获取所有没有被禁止的记录\nSELECT *FROM Trips AS TJOIN Users AS U1 ON (T.client_id = U1.users_id AND U1.banned =&#x27;No&#x27;)JOIN Users AS U2 ON (T.driver_id = U2.users_id AND U2.banned =&#x27;No&#x27;)\n每组的取消的行程数：SUM(    IF(T.STATUS &#x3D; ‘completed’,0,1))\nSELECT T.request_at AS `Day`, \tROUND(\t\t\tSUM(\t\t\t\tIF(T.STATUS = &#x27;completed&#x27;,0,1)\t\t\t)\t\t\t/ \t\t\tCOUNT(T.STATUS),\t\t\t2\t) AS `Cancellation Rate`FROM Trips AS TJOIN Users AS U1 ON (T.client_id = U1.users_id AND U1.banned =&#x27;No&#x27;)JOIN Users AS U2 ON (T.driver_id = U2.users_id AND U2.banned =&#x27;No&#x27;)WHERE T.request_at BETWEEN &#x27;2013-10-01&#x27; AND &#x27;2013-10-03&#x27;GROUP BY T.request_at\n\n\n","categories":["SQL"],"tags":["学习"]},{"title":"595.大的国家","url":"/java4u/2022/02/07/595.%20%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6/","content":"World 表：\n+-------------+---------+| Column Name | Type    |+-------------+---------+| name        | varchar || continent   | varchar || area        | int     || population  | int     || gdp         | int     |+-------------+---------+\nname 是这张表的主键。这张表的每一行提供：国家名称、所属大陆、面积、人口和 GDP 值。\n \n如果一个国家满足下述两个条件之一，则认为该国是 大国 ：\n面积至少为 300 平方公里（即，3000000 km2），或者人口至少为 2500 万（即 25000000）编写一个 SQL 查询以报告 大国 的国家名称、人口和面积。\n按 任意顺序 返回结果表。\n查询结果格式如下例所示。\n \n示例：\n输入：World 表：\n+-------------+-----------+---------+------------+--------------+| name        | continent | area    | population | gdp          |+-------------+-----------+---------+------------+--------------+| Afghanistan | Asia      | 652230  | 25500100   | 20343000000  || Albania     | Europe    | 28748   | 2831741    | 12960000000  || Algeria     | Africa    | 2381741 | 37100000   | 188681000000 || Andorra     | Europe    | 468     | 78115      | 3712000000   || Angola      | Africa    | 1246700 | 20609294   | 100990000000 |+-------------+-----------+---------+------------+--------------+\n输出：\n+-------------+------------+---------+| name        | population | area    |+-------------+------------+---------+| Afghanistan | 25500100   | 652230  || Algeria     | 37100000   | 2381741 |+-------------+------------+---------+\n\n解答：\nselect * from (select * from World w1 where w1.area &gt; 3000000unionselect * from World w2 where w2.population &gt; 25000000)\n\n答案：使用OR连接2个子查询\nSELECT    name, population, areaFROM    worldWHERE    area &gt;= 3000000 OR population &gt;= 25000000;\n使用UNION连接2个子查询，UNION选取不同的值，选取相同的值使用UNION ALL\nSELECT    name, population, areaFROM    worldWHERE    area &gt;= 3000000UNIONSELECT    name, population, areaFROM    worldWHERE    population &gt;= 25000000;\n","categories":["SQL"],"tags":["学习"]},{"title":"196.删除重复的电子邮箱","url":"/java4u/2022/02/06/196.%20%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/","content":"编写一个 SQL 查询，来删除 Person 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。\n+----+------------------+| Id | Email            |+----+------------------+| 1  | john@example.com || 2  | bob@example.com  || 3  | john@example.com |+----+------------------+\nId 是这个表的主键。例如，在运行你的查询语句之后，上面的 Person 表应返回以下几行:\n+----+------------------+| Id | Email            |+----+------------------+| 1  | john@example.com || 2  | bob@example.com  |+----+------------------+\n\n提示：\n执行 SQL 之后，输出是整个 Person 表。使用 delete 语句。\n答案：\nDELETE p1 FROM Person p1,    Person p2WHERE    p1.Email = p2.Email AND p1.Id &gt; p2.Id\n解答：查询重复的列，将表与自身通过Email连接\nSELECT p1.*FROM Person p1,    Person p2WHERE    p1.Email = p2.Email;\n需要找到其他记录中具有相同电子邮件地址的更大 ID。所以我们可以像这样给 WHERE 子句添加一个新的条件重复的数据中只要id大于其他的id，就需要被删除\nSELECT p1.*FROM Person p1,    Person p2WHERE    p1.Email = p2.Email AND p1.Id &gt; p2.Id;","categories":["SQL"],"tags":["学习"]},{"title":"197.上升的温度","url":"/java4u/2022/02/06/197.%20%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6/","content":"表 Weather\n+---------------+---------+| Column Name   | Type    |+---------------+---------+| id            | int     || recordDate    | date    || temperature   | int     |+---------------+---------+\nid 是这个表的主键该表包含特定日期的温度信息\n \n编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 id 。\n返回结果 不要求顺序 。\n查询结果格式如下例：\nWeather\n+----+------------+-------------+| id | recordDate | Temperature |+----+------------+-------------+| 1  | 2015-01-01 | 10          || 2  | 2015-01-02 | 25          || 3  | 2015-01-03 | 20          || 4  | 2015-01-04 | 30          |+----+------------+-------------+\nResult table:\n+----+| id |+----+| 2  || 4  |+----+\n2015-01-02 的温度比前一天高（10 -&gt; 25）2015-01-04 的温度比前一天高（20 -&gt; 30）\n答案：MySQL 使用 DATEDIFF 来比较两个日期类型的值DATEDIFF(date1,date2) 返回date1-date2相差的天数\nselect \tw1.id from \tweather w1,weather w2where \tdatediff(w1.recordDate,w2.recordDate)=1 and w1.temperature &gt; w2.temperature ;","categories":["SQL"],"tags":["学习"]},{"title":"185.部门工资前三高的所有员工","url":"/java4u/2022/02/05/185.%20%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E5%89%8D%E4%B8%89%E9%AB%98%E7%9A%84%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5/","content":"Employee 表包含所有员工信息，每个员工有其对应的工号 Id，姓名 Name，工资 Salary 和部门编号 DepartmentId 。\n+----+-------+--------+--------------+| Id | Name  | Salary | DepartmentId |+----+-------+--------+--------------+| 1  | Joe   | 85000  | 1            || 2  | Henry | 80000  | 2            || 3  | Sam   | 60000  | 2            || 4  | Max   | 90000  | 1            || 5  | Janet | 69000  | 1            || 6  | Randy | 85000  | 1            || 7  | Will  | 70000  | 1            |+----+-------+--------+--------------+\nDepartment 表包含公司所有部门的信息。\n+----+----------+| Id | Name     |+----+----------+| 1  | IT       || 2  | Sales    |+----+----------+\n编写一个 SQL 查询，找出每个部门获得前三高工资的所有员工。例如，根据上述给定的表，查询结果应返回：\n+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT         | Max      | 90000  || IT         | Randy    | 85000  || IT         | Joe      | 85000  || IT         | Will     | 70000  || Sales      | Henry    | 80000  || Sales      | Sam      | 60000  |+------------+----------+--------+\n解释：\nIT 部门中，Max 获得了最高的工资，Randy 和 Joe 都拿到了第二高的工资，Will 的工资排第三。销售部门（Sales）只有两名员工，Henry 的工资最高，Sam 的工资排第二。\n解答：\nselect \tDepartment,Employee,Salaryfrom (\tselect \t\te.name Employee, e.salary Salary, d.name Department,\t\tdense_rank() over(partition by departmentId order by salary desc) sal_rank\tfrom employee e,department d\twhere \t\te.departmentId = d.id)twhere \tsal_rank&lt;=3","categories":["SQL"],"tags":["学习"]},{"title":"184.部门工资最高的员工","url":"/java4u/2022/02/05/184.%20%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/","content":"表： Employee\n+--------------+---------+| 列名          | 类型    |+--------------+---------+| id           | int     || name         | varchar || salary       | int     || departmentId | int     |+--------------+---------+\nid是此表的主键列。departmentId是Department表中ID的外键。此表的每一行都表示员工的ID、姓名和工资。它还包含他们所在部门的ID。\n \n表： Department\n+-------------+---------+| 列名         | 类型    |+-------------+---------+| id          | int     || name        | varchar |+-------------+---------+\nid是此表的主键列。此表的每一行都表示一个部门的ID及其名称。\n \n编写SQL查询以查找每个部门中薪资最高的员工。按 任意顺序 返回结果表。查询结果格式如下例所示。\n \n示例 1:\n输入：Employee 表:\n+----+-------+--------+--------------+| id | name  | salary | departmentId |+----+-------+--------+--------------+| 1  | Joe   | 70000  | 1            || 2  | Jim   | 90000  | 1            || 3  | Henry | 80000  | 2            || 4  | Sam   | 60000  | 2            || 5  | Max   | 90000  | 1            |+----+-------+--------+--------------+\nDepartment 表:\n+----+-------+| id | name  |+----+-------+| 1  | IT    || 2  | Sales |+----+-------+\n输出：\n+------------+----------+--------+| Department | Employee | Salary |+------------+----------+--------+| IT         | Jim      | 90000  || Sales      | Henry    | 80000  || IT         | Max      | 90000  |+------------+----------+--------+\n解释：Max 和 Jim 在 IT 部门的工资都是最高的，Henry 在销售部的工资最高。\n解答：\nselect d.name Department ,t1.name Employee,t1.salary Salary from \tdepartment d join(\t\tselect e.* from \t\t\tEmployee e join ( \t\t\t\tselect departmentId,max(salary) max_sal from Employee\t\t\t\tgroup by departmentId\t\t\t) t\t\t\ton e.salary = t.max_sal\t\t\tand e.departmentId = t.departmentId\t) t1\ton d.id = t1.departmentId\nSELECT    Department.name AS &#x27;Department&#x27;,    Employee.name AS &#x27;Employee&#x27;,    SalaryFROM    Employee        JOIN    Department ON Employee.DepartmentId = Department.IdWHERE    (Employee.DepartmentId , Salary) IN    (   SELECT            DepartmentId, MAX(Salary)        FROM            Employee        GROUP BY DepartmentId\t);\n将多个查询条件用IN查询\n","categories":["SQL"],"tags":["学习"]},{"title":"182.查找重复的电子邮箱","url":"/java4u/2022/02/04/182.%20%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/","content":"编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。\n示例：\n+----+---------+| Id | Email   |+----+---------+| 1  | a@b.com || 2  | c@d.com || 3  | a@b.com |+----+---------+\n根据以上输入，你的查询应返回以下结果：\n+---------+| Email   |+---------+| a@b.com |+---------+\n说明：所有电子邮箱都是小写字母。\n解答：\nselect * from Person group by Email\n答案：\nselect Email from(  select Email, count(Email) as num  from Person  group by Email) as statisticwhere num &gt; 1;\n\n解释：使用临时表存储每封电子邮件的次数\nselect Email, count(Email) as numfrom Persongroup by Email;\ngroup by对结果集进行分组，前面查询的字段需要是相同的字段或者是函数\nselect Emailfrom Persongroup by Emailhaving count(Email) &gt; 1;\n使用having筛选结果集更加高效\n","categories":["SQL"],"tags":["学习"]},{"title":"183.从不订购的客户","url":"/java4u/2022/02/04/183.%20%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/","content":"某网站包含两个表，Customers 表和 Orders 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。\nCustomers 表：\n+----+-------+| Id | Name  |+----+-------+| 1  | Joe   || 2  | Henry || 3  | Sam   || 4  | Max   |+----+-------+\nOrders 表：\n+----+------------+| Id | CustomerId |+----+------------+| 1  | 3          || 2  | 1          |+----+------------+\n例如给定上述表格，你的查询应返回：\n+-----------+| Customers |+-----------+| Henry     || Max       |+-----------+\n\n答案：\nselect customers.name as &#x27;Customers&#x27;from customerswhere customers.id not in(    select customerid from orders);\n\n解答：select customerid from orders;获取订购过的客户列表\n使用 NOT IN 查询不在此列表中的客户\n","categories":["SQL"],"tags":["学习"]},{"title":"180.连续出现的数字","url":"/java4u/2022/02/03/180.%20%E8%BF%9E%E7%BB%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/","content":"表：Logs\n+-------------+---------+| Column Name | Type    |+-------------+---------+| id          | int     || num         | varchar |+-------------+---------+\nid 是这个表的主键。\n \n编写一个 SQL 查询，查找所有至少连续出现三次的数字。\n返回的结果表中的数据可以按 任意顺序 排列。\n \n查询结果格式如下面的例子所示：\n \nLogs 表：\n+----+-----+| Id | Num |+----+-----+| 1  | 1   || 2  | 1   || 3  | 1   || 4  | 2   || 5  | 1   || 6  | 2   || 7  | 2   |+----+-----+\nResult 表：\n+-----------------+| ConsecutiveNums |+-----------------+| 1               |+-----------------+\n1 是唯一连续出现至少三次的数字。\n答案：\nSELECT DISTINCT    l1.Num AS ConsecutiveNumsFROM    Logs l1,    Logs l2,    Logs l3WHERE    l1.Id = l2.Id - 1    AND l2.Id = l3.Id - 1    AND l1.Num = l2.Num    AND l2.Num = l3.Num;\n\n答案：\nSELECT DISTINCT    l1.Num AS ConsecutiveNumsFROM    Logs l1,    Logs l2,    Logs l3WHERE    l1.Id = l2.Id - 1    AND l2.Id = l3.Id - 1    AND l1.Num = l2.Num    AND l2.Num = l3.Num;\n上表中选择任意的 Num 获得想要的答案。同时我们需要添加关键字 DISTINCT ，因为如果一个数字连续出现超过 3 次，会返回重复元素。\n","categories":["SQL"],"tags":["学习"]},{"title":"181.超过经理收入的员工","url":"/java4u/2022/02/03/181.%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/","content":"Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。\n+----+-------+--------+-----------+| Id | Name  | Salary | ManagerId |+----+-------+--------+-----------+| 1  | Joe   | 70000  | 3         || 2  | Henry | 80000  | 4         || 3  | Sam   | 60000  | NULL      || 4  | Max   | 90000  | NULL      |+----+-------+--------+-----------+\n给定 Employee 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。\n+----------+| Employee |+----------+| Joe      |+----------+\n\n练习：\nselect Name from(\tselect * from(\tselect y.Salary ys, m.Salary ms,Name,ManagerId from  Employee e left join Employee m on e.ManagerId=m.Id\twhere  ManagerId is not null\t) where ys &gt; ms)\n\n\n解答：\nSELECT    a.Name AS &#x27;Employee&#x27;FROM    Employee AS a,    Employee AS bWHERE    a.ManagerId = b.Id    AND a.Salary &gt; b.Salary;\n\nSELECT     a.NAME AS EmployeeFROM Employee AS a JOIN Employee AS b     ON a.ManagerId = b.Id     AND a.Salary &gt; b.Salary;\n\n解释：需要从表中获取2次信息SELECT *FROM Employee AS a, Employee AS b;获得2个表的笛卡尔积16条记录添加过滤条件\nSELECT    *FROM    Employee AS a,    Employee AS bWHERE    a.ManagerId = b.Id    AND a.Salary &gt; b.Salary;","categories":["SQL"],"tags":["学习"]},{"title":"177.第N高的薪水","url":"/java4u/2022/02/02/177.%20%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/","content":"编写一个 SQL 查询，获取 Employee 表中第 n 高的薪水（Salary）。\n+----+--------+| Id | Salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+\n例如上述 Employee 表，n &#x3D; 2 时，应返回第二高的薪水 200。如果不存在第 n 高的薪水，那么查询应返回 null。\n+------------------------+| getNthHighestSalary(2) |+------------------------+| 200                    |+------------------------+\n\n答案：\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN    SET N := N-1;  RETURN (      # Write your MySQL query statement below.      SELECT             salary      FROM             employee      GROUP BY             salary      ORDER BY             salary DESC      LIMIT N, 1  );END\n同薪同名且不跳级的问题，解决办法是用group by按薪水分组后再order by排名第N高意味着要跳过N-1个薪水，由于无法直接用limit N-1，所以需先在函数开头处理N为N&#x3D;N-1。注：这里不能直接用limit N-1是因为limit和offset字段后面只接受正整数（意味着0、负数、小数都不行）或者单一变量（意味着不能用表达式），也就是说想取一条，limit 2-1、limit 1.1这类的写法都是报错的。\nCREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN  RETURN (      # Write your MySQL query statement below.        SELECT             DISTINCT salary        FROM             (SELECT                 salary, dense_rank() over(ORDER BY salary DESC) AS rnk             FROM                 employee) tmp        WHERE rnk = N  );END\n\nrow_number(): 同薪不同名，相当于行号，例如3000、2000、2000、1000排名后为1、2、3、4rank(): 同薪同名，有跳级，例如3000、2000、2000、1000排名后为1、2、2、4dense_rank(): 同薪同名，无跳级，例如3000、2000、2000、1000排名后为1、2、2、3ntile(): 分桶排名，即首先按桶的个数分出第一二三桶，然后各桶内从1排名，实际不是很常用显然，本题是要用第三个函数。另外这三个函数必须要要与其搭档over()配套使用，over()中的参数常见的有两个，分别是partition by，按某字段切分order by，与常规order by用法一致，也区分ASC(默认)和DESC，因为排名总得有个依据\n","categories":["SQL"],"tags":["学习"]},{"title":"178.分数排名","url":"/java4u/2022/02/02/178.%20%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D/","content":"编写一个 SQL 查询来实现分数排名。\n如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。\n+----+-------+| Id | Score |+----+-------+| 1  | 3.50  || 2  | 3.65  || 3  | 4.00  || 4  | 3.85  || 5  | 4.00  || 6  | 3.65  |+----+-------+\n例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：\n+-------+------+| Score | Rank |+-------+------+| 4.00  | 1    || 4.00  | 1    || 3.85  | 2    || 3.65  | 3    || 3.65  | 3    || 3.50  | 4    |+-------+------+\n重要提示：对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 Rank\n答案：\nselect     Score, dense_rank() over(order by Score desc) &#x27;RANK&#x27; from Scores","categories":["SQL"],"tags":["学习"]},{"title":"175.组合两个表","url":"/java4u/2022/02/01/175.%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/","content":"表1: Person\n+-------------+---------+| 列名         | 类型     |+-------------+---------+| PersonId    | int     || FirstName   | varchar || LastName    | varchar |+-------------+---------+\nPersonId 是上表主键表2: Address\n+-------------+---------+| 列名         | 类型    |+-------------+---------+| AddressId   | int     || PersonId    | int     || City        | varchar || State       | varchar |+-------------+---------+\nAddressId 是上表主键\n \n编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息： FirstName, LastName, City, State\n练习：\nselect FirstName,LastName,City,State from (\tselect * from Person a left join Address b on a.PersonId=b.PersonId )\n\n\n答案：\nselect FirstName, LastName, City, Statefrom Person left join Addresson Person.PersonId = Address.PersonId;\n解释：join可以看成将2张表合为1张表\n","categories":["SQL"],"tags":["学习"]},{"title":"176.第二高的薪水","url":"/java4u/2022/02/01/176.%20%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/","content":"Employee 表：\n+-------------+------+| Column Name | Type |+-------------+------+| id          | int  || salary      | int  |+-------------+------+\nid 是这个表的主键。表的每一行包含员工的工资信息。\n \n编写一个 SQL 查询，获取并返回 Employee 表中第二高的薪水 。如果不存在第二高的薪水，查询应该返回 null 。\n查询结果如下例所示。\n \n示例 1：\n输入：Employee 表：\n+----+--------+| id | salary |+----+--------+| 1  | 100    || 2  | 200    || 3  | 300    |+----+--------+\n输出：\n+---------------------+| SecondHighestSalary |+---------------------+| 200                 |+---------------------+\n示例 2：\n输入：Employee 表：\n+----+--------+| id | salary |+----+--------+| 1  | 100    |+----+--------+\n输出：\n+---------------------+| SecondHighestSalary |+---------------------+| null                |+---------------------+\n\n答案：\nSELECT    (SELECT DISTINCT            Salary        FROM            Employee        ORDER BY Salary DESC        LIMIT 1 OFFSET 1) AS SecondHighestSalary;\n让薪水去重排序，去除重复的薪水没有第二高的薪水时不会返回结果，我们需要使用临时表，去返回答案\n","categories":["SQL"],"tags":["学习"]},{"title":"江苏托收永不停机方案","url":"/java4u/2021/11/25/%E6%B1%9F%E8%8B%8F%E6%89%98%E6%94%B6%E6%B0%B8%E4%B8%8D%E5%81%9C%E6%9C%BA%E6%96%B9%E6%A1%88/","content":"永不停机规则永不停机是与银联进行对接，用户通过提供银行卡号、姓名、身份证信息，在我方营业厅柜台签订代扣协议进行签约绑定，签约时用户可自行设置不足额度（如5元、30元、50元）和每次代扣额度（如50元、100元、300元）。永不停机每日发起一次代扣，当用户账户额度不足预设限额后，自动向银联发起扣款请求，从用户银行卡中进行扣款并充值，扣款金额为用户签约时预设金额，如代扣后余额仍不足限额，可一次发起多笔扣款直至余额满足限额。代扣任务实时扣款后，将扣款成功与否信息发给我方，我方根据扣款情况进行BOSS入账。\n问题1.如何区分普通客户和永不停机客户？  签约时签约表添加永不停机的标识\nEntrustCreateTask   获取AM_ENTRUST_CREATE_NOTIFY 托收发起通知表 中state&#x3D;1 未处理的数据处理完将state更新为2 处理中\n2.通过发起任务生成托收明细表，之后再进行算费，倘若代扣的金额比较少，那就需要反复发起托收，进行反复算费？\n每日只发起一次托收，代扣金额不够就每天发起托收，直至金额到达设定的阙值\n3.在托收文件发送的时候，反复发起扣款请求\n每日一次，不会发起多次扣款\n4.需要调查欠查询用户金额，多次调用会超时如何解决\n将查询部分放到算费进程去处理\n5.托收不足金额和托收金额是哪个字段？永不停机进程每天查询一次签约表 am_entrust_relation 分公司为1001，类型为永不停机的数据同时页面不能查询到永不停机的数据  ——页面查询需要调整不足余额是总额还是某个业务不足\n大概方案步骤一：生成托收通知 每日从后台发起一次托收通知&#123;&quot;SELECT t.STATE ,t.* FROM ac.AM_ENTRUST_CREATE_NOTIFY t \\r\\n\\tWHERE BANK_ID =&#x27;1000001005&#x27; AND CORP_ORG_ID =&#x27;1001&#x27; AND SRC_TYPE =&#x27;6&#x27;&quot;: [       &#123;  &quot;STATE&quot; : 1,  &quot;NOTIFY_ID&quot; : 26153,  &quot;BANK_ID&quot; : 1000001005,  &quot;BANK_NAME&quot; : &quot;中国银联&quot;,  &quot;STAFF_ID&quot; : 100016545,  &quot;CORP_ORG_ID&quot; : 1001,  &quot;CORP_ORG_NAME&quot; : &quot;苏州分公司&quot;,  &quot;CREATE_TIME&quot; : &quot;2021-12-31T02:25:38.000Z&quot;,  &quot;STATE&quot; : 1,  &quot;STATE_TIME&quot; : &quot;2021-12-31T02:25:38.000Z&quot;,  &quot;REMARK&quot; : &quot;永不停机通知&quot;,  &quot;BUSI_TYPE&quot; : 2,  &quot;END_MON&quot; : &quot;2099-12-30T16:00:00.000Z&quot;,  &quot;SRC_TYPE&quot; : 6,  &quot;PAYBOSS_BATCH_ID&quot; : null   &#125;]&#125;\n\n步骤二：生成托收明细&#123;&quot;--托收明细表\\r\\nSELECT t.STATE,t.AMOUNT,t.* FROM ac.AM_ENTRUST_CREATE_DTL t WHERE corp_org_id=1001 AND BANK_ID =1000001005&quot;: [       &#123;   &quot;STATE&quot; : 5,   &quot;AMOUNT&quot; : null,   &quot;ENTRUST_CREATE_DTL_ID&quot; : 6794129,   &quot;ENTRUST_CREATE_ID&quot; : null,   &quot;CUST_NAME&quot; : &quot;朱忠华&quot;,   &quot;CUST_CODE&quot; : &quot;8523030001086&quot;,   &quot;BUSI_TYPE&quot; : 2,   &quot;CORP_ORG_ID&quot; : 1001,   &quot;CORP_ORG_NAME&quot; : &quot;苏州分公司&quot;,   &quot;ACCT_ID&quot; : 990002563106,   &quot;ACCT_NAME&quot; : &quot;朱忠华&quot;,   &quot;ACCT_TYPE&quot; : 1,   &quot;BANK_ID&quot; : 1000001005,   &quot;BANK_NAME&quot; : &quot;建设银行&quot;,   &quot;BANK_ACCT_ID&quot; : &quot;6221662072485938&quot;,   &quot;BANK_ACCT_NAME&quot; : &quot;8523030001086&quot;,   &quot;BANK_ACCT_TYPE&quot; : 5,   &quot;AMOUNT&quot; : null,   &quot;START_TIME&quot; : &quot;2021-12-31T02:24:10.000Z&quot;,   &quot;END_TIME&quot; : &quot;2021-12-31T02:24:10.000Z&quot;,   &quot;CREATE_TIME&quot; : &quot;2021-12-31T02:24:10.000Z&quot;,   &quot;BANK_DEAL_TIME&quot; : null,   &quot;STATE&quot; : 5,   &quot;STATE_TIME&quot; : &quot;2021-12-31T02:24:10.000Z&quot;,   &quot;IS_ERR&quot; : null,   &quot;ERR_CODE&quot; : null,   &quot;ERR_MSG&quot; : null,   &quot;REMARK&quot; : null,   &quot;CONTRACT_CODE&quot; : null,   &quot;CUST_ID&quot; : 2478574,   &quot;ENTRUST_DEAL_ID&quot; : 0,   &quot;SERV_ID&quot; : null,   &quot;SERVICE_ID&quot; : null,   &quot;BUSI_TYPE_NAME&quot; : null,   &quot;AMOUNT_LABEL&quot; : null,   &quot;SERVICE_NAME&quot; : null,   &quot;BANK_ACCT_BANK_ID&quot; : null,   &quot;AUTHOR_NO&quot; : null,   &quot;MEASURE_CODE&quot; : null,   &quot;ENTRUST_MONTHS&quot; : 0,   &quot;GIFT_MONTHS&quot; : 0,   &quot;ENTRUST_AMOUNT&quot; : 0,   &quot;GIFT_AMOUNT&quot; : 0,   &quot;PRICE_KIND_ID&quot; : 0,   &quot;NOTIFY_ID&quot; : 26153,   &quot;ENTRUST_RELATION_ID&quot; : 16851,   &quot;USER_TYPE&quot; : null   &#125;]&#125;UPDATE AM_ENTRUST_CREATE_NOTIFY  SET  STATE_TIME = ?,STATE = 2  where  STATE = ? and NOTIFY_ID = ?\n\n步骤三:计算托收金额update AM_ENTRUST_CREATE_DTL set  STATE_TIME = ? ,STATE = 6, END_TIME = ?, AMOUNT = ? where  ENTRUST_CREATE_DTL_ID = ?\n\n步骤四：生成托收文件名称，生成托收总表update AM_ENTRUST_CREATE_DTL set  STATE_TIME = ? ,STATE = 2, ENTRUST_CREATE_ID = ?    where  ENTRUST_CREATE_DTL_ID = ?&#123;&quot;SELECT * FROM ac.AM_ENTRUST_CREATE WHERE BANK_ID =1000001005&quot;: [        &#123;    &quot;ENTRUST_CREATE_ID&quot; : 1976467,    &quot;FILE_NAME&quot; : &quot;9001_2000_Send202112316467.txt&quot;,    &quot;BANK_ID&quot; : 1000001005,    &quot;BANK_NAME&quot; : &quot;中国银联&quot;,    &quot;CORP_ORG_ID&quot; : 1001,    &quot;CORP_ORG_NAME&quot; : &quot;苏州分公司&quot;,    &quot;TOTAL_AMOUNT&quot; : 10,    &quot;TOTAL_NUM&quot; : 1,    &quot;SUCC_NUM&quot; : null,    &quot;FAIL_NUM&quot; : null,    &quot;FORMAT_ERR_NUM&quot; : null,    &quot;STAFF_ID&quot; : 100016545,    &quot;CREATE_TIME&quot; : &quot;2021-12-31T03:13:23.000Z&quot;,    &quot;STATE&quot; : 1,    &quot;STATE_TIME&quot; : &quot;2021-12-31T03:13:23.000Z&quot;,    &quot;REMARK&quot; : null,    &quot;SRC_TYPE&quot; : 6,    &quot;BUSI_TYPE&quot; : 2,    &quot;AUTH_STATE&quot; : null,    &quot;AUDITOR_ID&quot; : null,    &quot;AUTH_TIME&quot; : null,    &quot;NOTIFY_ID&quot; : 26153    &#125;]&#125;UPDATE AM_ENTRUST_CREATE_NOTIFY  SET  STATE_TIME = ?,STATE = 3    where  STATE = ? and NOTIFY_ID = ?\n\n步骤五：自动送托文件生成并上发托收文件\nupdate AM_ENTRUST_CREATE set STATE = 2,STATE_TIME = ? where ROWID = ?\n\n步骤六：回盘文件处理（回盘进行解析）任务进程优化原先策略：写一个任务类继承AbstractSingleTaskDeal，该任务类可以进行查询数据和分发处理数据的操作    缺点：调度和分发代码与业务代码混合，集群处理任务时，需要配置通道号，启动多个进程任务进行处理\n优化策略：xxl-job调度任务（选型：quarts,Elastic-job,xxl-job，选型原因轻量级，融入项目简单，支持分布式调度）\n1.下载代码和依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;    &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;\n\n2.新建库和表tables_xxl_job.sql\n3.启动控制台\n\n4.编写执行器代码，修改执行器和初始化支持传入端口\n/** * 永不停机 * cron  0 0 2 * * ?   每天凌晨2点执行 * */@XxlJob(&quot;entrustNeverStopTaskHandler&quot;)public void entrustNeverStopTaskHandler() throws Exception &#123;    XxlJobHelper.log(&quot;EntrustNeverStopTaskHandler start&quot;);    EntrustNeverStopTaskApp app = new EntrustNeverStopTaskApp();    app.createEntrustNotify();    XxlJobHelper.log(&quot;EntrustNeverStopTaskHandler end&quot;);&#125;/** * 自动送托 * cron 0 0 3 * * ?   每天凌晨3点执行，确保托收总表已生成 * */@XxlJob(&quot;entrustAutoDeliveryTaskHandler&quot;)public void entrustAutoDeliveryTask() throws Exception &#123;    XxlJobHelper.log(&quot;entrustAutoDeliveryTaskHandler start&quot;);    EntrustAutoDeliveryTaskApp app = new EntrustAutoDeliveryTaskApp();    app.autoDelivery();    XxlJobHelper.log(&quot;entrustAutoDeliveryTaskHandler end&quot;);&#125;\n\n5.编写业务代码，取代之前的AbstractSingleTaskDeal任务处理类    将业务代码与分片调度分离开\n6.启动多条执行器，进行调度测试（支持自选路由方式）\n","categories":["方案"],"tags":["xxl-job","托收"]},{"title":"批量工单执行出错","url":"/java4u/2021/11/11/%E6%89%B9%E9%87%8F%E5%B7%A5%E5%8D%95%E6%89%A7%E8%A1%8C%E5%87%BA%E9%94%99/","content":"批量处理工单处理任务时，发现大量错误：CsfException [serviceCode&#x3D;asset_ITaskCSV_syncWriteOffTask, processName&#x3D;asset_writeoffAsynBatch,date&#x3D;2021-11-11 23:13:08, exceptionCode&#x3D;csf1219, exceptionMessage&#x3D;获取返回值失败，可能原因是服务端返回值过大，需要配置csf客户端maxContextLength大小，也可能是在给定时间内未收到服务的响应，无法获取到返回值,exceptionStack&#x3D;java.lang.OutOfMemoryError: GC overhead limit exceeded, requestId&#x3D;]\n原因：由于某种原因垃圾收集器占用了过多的时间（默认为进程所有 CPU 时间的 98%）并且在每次运行中回收的内存非常少（默认为堆的 2%）。      这实际上意味着您的程序停止执行任何进度并且一直忙于只运行垃圾收集。     为了防止您的应用程序在没有完成任何事情的情况下占用 CPU 时间，JVM 会抛出此问题，Error以便您有机会诊断问题\n现象：\n进程端报错，插入工单历史表出错[2021-11-11 23:13:13,738] [processor-1] (DataStoreImpl.java:773)  WARN  - 3108java.lang.Exception: SQLִŻ5;9Hat com.ai.appframe2.bo.DataStoreImpl.save2(DataStoreImpl.java:773)                                                  (                      )        at com.ai.appframe2.complex.tab.store.AdvanceDataStoreImpl.save2(AdvanceDataStoreImpl.java:44)        at com.ai.appframe2.bo.DataStoreImpl.save(DataStoreImpl.java:989)        at com.asiainfo.asset.component.po.bo.payment.BOBusiTaskEngine.save(BOBusiTaskEngine.java:141)        at com.asiainfo.asset.component.po.dao.payment.impl.BusiTaskDAOImpl.addBusiTaskHis(BusiTaskDAOImpl.java:186)        at sun.reflect.GeneratedMethodAccessor27.invoke(Unknown Source)        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)        at java.lang.reflect.Method.invoke(Method.java:498)        at com.ai.appframe2.complex.service.proxy.ProxyInvocationHandler.invoke(ProxyInvocationHandler.java:129)        at com.sun.proxy.$Proxy18.addBusiTaskHis(Unknown Source)        at com.ai.ac.core.writeoff.dao.BusiTaskDao.insertBusiTaskHis(BusiTaskDao.java:55)        at com.ai.ac.core.writeoff.bc.WriteOffAsynTaskApp.doWriteOffAsynEnd(WriteOffAsynTaskApp.java:125)        at com.ai.ac.core.writeoff.task.WriteOffAsynBatchTask.execute(WriteOffAsynBatchTask.java:146)        at com.ai.ac.core.writeoff.task.WriteOffAsynBatchTask.execute(WriteOffAsynBatchTask.java:30)        at com.ai.acctcomp.task.client.AbstractThreadTaskDeal.process(AbstractThreadTaskDeal.java:43)        at com.ai.acctcomp.queue.disruptor.MsgWorkHandler.onEvent(DisruptorQueueProcessor.java:92)        at com.ai.acctcomp.queue.disruptor.MsgWorkHandler.onEvent(DisruptorQueueProcessor.java:82)\t\t插入异常日志则为内存溢出\n\n\t临时解决方案：\tJVM 选项启用吞吐量收集：\t-XX:+UseParallelGC\t在此期间，请为您的应用程序提供尽可能多的堆空间：\t-Xms????m（其中????代表以 MB 为单位的堆空间量，例如-Xms8192m）\t如果这没有帮助，请尝试使用此选项设置更宽松的吞吐量目标：\t-XX:GCTimeRatio=19 \n\n\t查询JVM内存堆信息：\t\t[boss@js-cache-04 batchAsynWoff]$ jmap -heap 1095460Attaching to process ID 1095460, please wait...Debugger attached successfully.Server compiler detected.JVM version is 25.211-b12using thread-local object allocation.Parallel GC with 23 thread(s)Heap Configuration:   MinHeapFreeRatio         = 0   MaxHeapFreeRatio         = 100   MaxHeapSize              = 1073741824 (1024.0MB)   NewSize                  = 89128960 (85.0MB)   MaxNewSize               = 357564416 (341.0MB)   OldSize                  = 179306496 (171.0MB)   NewRatio                 = 2   SurvivorRatio            = 8   MetaspaceSize            = 21807104 (20.796875MB)   CompressedClassSpaceSize = 1073741824 (1024.0MB)   MaxMetaspaceSize         = 17592186044415 MB   G1HeapRegionSize         = 0 (0.0MB)Heap Usage:PS Young GenerationEden Space:   capacity = 119537664 (114.0MB)   used     = 118662472 (113.16535186767578MB)   free     = 875192 (0.8346481323242188MB)   99.26785251550507% used                          -----Eden区几乎被完全占用From Space:   capacity = 119013376 (113.5MB)   used     = 0 (0.0MB)   free     = 119013376 (113.5MB)   0.0% usedTo Space:   capacity = 119013376 (113.5MB)   used     = 0 (0.0MB)   free     = 119013376 (113.5MB)   0.0% usedPS Old Generation   capacity = 716177408 (683.0MB)   used     = 716172800 (682.99560546875MB)   free     = 4608 (0.00439453125MB)   99.99935658400439% used\t\t\t\t\t\t\t\t\t\t\t\t-------Old Generation几乎被完全占用\n\n因为修改堆空间只会暂时延缓问题出现的时间，是程序中出现的问题，需要分析dumpjmap -dump:file=a.dump &lt;pid&gt;  生成dump文件下载到本地，使用 jvisualvm 分析dump在使用MAT（MemoryAnalyzer）分析dump，查看dominator tree\n\n\ncom.asiainfo.asset.component.po.bo.payment.BOBusiTaskBean 占其中91%    ---------BOBusiTaskBean就是分发的对象快速处理任务的时候，会创建大量分发对象分发到多个线程处理，每个线程获取到分发对象，需要调销账服务进行处理，没有完成销账会一直持有分发对象，在不影响效率的情况下提供内存空间到1024M，任务顺利跑完\n","categories":["JVM"],"tags":["内存溢出","JVM"]},{"title":"其他框架","url":"/java4u/2021/10/06/6.2%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/","content":"其他框架1. 描述⼀下Hibernate的三个状态？a. transient(瞬时状态)：new出来⼀个对象，还没被保存到数据库中\nb. persistent(持久化状态)：对象已经保存到数据库中并且在hibernate session也存在该对象\nc. detached(离线状态)：对象在数据库中存在，hibernate session不存在\n2. Hibernate对⼀⼆级缓存的使⽤， Lazy-Load的理解;a. ⼀级缓存：hibernate的⼀级缓存是由session提供的，因此它只存在session的⽣命周期中。也就是说session关闭的时候该session所管理的⼀级缓存也随之被清除。hibernate的⼀级缓存是session所内置的，默认开启，不能被卸载，也不能进⾏任何配置。在缓存中的对象,具有持久性,session对象负责管理.⼀级缓存的优点是使⽤同⼀个session对象多次查询同⼀个数据对象,仅对数据库查询⼀次。⼀级缓存采⽤的是Key-Value的MAP⽅式来实现的。在缓存实体对象时，对象的主关键字ID是MAP的Key，实体对象就是对象的值。所以说⼀级缓存是以实体对象为单位进⾏存储的。访问的时候使⽤的是主键关键字ID。⼀级缓存使⽤的是⾃动维护的功能。但可以通过session提供的⼿动⽅法对⼀级缓存的管理进⾏⼿动⼲预。evict()⽅法⽤于将某个对象从session的⼀级缓存中清除。clear()⽅法⽤于将session缓存中的⽅法全部清除。\nb. ⼆级缓存：⼆级缓存的实现原理与⼀级缓存是⼀样的。也是通过Key-Value的Map来实现对对象的缓存。⼆级缓存是作⽤在SessionFactory范围内的。因此它可被所有的Session对象所共享。需要注意的是放⼊缓存中的数据不能有第三⽅的应⽤对数据进⾏修改。⼆级缓存默认关闭，需要程序员⼿动开启，默认为ehcache实现.\nc. 懒加载：当⽤到数据的时候才向数据库查询，这就是hibernate的懒加载特性。延迟加载策略能避免加载应⽤程序不需要访问的关联对象，以提⾼应⽤程序的性能。\n3. zookeeper有什么功能，选举算法如何进⾏：1、选举算法：1、Fast Leader(领导者选举)选举算法： 1.server启动时默认选举⾃⼰，并向整个集群⼴播\n 2.收到消息时，通过3层判断：选举轮数，zxid，server id⼤⼩判断是否同意对⽅，如果同意，则修改⾃⼰的选\n票，并向集群⼴播\n 3.QuorumCnxManager负责IO处理，每2个server建⽴⼀个连接，只允许id⼤的server连id⼩的server，每个\nserver启动单独的读写线程处理，使⽤阻塞IO\n 4.默认超过半数机器同意时，则选举成功，修改⾃身状态为LEADING或FOLLOWING\n 5.Obserer机器不参与选举\n2、原理：选举结果的影响权重关系是:⾸先看数据id,数据id⼤者胜出;其次再判断leader id,leader id⼤者胜出。3、举例： 假设有五台服务器组成的zookeeper集群,它们的id从1-5,同时它们都是最新启动的,也就是没有历史数据,在存放数\n据量这⼀点上,都是⼀样的.假设这些服务器依序启动,来看看会发⽣什么.\n \\1) 服务器1启动,此时只有它⼀台服务器启动了,它发出去的报没有任何响应,所以它的选举状态⼀直是LOOKING\n状态；\n \\2) 服务器2启动,它与最开始启动的服务器1进⾏通信,互相交换⾃⼰的选举结果,由于两者都没有历史数据,所以id\n值较⼤的服务器2胜出,但是由于没有达到超过半数以上的服务器都同意选举它(这个例⼦中的半数以上是3),所以服务器1,2还是继续保持LOOKING状态.\n \\3) 服务器3启动,根据前⾯的理论分析,服务器3成为服务器1,2,3中的⽼⼤,⽽与上⾯不同的是,此时有三台服务器\n选举了它,所以它成为了这次选举的leader.\n \\4) 服务器4启动,根据前⾯的分析,理论上服务器4应该是服务器1,2,3,4中最⼤的,但是由于前⾯已经有半数以上的\n服务器选举了服务器3,所以它只能接收当⼩弟的命了.\n \\5) 服务器5启动,同4⼀样,当⼩弟. \n4、zookeeper管理员指南： 1、集群中过半存活即可⽤，故集群选择奇数台机器；\n4. Netty⾼性能： 1、NIO异步⾮阻塞通信\n 2、“零拷⻉”\n 3、内存池ByteBuf\n 4、Netty提供了多种内存管理策略，通过在启动辅助类中配置相关参数，可以实现差异化的定制。\n 5、⾼效的Reactor线程模型：Reactor单线程(多线程、主从)模型，指的是所有的IO操作都在同⼀个NIO线程上⾯完成\n 6、为了尽可能提升性能，Netty采⽤了串⾏⽆锁化设计，在IO线程内部进⾏串⾏操作，避免多线程竞争导致的性能下降。表⾯上看，串⾏化设计似乎CPU利⽤率不⾼，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串⾏化的线程并⾏运⾏，这种局部⽆锁化的串⾏线程设计相⽐⼀个队列-多个⼯作线程模型性能更优。\n 7、⾼效的并发编程：Netty的⾼效并发编程主要体现在如下⼏点：\n \\1) volatile的⼤量、正确使⽤;\n \\2) CAS和原⼦类的⼴泛使⽤；\n \\3) 线程安全容器的使⽤； 4) 通过读写锁提升并发性能。\n 8、⾼效的序列化框架：\n 9、灵活的TCP参数配置能⼒：合理设置TCP参数在某些场景下对于性能的提升可以起到显著的效果，例如SO_RCVBUF和SO_SNDBUF。如果设置不当，对性能的影响是⾮常⼤的。\n5. 如何保证服务的幂等性？1、概念：接⼝的幂等性实际上就是接⼝可重复调⽤，在调⽤⽅多次调⽤的情况下，接⼝最终得到的结果是⼀致的。有些\n接⼝可以天然的实现幂等性，⽐如查询接⼝，对于查询来说，你查询⼀次和两次，对于系统来说，没有任何影响，查出的结果也是⼀样。\n2、GET幂等：值得注意，幂等性指的是作⽤于结果⽽⾮资源本身。怎么理解呢？例如，这个HTTP GET⽅法可能会每次\n得到不同的返回内容，但并不影响资源。\n3、POST⾮幂等：因为它会对资源本身产⽣影响，每次调⽤都会有新的资源产⽣，因此不满⾜幂等性。\n4、如何保证幂等性： 1、全局唯⼀id：如果使⽤全局唯⼀ID，就是根据业务的操作和内容⽣成⼀个全局ID，在执⾏操作前先根据这个全局唯⼀ID是否存在，来判断这个操作是否已经执⾏。如果不存在则把全局ID，存储到存储系统中，⽐如数据库、redis等。如果存在则表示该⽅法已经执⾏。从⼯程的⻆度来说，使⽤全局ID做幂等可以作为⼀个业务的基础的微服务存在，在很多的微服务中都会⽤到这样的服务，在每个微服务中都完成这样的功能，会存在⼯作量重复。另外打造⼀个⾼可靠的幂等服务还需要考虑很多问题，⽐如⼀台机器虽然把全局ID先写⼊了存储，但是在写⼊之后挂了，这就需要引⼊全局ID的超时机制。 使⽤全局唯⼀ID是⼀个通⽤⽅案，可以⽀持插⼊、更新、删除业务操作。但是这个⽅案看起来很美但是实现起来⽐较麻烦，下⾯的⽅案适⽤于特定的场景，但是实现起来⽐较简单。\n 2、去重表：这种⽅法适⽤于在业务中有唯⼀标的插⼊场景中，⽐如在以上的⽀付场景中，如果⼀个订单只会⽀付⼀次，所以订单ID可以作为唯⼀标识。这时，我们就可以建⼀张去重表，并且把唯⼀标识作为唯⼀索引，在我们实现时，把创建⽀付单据和写⼊去去重表，放在⼀个事务中，如果重复创建，数据库会抛出唯⼀约束异常，操作就会回滚。\n 3、插⼊或更新：这种⽅法插⼊并且有唯⼀索引的情况，⽐如我们要关联商品品类，其中商品的ID和品类的ID可以构成唯⼀索引，并且在数据表中也增加了唯⼀索引。这时就可以使⽤InsertOrUpdate操作。在mysql数据库中如下：\ninsert into goods_category (goods_id,category_id,create_time,update_time) values(#&#123;goodsId&#125;,#&#123;categoryId&#125;,now(),now())on DUPLICATE KEY UPDATEupdate_time=now()\n\n 4、多版本控制：这种⽅法适合在更新的场景中，⽐如我们要更新商品的名字，这时我们就可以在更新的接⼝中增加⼀个版本号，来做幂等\nupdate goods set name=#&#123;newName&#125;,version=#&#123;version&#125; where id=#&#123;id&#125; and version&lt;$&#123;version&#125;\n\n5、状态机控制：这种⽅法适合在有状态机流转的情况下，⽐如就会订单的创建和付款，订单的付款肯定是在之前，这时我们可以通过在设计状态字段时，使⽤int类型，并且通过值类型的⼤⼩来做幂等，⽐如订单的创建为0，付款成功为100。付款失败为99,在做状态机更新时，我们就这可以这样控制\nupdate `order` set status=#&#123;status&#125; where id=#&#123;id&#125; and status&lt;#&#123;status&#125;\n\n","categories":["面试"],"tags":["学习"]},{"title":"spring","url":"/java4u/2021/09/23/6.1%E6%A1%86%E6%9E%B6%E2%80%94Spring/","content":"框架–Spring1. Spring框架中IOC的原理是什么？(1). IoC（Inversion of Control）是指容器控制程序对象之间的关系，⽽不是传统实现中，由程序代码直接操控。控制权由应⽤代码中转到了外部容器，控制权的转移是所谓反转。 对于Spring⽽⾔，就是由Spring来控制对象的⽣命周期和对象之间的关系；IoC还有另外⼀个名字——“依赖注⼊（Dependency Injection）”。从名字上理解，所谓依赖注⼊，即组件之间的依赖关系由容器在运⾏期决定，即由容器动态地将某种依赖关系注⼊到组件之中。 \n(2). 在Spring的⼯作⽅式中，所有的类都会在spring容器中登记，告诉spring这是个什么东⻄，你需要什么东⻄，然后spring会在系统运⾏到适当的时候，把你要的东⻄主动给你，同时也把你交给其他需要你的东⻄。所有的类的创建、销毁都由spring来控制，也就是说控制对象⽣存周期的不再是引⽤它的对象，⽽是spring。对于某个具体的对象⽽⾔，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。\n(3). 在系统运⾏中，动态的向某个对象提供它所需要的其他对象。 \n(4). 依赖注⼊的思想是通过反射机制实现的，在实例化⼀个类时，它通过反射调⽤类中set⽅法将事先保存在HashMap中的类属性注⼊到类中。 总⽽⾔之，在传统的对象创建⽅式中，通常由调⽤者来创建被调⽤者的实例，⽽在Spring中创建被调⽤者的⼯作由Spring来完成，然后注⼊调⽤者，即所谓的依赖注⼊or控制反转。 注⼊⽅式有两种：依赖注⼊和设置注⼊； IoC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。\nCSF创建组件方式：\n使用BCFactory工厂方式创建，先创建一个SERVICES_CACHE，先根据类名从里面取组件，如果没取到，就创建之后放入缓存中\n","categories":["面试"],"tags":["学习"]},{"title":"springcloud","url":"/java4u/2021/09/21/4.2%E5%BE%AE%E6%9C%8D%E5%8A%A1--springcloud/","content":"微服务–springcloud1.springcloud和dubbo有哪些区别a. Dubbo具有调度、发现、监控、治理等功能，⽀持相当丰富的服务治理能⼒。Dubbo架构下，注册中⼼对等集群，并会缓存服务列表已被数据库失效时继续提供发现功能，本身的服务发现结构有很强的可⽤性与健壮性，⾜够⽀持⾼访问量的⽹站。\nb. 虽然Dubbo ⽀持短连接⼤数据量的服务提供模式，但绝⼤多数情况下都是使⽤⻓连接⼩数据量的模式提供服务使⽤的。所以，对于类似于电商等同步调⽤场景多并且能⽀撑搭建Dubbo 这套⽐较复杂环境的成本的产品⽽⾔，Dubbo 确实是⼀个可以考虑的选择。但如果产品业务中由于后台业务逻辑复杂、时间⻓⽽导致异步逻辑⽐较多的话，可能Dubbo 并不合适。同时，对于⼈⼿不⾜的初创产品⽽⾔，这么重的架构维护起来也不是很⽅便。\nc. Spring Cloud由众多⼦项⽬组成，如Spring Cloud Config、Spring Cloud Netflix、Spring Cloud Consul 等，提供了搭建分布式系统及微服务常⽤的⼯具，如配置管理、服务发现、断路器、智能路由、微代理、控制总线、⼀次性token、全局锁、选主、分布式会话和集群状态等，满⾜了构建微服务所需的所有解决⽅案。⽐如使⽤Spring Cloud Config 可以实现统⼀配置中⼼，对配置进⾏统⼀管理；使⽤Spring Cloud Netflix 可以实现Netflix 组件的功能 - 服务发现（Eureka）、智能路由（Zuul）、客户端负载均衡（Ribbon）。\nd. dubbo的开发难度较⼤，原因是dubbo的jar包依赖问题很多⼤型⼯程⽆法解决。\ne. Dubbo 提供了各种 Filter，对于上述中“⽆”的要素，可以通过扩展 Filter 来完善。\n2. 什么是服务熔断，什么是服务降级a. 服务熔断：（为防止系统出现雪崩情况，暂停对服务的调用）\ni. 如果检查出来频繁超时，就把consumer调⽤provider的请求，直接短路掉，不实际调⽤，⽽是直接返回⼀个mock的值。\nb. 服务降级：（返回一个处理好的错误信息）\ni. consumer 端：consumer 如果发现某个provider出现异常情况，⽐如，经常超时(可能是熔断引起的降级)，数据错误，这时，consumer可以采取⼀定的策略，降级provider的逻辑，基本的有直接返回固定的数据。\n\\2. provider 端：当provider 发现流量激增的时候，为了保护⾃身的稳定性，也可能考虑降级服务。\n⽐如，1，直接给consumer返回固定数据，2，需要实时写⼊数据库的，先缓存到队列⾥，异步写⼊数据库。\n3. 微服务的优缺点a. 优点：\ni. 单⼀职责：每个微服务仅负责⾃⼰业务领域的功能；\nii. ⾃治：⼀个微服务就是⼀个独⽴的实体，它可以独⽴部署、升级，服务与服务之间通过REST等形式的标准接⼝进⾏通信，并且⼀个微服务实例可以被替换成另⼀种实现，⽽对其它的微服务不产⽣影响。\niii. 逻辑清晰：微服务单⼀职责特性使微服务看起来逻辑清晰，易于维护。\niv. 简化部署：单系统中修改⼀处需要部署整个系统，⽽微服务中修改⼀处可单独部署⼀个服务。\nv. 可扩展：应对系统业务增⻓的⽅法通常采⽤横向（Scale out）或纵向（Scale up）的⽅向进⾏扩展。分布式系统中通常要采⽤Scale out的⽅式进⾏扩展。\nvi. 灵活组合：\nvii. 技术异构：不同的服务之间，可以根据⾃⼰的业务特点选择不通的技术架构，如数据库等。\nb. 缺点：\ni. 复杂度⾼：\n\\1. 服务调⽤要考虑被调⽤⽅故障、过载、消息丢失等各种异常情况，代码逻辑更加复杂；\n\\2. 对于微服务间的事务性操作，因为不同的微服务采⽤了不同的数据库，将⽆法利⽤数据库本身的事务机制保证⼀致性，需要引⼊⼆阶段提交等技术。\nii. 运维复杂：系统由多个独⽴运⾏的微服务构成，需要⼀个设计良好的监控系统对各个微服务的运⾏状态进⾏监控。运维⼈员需要对系统有细致的了解才对够更好的运维系统。\niii. 通信延迟：微服务之间调⽤会有时间损耗，造成通信延迟。\n4. 列举微服务技术栈a. 服务⽹关Zuul\nb. 服务注册发现Eureka+Ribbon\na. 服务配置中⼼Apollo\nb. 认证授权中⼼Spring Security OAuth2\nc. 服务框架Spring Boot\nd. 数据总线Kafka\ne. ⽇志监控ELK\nf. 调⽤链监控CAT\ng. Metrics监控KairosDB\nh. 健康检查和告警ZMon\ni. 限流熔断和流聚合Hystrix&#x2F;Turbine\n5. eureka和zookeeper都可以提供服务的注册与发现功能，他们的区别a. Zookeeper保证CP（一致性、分区容错）\n 当向注册中⼼查询服务列表时，我们可以容忍注册中⼼返回的是⼏分钟以前的注册信息，但不能接受服务直接down掉不可⽤。也就是说，服务注册功能对可⽤性的要求要⾼于⼀致性。但是zk会出现这样⼀种情况，当master节点因为⽹络故障与其他节点失去联系时，剩余节点会重新进⾏leader选举。问题在于，选举leader的时间太⻓，30 ~ 120s, 且选举期间整个zk集群都是不可⽤的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因⽹络问题使得zk集群失去master节点是较⼤概率会发⽣的事，虽然服务能够最终恢复，但是漫⻓的选举时间导致的注册⻓期不可⽤是不能容忍的。\nb. Eureka保证AP（高可用、分区容错）\n Eureka看明⽩了这⼀点，因此在设计时就优先保证可⽤性。Eureka各个节点都是平等的，⼏个节点挂掉不会影响正常节点的⼯作，剩余的节点依然可以提供注册和查询服务。⽽Eureka的客户端在向某个Eureka注册或如果发现连接失败，则会⾃动切换⾄其它节点，只要有⼀台Eureka还在，就能保证注册服务可⽤(保证可⽤性)，只不过查到的信息可能不是最新的(不保证强⼀致性)。除此之外，Eureka还有⼀种⾃我保护机制，如果在15分钟内超过85%的节点都没有正常的⼼跳，那么Eureka就认为客户端与注册中⼼出现了⽹络故障，此时会出现以下⼏种情况：\n \\1. Eureka不再从注册列表中移除因为⻓时间没收到⼼跳⽽应该过期的服务\n \\2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可⽤)\n \\3. 当⽹络稳定时，当前实例新的注册信息会被同步到其它节点中\n 因此， Eureka可以很好的应对因⽹络故障导致部分节点失去联系的情况，⽽不会像zookeeper那样使整个注册服务瘫痪。\n6. eureka服务注册与发现原理：a. 每30s发送⼼跳检测重新进⾏租约，如果客户端不能多次更新租约，它将在90s内从服务器注册中⼼移除。\nb. 注册信息和更新会被复制到其他Eureka 节点，来⾃任何区域的客户端可以查找到注册中⼼信息，每30s发⽣⼀次复制来定位他们的服务，并进⾏远程调⽤。\nc. 客户端还可以缓存⼀些服务实例信息，所以即使Eureka全挂掉，客户端也是可以定位到服务地址的。\n7.限流1、http限流：我们使⽤nginx的limitzone来完成： &#x2F;&#x2F;这个表示使⽤ip进⾏限流 zone名称为req_one 分配了10m 空间使⽤漏桶算法 每秒钟允许1个请求\nlimit_req_zone $binary_remote_addr zone&#x3D;req_one:10m rate&#x3D;1r&#x2F;s; \n这边burst表示可以瞬间超过20个请求 由于没有noDelay参数因此需要排队 如果超过这20个那么直接返回503\nlimit_req zone&#x3D;req_three burst&#x3D;20; \n2、dubbo限流：dubbo提供了多个和请求相关的filter：ActiveLimitFilter ExecuteLimitFilter TPSLimiterFilter\\1. ActiveLimitFilter： \n@Activate(group &#x3D; Constants.CONSUMER, value &#x3D; Constants.ACTIVES_KEY)\n作⽤于客户端，主要作⽤是控制客户端⽅法的并发度；\n当超过了指定的active值之后该请求将等待前⾯的请求完成【何时结束呢？依赖于该⽅法的timeout 如果没有设置timeout的话可能就是多个请求⼀直被阻塞然后等待随机唤醒。\n\\2. ExecuteLimitFilter： \n@Activate(group &#x3D; Constants.PROVIDER, value &#x3D; Constants.EXECUTES_KEY)\n作⽤于服务端，⼀旦超出指定的数⽬直接报错 其实是指在服务端的并⾏度【需要注意这些都是指的是在单台服务上⽽不是整个服务集群】\n\\3. TPSLimiterFilter： \n@Activate(group &#x3D; Constants.PROVIDER, value &#x3D; Constants.TPS_LIMIT_RATE_KEY)\n作⽤于服务端，控制⼀段时间内的请求数；默认情况下取得tps.interval字段表示请求间隔 如果⽆法找到则使⽤60s 根据tps字段表示允许调⽤次数。使⽤AtomicInteger表示允许调⽤的次数 每次调⽤减少1次当结果⼩于0之后返回不允许调⽤\n3、springcloud限流：1、我们可以通过semaphore.maxConcurrentRequests,coreSize,maxQueueSize和queueSizeRejectionThreshold设置信号量模式下的最⼤并发量、线程池⼤⼩、缓冲区⼤⼩和缓冲区降级阈值。 \n#不设置缓冲区，当请求数超过coreSize时直接降级\nhystrix.threadpool.userThreadPool.maxQueueSize&#x3D;-1 \n#超时时间⼤于我们的timeout接⼝返回时间\nhystrix.command.userCommandKey.execution.isolation.thread.timeoutInMilliseconds&#x3D;15000\n这个时候我们连续多次请求&#x2F;user&#x2F;command&#x2F;timeout接⼝，在第⼀个请求还没有成功返回时，查看输出⽇志可以发现只有第⼀个请求正常的进⼊到user-service的接⼝中，其它请求会直接返回降级信息。这样我们就实现了对服务请求的限流。\n2、漏桶算法：⽔（请求）先进⼊到漏桶⾥，漏桶以⼀定的速度出⽔，当⽔流⼊速度过⼤会直接溢出，可以看出漏桶算法能强⾏限制数据的传输速率。\n\n3、令牌桶算法：除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。如图2所示，令牌桶算法的原理是系统会以⼀个恒定的速度往桶⾥放⼊令牌，⽽如果请求需要被处理，则需要先从桶⾥获取⼀个令牌，当桶⾥没有令牌可取时，则拒绝服务。\n\n4、redis计数器限流；\n8.springcloud核⼼组件及其作⽤，以及springcloud⼯作原理：\nspringcloud由以下⼏个核⼼组件构成：\nEureka：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从EurekaServer拉取注册表，从⽽知道其他服务在哪⾥\nRibbon：服务间发起请求的时候，基于Ribbon做负载均衡，从⼀个服务的多台机器中选择⼀台\nFeign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求\nHystrix：发起请求是通过Hystrix的线程池来⾛的，不同的服务⾛不同的线程池，实现了不同服务调⽤的隔离，避免了服务雪崩的问题（CSF也会通过Hystrix线程池发起请求）\nZuul：如果前端、移动端要调⽤后端系统，统⼀从Zuul⽹关进⼊，由Zuul⽹关转发请求给对应的服务\n9. eureka缓存机制：\na. 第⼀层缓存：readOnlyCacheMap，本质上是ConcurrentHashMap：这是⼀个JVM的CurrentHashMap只读缓存，这个主要是为了供客户端获取注册信息时使⽤，其缓存更新，依赖于定时器的更新，通过和readWriteCacheMap 的值做对⽐，如果数据不⼀致，则以readWriteCacheMap 的数据为准。readOnlyCacheMap 缓存更新的定时器时间间隔，默认为30秒（AICACHE的readOnlyCache基于相同的机制）\nb. 第⼆层缓存：readWriteCacheMap，本质上是Guava缓存：此处存放的是最终的缓存， 当服务下线，过期，注册，状态变更，都会来清除这个缓存⾥⾯的数据。 然后通过CacheLoader进⾏缓存加载，在进readWriteCacheMap.get(key)的时候，⾸先看这个缓存⾥⾯有没有该数据，如果没有则通过CacheLoader的load⽅法去加载，加载成功之后将数据放⼊缓存，同时返回数据。 readWriteCacheMap 缓存过期时间，默认为 180 秒 。\nc. 缓存机制：设置了⼀个每30秒执⾏⼀次的定时任务，定时去服务端获取注册信息。获取之后，存⼊本地内存。\n10. 熔断的原理，以及如何恢复？\na. 服务的健康状况 &#x3D; 请求失败数 &#x2F; 请求总数.\n熔断器开关由关闭到打开的状态转换是通过当前服务健康状况和设定阈值⽐较决定的.\ni. 当熔断器开关关闭时, 请求被允许通过熔断器. 如果当前健康状况⾼于设定阈值, 开关继续保持关闭. 如果当前健康状况低于设定阈值, 开关则切换为打开状态.\nii. 当熔断器开关打开时, 请求被禁⽌通过.\niii. 当熔断器开关处于打开状态, 经过⼀段时间后, 熔断器会⾃动进⼊半开状态, 这时熔断器只允许⼀个请求通过. 当该请求调⽤成功时, 熔断器恢复到关闭状态. 若该请求失败, 熔断器继续保持打开状态, 接下来的请求被禁⽌通过.熔断器的开关能保证服务调⽤者在调⽤异常服务时, 快速返回结果, 避免⼤量的同步等待. 并且熔断器能在⼀段时间后继续侦测请求执⾏结果, 提供恢复服务调⽤的可能.\n（CSF会监控请求过来的请求，请求会被放入请求队列处理，当队列的请求大于设定的阈值时，拒绝请求）\n11. 服务雪崩？遇到过的雪崩：服务重启时，某台机不可用，影响到集群中所有服务，导致大部分请求都不可用（请求队列满，请求被拒绝）\n可能原因：大量慢SQL的查询堆积，占用了CSF服务导致线程无法释放，最后影响到所有服务\n\na. 简介：服务雪崩效应是⼀种因 服务提供者 的不可⽤导致 服务调⽤者 的不可⽤,并将不可⽤ 逐渐放⼤ 的过程.\nb. 形成原因：\ni. 服务提供者不可⽤\nii. 重试加⼤流量\niii. 服务调⽤者不可⽤\nc. 采⽤策略：\ni. 流量控制\nii. 改进缓存模式\niii. 服务⾃动扩容\niv. 服务调⽤者降级服务\n12. 接⼝限流⽅法？a. 限制 总并发数（⽐如 数据库连接池、线程池）\nb. 限制 瞬时并发数（如 nginx 的 limit_conn 模块，⽤来限制 瞬时并发连接数）\nc. 限制 时间窗⼝内的平均速率（如 Guava 的 RateLimiter、nginx 的 limit_req模块，限制每秒的平均速率）\nd. 限制 远程接⼝ 调⽤速率\ne. 限制 MQ 的消费速率\nf. 可以根据 ⽹络连接数、⽹络流量、CPU 或 内存负载 等来限流\n","categories":["面试"],"tags":["学习"]},{"title":"dubbo","url":"/java4u/2021/09/20/4.1%E5%BE%AE%E6%9C%8D%E5%8A%A1--dubbo/","content":"微服务–dubbo\n1.Dubbo 和 Spring Cloud 有什么区别？1）通信⽅式不同\n1、Dubbo 使⽤的是 RPC 通信，⽽ Spring Cloud 使⽤的是 HTTP RESTFul ⽅式。 \n2、dubbo由于是⼆进制的传输，占⽤带宽会更少（基于netty等）；springCloud是http协议传输，带宽会⽐较多，同时使⽤http协议（http+restful api）⼀般会使⽤JSON报⽂，消耗会更⼤。\n3、dubbo的开发难度较⼤，原因是dubbo的jar包依赖（存在代码级别的强依赖）问题很多⼤型⼯程⽆法解决；\nspringcloud的接⼝协议约定⽐较⾃由且松散，需要有强有⼒的⾏政措施来限制接⼝⽆序升级。\n4、dubbo的改进是通过dubbofilter，很多东⻄没有，需要⾃⼰继承，如监控，如⽇志，如限流，如追踪。springcloud具有配置管理、服务发现、断路器、智能路由、微代理、控制总线、⼀次性token、全局锁、选主、分布式会话和集群状态等，满⾜了构建微服务所需的所有解决⽅案。\n2）组成不同\n2.Dubbo⾥⾯有哪⼏种节点⻆⾊？\n3.Dubbo服务注册与发现流程\n4.Dubbo有哪⼏种集群容错⽅案，默认是哪种？\n5.Dubbo有哪⼏种负载均衡策略，默认是哪种？\n6.Dubbo服务之间的调⽤是阻塞的吗？默认是同步等待结果阻塞的，⽀持异步调⽤。Dubbo 是基于 NIO 的⾮阻塞实现并⾏调⽤，客户端不需要启动多线程即可完成并⾏调⽤多个远程服务，相对多线程开销较⼩，异步调⽤会返回⼀个 Future 对象。\n异步调⽤流程图如下。\n\n7.说说 Dubbo 服务暴露的过程Dubbo 会在 Spring 实例化完 bean 之后，在刷新容器最后⼀步发布 ContextRefreshEvent 事件的时候，通知实现了ApplicationListener 的 ServiceBean 类进⾏回调 onApplicationEvent 事件⽅法，Dubbo 会在这个⽅法中调⽤ ServiceBean ⽗类ServiceConfig 的 export ⽅法，⽽该⽅法真正实现了服务的（异步或者⾮异步）发布。\n8.注册中⼼挂了，消费者还能调⽤服务者吗？\\1. 注册中⼼对等集群，任意⼀台宕掉后，会⾃动切换到另⼀台\n\\2. 注册中⼼全部宕掉，服务提供者和消费者仍可以通过本地缓存通讯\n\\3. 服务提供者⽆状态，任⼀台 宕机后，不影响使⽤\n\\4. 服务提供者全部宕机，服务消费者会⽆法使⽤，并⽆限次重连等待服务者恢复\n","categories":["面试"],"tags":["学习"]},{"title":"托收算费优化","url":"/java4u/2021/09/16/%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%8C%96/","content":"场景：新上线常州分公司的托收任务（20W数据） 算费过慢    目标（每分钟处理 5000条数据）\n分析：\t一条数据共耗时：2719ms  查询托收关系表\t1.  92ms  select * from AM_ENTRUST_RELATION where 1 = 1  and state = ? and ACCT_ID = ? \t--加索引，gj2环境已经加了\t2.  824ms   EntrustFunc.qryAcctAllStopServ ,判断是否为主动停机用户\t--建议查询计费用户状态表\t3. 214ms 从注册中心获取远程服务地址:OC.BC.person.IQryCustIdSV.checkCustExistsByType-&gt;http://10.97.114.108:10001/service\t--建议查询计费用户状态表\t4. 542ms 从注册中心获取远程服务地址:OC.person.IQueryScaInfoSV.queryUserCustAcctInfoByAccId-&gt;http://10.97.114.108:10001/service\t--建议查询计费用户状态表\t5. 412ms select b.service_id,a.object_id,min(a.PRODUCT_STATUS) status_min,max(a.PRODUCT_STATUS) status_max,min(a.VALID_DATE) valid_date,max(a.EXPIRE_DATE) expire_date from CD.CO_PROD_STS_0523_1 a left join CD.CO_PROD_0523_1 b on a.PRODUCT_ID=b.PRODUCT_ID and b.service_id is not null where a.OBJECT_TYPE= 0 and a.PRODUCT_STATUS !=0 and a.EXPIRE_DATE&gt;=sysdate and a.OBJECT_ID in (108727164,108727147,102349814) group by a.object_id,b.SERVICE_ID \t--优化索引，gj2环境已经加了--50ms左右\t6. 606ms 本次调用服务asset_IPaymentCSV_queryOweFee总耗时:606ms\t\t30分钟大概处理4000条数据\n\n第一次优化：\t1.优化表，表加索引\t2.减少去三户信息的调用  查表替代\t3.优化查欠      查欠不查询三户信息，托收不需要获取客户的三户信息\t结果：\t目前效率 1分钟500条     500 * 60 = 3W条\t大部分使用CPU（5-6）  服务器：32核\t提升线程数也不能提供CPU的使用分析：\tCPU占用上不去，进程太少\t多的分公司有20W数据，优化拆分逻辑，对账户进行取模分发\t（分发数据前修改查询方式）\n\n\t第二次优化：\t\t添加通道，对MOD(A.CUST_CODE,10000) 0-1999 2000-3999 4000-5999 6000-7999 8000-9999 在分5个进程处理\t\t\t\t\t结果：\t\t每分钟大概3500条\t\t\t\t分析：[2021-09-21 14:55:33,715] [processor-6] (ClientStub.java:119)  INFO  - 本次调用服务asset_ICycleCSV_querySysPreCycle总耗时:394ms[2021-09-21 14:55:34,124] [processor-6] (ClientStub.java:119)  INFO  - 本次调用服务asset_ICycleCSV_querySysCurCycle总耗时:342ms[2021-09-21 14:55:34,377] [processor-6] (ClientStub.java:119)  INFO  - 本次调用服务asset_ICycleCSV_querySysMaxCycle总耗时:250ms[2021-09-21 14:55:34,966] [processor-6] (ClientStub.java:119)  INFO  - 本次调用服务acomp_ICommParamCSV_getList总耗时:570ms[2021-09-21 14:55:35,406] [processor-6] (ClientStub.java:119)  INFO  - 本次调用服务acomp_ICommParamCSV_getList总耗时:435ms[2021-09-21 14:55:36,051] [processor-6] (ClientStub.java:119)  INFO  - 本次调用服务asset_IEntrustDoCSV_doEntrustErr总耗时:618ms\t\t\t\t发现多次去调用服务查询账期（查询虚销时需要查询账期）\t\t实际获取的都是系统账期（当前没有分库），只需要查询一次就可以了\n\n第三次优化：\t进程启动时查询账期数据放入缓存，\t查欠修改支持外部传入账期，\t账期只有第一次需要查询，之后直接获取即可\t结果：\t2台主机，30个进程，10个线程，5000条/分钟--7000条/分钟","categories":["调优"],"tags":["进程优化"]},{"title":"多线程","url":"/java4u/2021/09/03/4.%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"1. 什么是线程？1、线程是操作系统能够进⾏运算调度的最⼩单位，它被包含在进程之中，是进程中的实际运作单位，可以使⽤多线程对进⾏运算提速。\n2.什么是⾃旋锁？⾃旋锁是SMP架构中的⼀种low-level的同步机制。\n1、当线程A想要获取⼀把⾃旋锁⽽该锁⼜被其它线程锁持有时，线程A会在⼀个循环中⾃旋以检测锁是不是已经可⽤了。 \n2、⾃选锁需要注意：\n由于⾃旋时不释放CPU，因⽽持有⾃旋锁的线程应该尽快释放⾃旋锁，否则等待该⾃旋锁的线程会⼀直在那⾥⾃旋，这就会浪费CPU时间。持有⾃旋锁的线程在sleep之前应该释放⾃旋锁以便其它线程可以获得⾃旋锁。\n3、⽬前的JVM实现⾃旋会消耗CPU，如果⻓时间不调⽤doNotify⽅法，doWait⽅法会⼀直⾃旋，CPU会消耗太⼤\n4、⾃旋锁⽐较适⽤于锁使⽤者保持锁时间⽐较短的情况，这种情况⾃旋锁的效率⽐较⾼。\n5、⾃旋锁是⼀种对多处理器相当有效的机制，⽽在单处理器⾮抢占式的系统中基本上没有作⽤。\n3. 什么是CAS？1、CAS（compare and swap）的缩写，中⽂翻译成⽐较并交换。\n2、CAS 不通过JVM,直接利⽤java本地⽅ JNI（Java Native Interface为JAVA本地调⽤）,直接调⽤CPU 的cmpxchg（是汇编指令）指令。\n3、利⽤CPU的CAS指令，同时借助JNI来完成Java的⾮阻塞算法,实现原⼦操作。其它原⼦操作都是利⽤类似的特性完成的。\n4、整个java.util.concurrent都是建⽴在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很⼤的提升。\n5、CAS是项乐观锁技术，当多个线程尝试使⽤CAS同时更新同⼀个变量时，只有其中⼀个线程能更新变量的值，⽽其它线程都失败，失败的线程并不会被挂起，⽽是被告知这次竞争中失败，并可以再次尝试。\n\n1、使⽤CAS在线程冲突严重时，会⼤幅降低程序性能；CAS只适合于线程冲突较少的情况使⽤。\n2、synchronized在jdk1.6之后，已经改进优化。synchronized的底层实现主要依靠Lock-Free的队列，基本思路是⾃旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了⾼吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；⽽线程冲突严重的情况下，性能远⾼于CAS。\n\n4. 什么是AQS？1、AbstractQueuedSynchronizer简称AQS，是⼀个⽤于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建，例如ReentrantLock，Semaphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时设计的⼤量细节问题。2、AQS使⽤⼀个FIFO的队列表示排队等待锁的线程，队列头节点称作“哨兵节点”或者“哑节点”，它不与任何线程关联。其他的节点与等待线程关联，每个节点维护⼀个等待状态waitStatus。\n5. 什么是阻塞队列？如何使⽤阻塞队列来实现⽣产者-消费者模型？1、JDK7提供了7个阻塞队列。（也属于并发容器）\ni. ArrayBlockingQueue ：⼀个由数组结构组成的有界阻塞队列。\nii. LinkedBlockingQueue ：⼀个由链表结构组成的有界阻塞队列。\niii. PriorityBlockingQueue ：⼀个⽀持优先级排序的⽆界阻塞队列。\niv. DelayQueue：⼀个使⽤优先级队列实现的⽆界阻塞队列。\nv. SynchronousQueue：⼀个不存储元素的阻塞队列。\nvi. LinkedTransferQueue：⼀个由链表结构组成的⽆界阻塞队列。\nvii. LinkedBlockingDeque：⼀个由链表结构组成的双向阻塞队列。\n2、概念：阻塞队列是⼀个在队列基础上⼜⽀持了两个附加操作的队列。 \n3、2个附加操作：\n⽀持阻塞的插⼊⽅法：队列满时，队列会阻塞插⼊元素的线程，直到队列不满。\n⽀持阻塞的移除⽅法：队列空时，获取元素的线程会等待队列变为⾮空。\n6. 什么是Callable和Future?1、Callable 和 Future 是⽐较有趣的⼀对组合。当我们需要获取线程的执⾏结果时，就需要⽤到它们。Callable⽤于产⽣结果，Future⽤于获取结果。\n2、Callable接⼝使⽤泛型去定义它的返回类型。Executors类提供了⼀些有⽤的⽅法去在线程池中执⾏Callable内的任务。由于Callable任务是并⾏的，必须等待它返回的结果。java.util.concurrent.Future对象解决了这个问题。\n3、在线程池提交Callable任务后返回了⼀个Future对象，使⽤它可以知道Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()⽅法，等待Callable结束并获取它的执⾏结果。\n7. 什么是FutureTask?1、FutureTask可⽤于异步获取执⾏结果或取消执⾏任务的场景。通过传⼊Runnable或者Callable的任务给FutureTask，直接调⽤其run⽅法或者放⼊线程池执⾏，之后可以在外部通过FutureTask的get⽅法异步获取执⾏结果，因此，FutureTask⾮常适合⽤于耗时的计算，主线程可以在完成⾃⼰的任务后，再去获取结果。另外，FutureTask还可以确保即使调⽤了多次run⽅法，它都只会执⾏⼀次Runnable或者Callable任务，或者通过cancel取消FutureTask的执⾏等。\n2、futuretask可⽤于执⾏多任务、以及避免⾼并发情况下多次创建数据机锁的出现。\n8. ThreadLocal的设计理念与作⽤？Java中的ThreadLocal类允许我们创建只能被同⼀个线程读写的变量。因此，如果⼀段代码含有⼀个ThreadLocal变量的引⽤，即使两个线程同时执⾏这段代码，它们也⽆法访问到对⽅的ThreadLocal变量。\n 1、概念：线程局部变量。在并发编程的时候，成员变量如果不做任何处理其实是线程不安全的，各个线程都在操作同⼀个变量，显然是不⾏的，并且我们也知道volatile这个关键字也是不能保证线程安全的。那么在有⼀种情况之下，我们需要满⾜这样⼀个条件：变量是同⼀个，但是每个线程都使⽤同⼀个初始值，也就是使⽤同⼀个变量的⼀个新的副本。这种情况之下ThreadLocal就⾮常适⽤，⽐如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是⼀个线程安全的变量。⽽我们每个线程都需要使⽤他，并且各⾃使⽤各⾃的。这种情况，ThreadLocal就⽐较好的解决了这个问题。\n 2、原理：从本质来讲，就是每个线程都维护了⼀个map，⽽这个map的key就是threadLocal，⽽值就是我们set的那个值，每次线程在get的时候，都从⾃⼰的变量中取值，既然从⾃⼰的变量中取值，那肯定就不存在线程安全问题，总体来讲，ThreadLocal这个变量的状态根本没有发⽣变化，他仅仅是充当⼀个key的⻆⾊，另外提供给每⼀个线程⼀个初始值。\n 3、实现机制：每个Thread对象内部都维护了⼀个ThreadLocalMap这样⼀个ThreadLocal的Map，可以存放若⼲个ThreadLocal。 \n 4、应⽤场景：当很多线程需要多次使⽤同⼀个对象，并且需要该对象具有相同初始化值的时候最适合使⽤ThreadLocal。\n9. synchronized和ReentrantLock的区别？1、基础知识\n可重⼊锁。可重⼊锁是指同⼀个线程可以多次获取同⼀把锁。ReentrantLock和synchronized都是可重⼊锁。\n可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是不可中断锁，⽽ReentrantLock则提供了中断功能。\n公平锁与⾮公平锁。公平锁是指多个线程同时尝试获取同⼀把锁时，获取锁的顺序按照线程达到的顺序，⽽⾮公平锁则允许线程“插队”。synchronized是⾮公平锁，⽽ReentrantLock的默认实现是⾮公平锁，但是也可以设置为公平锁。\nCAS操作(CompareAndSwap)。CAS操作简单的说就是⽐较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会⾃动将该位置值更新为新值。否则，处理器不做任何操作。⽆论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” \n2、Synchronized\ni. synchronized是java内置的关键字，它提供了⼀种独占的加锁⽅式。synchronized的获取和释放锁由JVM实现，⽤户不需要显示的释放锁，⾮常⽅便。然⽽synchronized也有⼀定的局限性：\n\\1. 当线程尝试获取锁的时候，如果获取不到锁会⼀直阻塞。\n\\2. 如果获取锁的线程进⼊休眠或者阻塞，除⾮当前线程异常，否则其他线程尝试获取锁必须⼀直等待。\n3、ReentrantLock\ni. ReentrantLock它是JDK 1.5之后提供的API层⾯的互斥锁，需要lock()和unlock()⽅法配合try&#x2F;finally语句块来完成。\nii. 等待可中断避免，出现死锁的情况（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false）\niii. 公平锁与⾮公平锁多个线程等待同⼀个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁⾮公平锁，ReentrantLock默认的构造函数是创建的⾮公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。\n10. ⾼并发、任务执⾏时间短的业务怎样使⽤线程池？并发不⾼、任务执⾏时间⻓的业务怎样使⽤线程池？并发⾼、业务执⾏时间⻓的业务怎样使⽤线程池？\\1. ⾼并发、任务执⾏时间短的业务：线程池线程数可以设置为CPU核数+1，减少线程上下⽂的切换。\n\\2. 并发不⾼、任务执⾏时间⻓的业务要区分开看：\na. 假如是业务时间⻓集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占⽤CPU，所以不要让所有的CPU\n闲下来，可以加⼤线程池中的线程数⽬，让CPU处理更多的业务\nb. 假如是业务时间⻓集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）⼀样吧，线程池中的线程数设置得少⼀些，减少线程上下⽂的切换\n\\3. 并发⾼、业务执⾏时间⻓，解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，看看这些业务⾥⾯某些数据是否能做缓存是第⼀步，增加服务器是第⼆步，⾄于线程池的设置，设置参考（2）。最后，业务执⾏时间⻓的问题，也可能需要分析⼀下，看看能不能使⽤中间件对任务进⾏拆分和解耦。\n11. 如何检测死锁？怎么预防死锁？1. 概念：是指两个或两个以上的进程在执⾏过程中，因争夺资源⽽造成的⼀种互相等待的现象，若⽆外⼒作⽤，它们都将⽆法推进下去。此时称系统处于死锁；\n2. 死锁的四个必要条件：i. 互斥条件：进程对所分配到的资源不允许其他进程进⾏访问，若其他进程访问该资源，只能等待，直⾄占有该资源的进程使⽤完成后释放该资源\nii. 请求和保持条件：进程获得⼀定的资源之后，⼜对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但⼜对⾃⼰获得的资源保持不放\niii. 不可剥夺条件：是指进程已获得的资源，在未完成使⽤之前，不可被剥夺，只能在使⽤完后⾃⼰释放\niv. 环路等待条件：是指进程发⽣死锁后，若⼲进程之间形成⼀种头尾相接的循环等待资源关系\n3. 死锁产⽣的原因：1.因竞争资源发⽣死锁 现象：系统中供多个进程共享的资源的数⽬不⾜以满⾜全部进程的需要时，就会引起对诸资源的竞争⽽发⽣死锁现象\n2.进程推进顺序不当发⽣死锁\n4. 检查死锁i. 有两个容器，⼀个⽤于保存线程正在请求的锁，⼀个⽤于保存线程已经持有的锁。每次加锁之前都会做如下检测:\nii. 检测当前正在请求的锁是否已经被其它线程持有,如果有，则把那些线程找出来\niii. 遍历第⼀步中返回的线程，检查⾃⼰持有的锁是否正被其中任何⼀个线程请求，如果第⼆步返回真,表示出现了死锁\n5. 死锁的解除与预防：控制不要让四个必要条件成⽴。12. 线程池原理： 1、使⽤场景：假设⼀个服务器完成⼀项任务所需时间为：T1-创建线程时间，T2-在线程中执⾏任务的时间，T3-销毁线程时间。如果T1+T3远⼤于T2，则可以使⽤线程池，以提⾼服务器性能；\n 2、组成：\n 1、线程池管理器（ThreadPool）：⽤于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；\n 2、⼯作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执⾏任务；\n 3、任务接⼝（Task）：每个任务必须实现的接⼝，以供⼯作线程调度任务的执⾏，它主要规定了任务的⼊⼝，任务执⾏完后的收尾⼯作，任务的执⾏状态等；\n 4、任务队列（taskQueue）：⽤于存放没有处理的任务。提供⼀种缓冲机制。\n 2、原理：线程池技术正是关注如何缩短或调整T1,T3时间的技术，从⽽提⾼服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者⼀些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。 \n 3、⼯作流程：\n 1、线程池刚创建时，⾥⾯没有⼀个线程(也可以设置参数prestartAllCoreThreads启动预期数量主线程)。任务队列是作\n为参数传进来的。不过，就算队列⾥⾯有任务，线程池也不会⻢上执⾏它们。\n 2、当调⽤ execute() ⽅法添加⼀个任务时，线程池会做如下判断：\n\\1. 如果正在运⾏的线程数量⼩于 corePoolSize，那么⻢上创建线程运⾏这个任务；\n\\2. 如果正在运⾏的线程数量⼤于或等于 corePoolSize，那么将这个任务放⼊队列；\n\\3. 如果这时候队列满了，⽽且正在运⾏的线程数量⼩于 maximumPoolSize，那么还是要创建⾮核⼼线程⽴刻运⾏这个任务；\n\\4. 如果队列满了，⽽且正在运⾏的线程数量⼤于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。\n 3、当⼀个线程完成任务时，它会从队列中取下⼀个任务来执⾏。\n 4、当⼀个线程⽆事可做，超过⼀定的时间（keepAliveTime）时，线程池会判断，如果当前运⾏的线程数⼤于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的⼤⼩。\n13、ThreadLocal为什么会发⽣内存泄漏？1、threadlocal原理图：\n\n2、OOM实现：\n1、ThreadLocal的实现是这样的：每个Thread 维护⼀个 ThreadLocalMap 映射表，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object。 \n2、也就是说 ThreadLocal 本身并不存储值，它只是作为⼀个 key 来让线程从 ThreadLocalMap 获取 value。值得注意的是图中的虚线，表示 ThreadLocalMap 是使⽤ ThreadLocal 的弱引⽤作为 Key 的，弱引⽤的对象在 GC 时会被回收。\n3、ThreadLocalMap使⽤ThreadLocal的弱引⽤作为key，如果⼀个ThreadLocal没有外部强引⽤来引⽤它，那么系统 GC的时候，这个ThreadLocal势必会被回收，这样⼀来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会⼀直存在⼀条强引⽤链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远⽆法回收，造成内存泄漏。\n3、预防办法：在ThreadLocal的get(),set(),remove()的时候都会清除线程ThreadLocalMap⾥所有key为null的value。但是这些被动的预防措施并不能保证不会内存泄漏：\n（1）使⽤static的ThreadLocal，延⻓了ThreadLocal的⽣命周期，可能导致内存泄漏。\n（2）分配使⽤了ThreadLocal⼜不再调⽤get(),set(),remove()⽅法，那么就会导致内存泄漏，因为这块内存⼀直存在。\n14、⾼并发系统如何做性能优化？如何防⽌库存超卖？1、⾼并发系统性能优化： 优化程序，优化服务配置，优化系统配置\n 1.尽量使⽤缓存，包括⽤户缓存，信息缓存等，多花点内存来做缓存，可以⼤量减少与数据库的交互，提⾼性能。\n 2.⽤jprofiler等⼯具找出性能瓶颈，减少额外的开销。\n 3.优化数据库查询语句，减少直接使⽤hibernate等⼯具的直接⽣成语句（仅耗时较⻓的查询做优化）。\n 4.优化数据库结构，多做索引，提⾼查询效率。\n 5.统计的功能尽量做缓存，或按每天⼀统计或定时统计相关报表，避免需要时进⾏统计的功能。\n 6.能使⽤静态⻚⾯的地⽅尽量使⽤，减少容器的解析（尽量将动态内容⽣成静态html来显示）。\n 7.解决以上问题后，使⽤服务器集群来解决单台的瓶颈问题。\n2、防⽌库存超卖：1、悲观锁：在更新库存期间加锁，不允许其它线程修改； 1、数据库锁：select xxx for update；\n 2、分布式锁；\n2、乐观锁：使⽤带版本号的更新。每个线程都可以并发修改，但在并发时，只有⼀个线程会修改成功，其它会返回失败。 1、redis watch：监视键值对，作⽤时如果事务提交exec时发现监视的监视对发⽣变化，事务将被取消。\n3、消息队列：通过 FIFO 队列，使修改库存的操作串⾏化。 4、总结：总的来说，不能把压⼒放在数据库上，所以使⽤ “select xxx for update” 的⽅式在⾼并发的场景下是不可⾏的。FIFO 同步队列的⽅式，可以结合库存限制队列⻓，但是在库存较多的场景下，⼜不太适⽤。所以相对来说，我会倾向于选择：乐观锁 &#x2F; 缓存锁 &#x2F; 分布式锁的⽅式。\n15、说说java同步机制，java有哪些锁，每个锁的特性？synchronized  lock\n16、说说volatile如何保证可⻅性，从cpu层⾯分析？加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障，它有三个功能：\n1.确保指令重排序时不会把其后面的指令重排到内存屏障之前的位置，也不会把前面的指令排到内存屏障后面，即在执行到内存屏障这句指令时，前面的操作已经全部完成；2.将当前处理器缓存行的数据立即写回系统内存（由volatile先行发生原则保证）；3.这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。写回操作时要经过总线传播数据，而每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器要对这个值进行修改的时候，会强制重新从系统内存里把数据读到处理器缓存(也是由volatile先行发生原则保证)；\n","categories":["面试"],"tags":["学习"]},{"title":"475. 供暖器","url":"/java4u/2021/09/01/475.%20%E4%BE%9B%E6%9A%96%E5%99%A8/","content":"475. 供暖器冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。\n在加热器的加热半径范围内的每个房屋都可以获得供暖。\n现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。\n说明：所有供暖器都遵循你的半径标准，加热的半径也一样。\n示例 1:\n输入: houses &#x3D; [1,2,3], heaters &#x3D; [2]输出: 1解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。\n示例 2:\n输入: houses &#x3D; [1,2,3,4], heaters &#x3D; [1,4]输出: 1解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。\n示例 3：\n输入：houses &#x3D; [1,5], heaters &#x3D; [2]输出：3\n提示：\n1 &lt;&#x3D; houses.length, heaters.length &lt;&#x3D; 3 * 10^41 &lt;&#x3D; houses[i], heaters[i] &lt;&#x3D; 10^9\n题解/** * 找到供暖期和房屋距离的最大值 * 2 * 1 2 3 * &lt;p&gt; * 1     4 * 1 2 3 4 * &lt;p&gt; * 2 * 1       5 * * @param houses * @param heaters * @return */public int findRadius(int[] houses, int[] heaters) &#123;    //该法能成立的先决条件为两数组一定都要从小到大排好序    Arrays.sort(heaters);    Arrays.sort(houses);    int l = 0;    int r = Math.max(houses[houses.length - 1], heaters[heaters.length - 1]);    //开始二分枚举    while (l &lt; r) &#123;        //无符号的右移        int mid = (l + r) &gt;&gt;&gt; 1;        //成立时，右界移动至中心        if (Helper(houses, heaters, mid)) &#123;            r = mid;        &#125; else &#123;            //不成立时，左界移至中心+1            //这样可以保证最后的跳出循环l一定为半径最小            l = mid + 1;        &#125;    &#125;    return l;&#125;public boolean Helper(int[] houses, int[] heaters, int len) &#123;    int m = houses.length;    int index = 0;    for (int heater : heaters) &#123;        long l = heater - len, r = heater + len;        //计算能否完全覆盖房屋        while (index &lt; m &amp;&amp; (long) houses[index] &gt;= l &amp;&amp; (long) houses[index] &lt;= r) &#123;            index++;        &#125;        if (index == m) return true;    &#125;    return false;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","二分法"]},{"title":"154. 寻找旋转排序数组中的最小值 II","url":"/java4u/2021/08/31/154.%20%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%20II/","content":"154. 寻找旋转排序数组中的最小值 II已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,4,4,5,6,7] 在变化后可能得到：若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。\n给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n你必须尽可能减少整个过程的操作步骤。\n示例 1：\n输入：nums &#x3D; [1,3,5]输出：1\n示例 2：\n输入：nums &#x3D; [2,2,2,0,1]输出：0\n提示：\nn &#x3D;&#x3D; nums.length1 &lt;&#x3D; n &lt;&#x3D; 5000-5000 &lt;&#x3D; nums[i] &lt;&#x3D; 5000nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\n进阶：这道题与 寻找旋转排序数组中的最小值 类似，但 nums 可能包含重复元素。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？\n题解/** * 输入：nums = [2,2,2,0,1] * 2 2 2 *         1 *       0 * *     2 2 2 *   1 * 0 * @param nums * @return */public int findMin(int[] nums) &#123;    int left = 0;    int right = nums.length-1;    while (left &lt; right) &#123;        int mid = left + (right -left)/2;        if(nums[mid] &lt; nums[right])&#123;            right = mid;        &#125;else if(nums[mid] &gt; nums[right])&#123;            left = mid +1;        &#125;else &#123;            // 1 1 1 1 0 1 1            //       m     r            // 1 0 1 1 1 1 1            //       m     r            //最小值可能在左边或右边，不使用二分法，只能砍掉右边界            right--;        &#125;    &#125;    return nums[left];&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","二分法"]},{"title":"153. 寻找旋转排序数组中的最小值","url":"/java4u/2021/08/27/153.%20%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","content":"153. 寻找旋转排序数组中的最小值已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums &#x3D; [0,1,2,4,5,6,7] 在变化后可能得到：若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。\n给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\n输入：nums &#x3D; [3,4,5,1,2]输出：1解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。\n示例 2：\n输入：nums &#x3D; [4,5,6,7,0,1,2]输出：0解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。\n示例 3：\n输入：nums &#x3D; [11,13,15,17]输出：11解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。\n提示：\nn &#x3D;&#x3D; nums.length1 &lt;&#x3D; n &lt;&#x3D; 5000-5000 &lt;&#x3D; nums[i] &lt;&#x3D; 5000nums 中的所有整数 互不相同nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转\n题解/** * 3,4,5,1,2 *     5 *   4 * 3 *         2 *       1 * 取任意中间数，如果中间数小于右边，可知中间数位于曲线右侧 * 如果中间数大于右边，可知中间数位于曲线左侧，左侧的数都不是需要的最小值，将中间数+1 * 当左边low大于右侧high时，即low，high处于5的位置，low+1即为要得到的最小值 * @param nums * @return */public int findMin(int[] nums) &#123;    int left = 0;    int right = nums.length - 1;    while (left &lt; right) &#123;        int pivot = left + (right - left) / 2;        if (nums[pivot] &lt; nums[right]) &#123;            right = pivot;        &#125; else &#123;            //曲线左侧的数都需要舍弃            left = pivot + 1;        &#125;    &#125;    return nums[left];&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","二分法"]},{"title":"278. 第一个错误的版本","url":"/java4u/2021/08/26/278.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/","content":"278. 第一个错误的版本你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n示例 1：\n输入：n &#x3D; 5, bad &#x3D; 4输出：4解释：调用 isBadVersion(3) -&gt; false调用 isBadVersion(5) -&gt; true调用 isBadVersion(4) -&gt; true所以，4 是第一个错误的版本。\n示例 2：\n输入：n &#x3D; 1, bad &#x3D; 1输出：1\n提示：\n1 &lt;&#x3D; bad &lt;&#x3D; n &lt;&#x3D; 2^31 - 1\n题解\n如果中间的mid如果是错误版本，那我们就知道 mid 右侧都不可能是第一个错误的版本。那我们就令 right &#x3D; mid，如果mid是正确版本则mid及mid左边都不可能是错误版本，我们令left&#x3D;mid+1，把下一次搜索空间变成[left, mid]，然后自然我们很顺利查找到目标。\n\npublic int firstBadVersion(int n) &#123;    int left = 1;    int right = n;    while (left &lt; right) &#123;        int mid = left + (right - left) / 2;        if (isBadVersion(mid)) &#123;            right = mid;        &#125; else &#123;            left = mid + 1;        &#125;    &#125;    return left;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","二分法"]},{"title":"69. x 的平方根","url":"/java4u/2021/08/25/69.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/","content":"69. x 的平方根给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\n输入：x &#x3D; 4输出：2\n示例 2：\n输入：x &#x3D; 8输出：2解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。\n提示：\n0 &lt;&#x3D; x &lt;&#x3D; 2^31 - 1\n题解public int mySqrt(int x) &#123;    if(x == 0) return 0;    //将边界设为long 防止超出界限    long left = 1;    long right = x;    long res = 0;    while (left &lt;= right) &#123;        long mid = left + (right - left)/2;        if(mid*mid &lt; x) &#123;            res = Math.max(res, mid);            left = mid+1;        &#125; else if(mid*mid == x)&#123;            return (int)mid;        &#125; else &#123;            right = mid-1;        &#125;    &#125;    return (int)res;&#125;public int mySqrt2(int x) &#123;    if (x == 0) return 0;    long left = 1;    long right = x / 2;    while (left &lt; right) &#123;        //注意这一行代码        //2.828*2.828=8  取整加1  mid取3        long mid = (right + left) / 2 + 1;        if (mid &gt; x / mid) &#123;            //结果大于 即3这个值不考虑，也需要舍弃            right = mid - 1;        &#125; else &#123;            left = mid;        &#125;    &#125;    return (int) left;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","二分法"]},{"title":"875. 爱吃香蕉的珂珂","url":"/java4u/2021/08/24/875.%20%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/","content":"875. 爱吃香蕉的珂珂珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。\n珂珂可以决定她吃香蕉的速度 k （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  \n珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。\n示例 1：\n输入：piles &#x3D; [3,6,7,11], h &#x3D; 8输出：4\n示例 2：\n输入：piles &#x3D; [30,11,23,4,20], h &#x3D; 5输出：30\n示例 3：\n输入：piles &#x3D; [30,11,23,4,20], h &#x3D; 6输出：23\n提示：\n1 &lt;&#x3D; piles.length &lt;&#x3D; 10^4piles.length &lt;&#x3D; h &lt;&#x3D; 10^91 &lt;&#x3D; piles[i] &lt;&#x3D; 10^9\n题解/** * 大部分的二分查找，基本都由以下三步组成： * 预处理过程（大部分场景就是对未排序的集合进行排序） * 二分查找过程（找到合适的循环条件，每一次将查找空间一分为二） * 后处理过程（在剩余的空间中，找到合适的目标值） * * 初始条件：left = 0, right = length-1 * 终止：left &gt; right * 向左查找：right = mid-1 * 向右查找：left = mid +1 */public int binarySearch(int[] array, int des) &#123;    int low = 0, high = array.length - 1;    while (low &lt;= high) &#123;        int mid = low + (high - low) / 2;        if (des == array[mid]) &#123;            return mid;        &#125; else if (des &lt; array[mid]) &#123;            high = mid - 1;        &#125; else &#123;            low = mid + 1;        &#125;    &#125;    return -1;&#125;public int minEatingSpeed(int[] piles, int h) &#123;    if(piles.length == 0)return 0;    //排序数组    Arrays.sort(piles);    //获取左右边界    int left = 1;    int right = piles[piles.length-1];    int min = Integer.MAX_VALUE;    while (left &lt;= right) &#123;        int mid = left + (right - left) / 2;        if (eatHours(piles, mid) &lt;= h)&#123;            min = Math.min(min, mid);            right = mid - 1;        &#125; else &#123;            left = mid + 1;        &#125;    &#125;    return min;&#125;private int eatHours(int[] piles, int speed)&#123;    int h = 0;    for (int pile : piles) &#123;        //向上取整        h += Math.ceil(pile * 1.0 / speed);    &#125;    return h;&#125;/** * 遍历香蕉堆直接获取最大值，就是最大吃香蕉的速度（超过还是1小时吃一堆），可以不需要排序香蕉堆 * @param piles * @param H * @return */public int minEatingSpeed2(int[] piles, int H) &#123;    int maxVal = 1;    for (int pile : piles) &#123;        maxVal = Math.max(maxVal, pile);    &#125;    int left = 1;    int right = maxVal;    while (left &lt; right) &#123;        int mid = (left + right) &gt;&gt; 1;        if (canEat(piles, mid, H)) &#123;            //不能吃完，包含Mid和左边的都舍弃            left = mid + 1;        &#125; else &#123;            right = mid;        &#125;    &#125;    //不满足的左边界都被舍弃，left就是满足的条件    return left;&#125;/** * * @param piles * @param speed * @param H * @return  true  不能吃完    false 能吃完 */private boolean canEat(int[] piles, int speed, int H) &#123;    int sum = 0;    for (int pile : piles) &#123;        //向上取整        sum += Math.ceil(pile * 1.0 / speed);    &#125;    return sum &gt; H;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","二分法"]},{"title":"设计模式","url":"/java4u/2021/08/20/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"1.工厂方法模式public class SendFactory &#123;    public Sender produceMail()&#123;return new MailSender();&#125;        public Sender produceSms()&#123;return new SmsSender();&#125;&#125;\n\n静态⼯⼚⽅法模式：将上⾯的多个⼯⼚⽅法置为静态的，不需要创建⼯⼚实例，直接调⽤即可；\n适⽤场景：凡是出现了⼤量不同种类的产品需要创建，并且具有共同的接⼝时，可以通过⼯⼚⽅法模式进⾏创建。⼤多数情况下，我们会选⽤——静态⼯⼚⽅法模式。\n2.抽象工厂模式创建多个⼯⼚类，（生产一个系列商品）提⾼⼯⼚的扩展性，不⽤像上⾯⼀样如果增加产品则要去修改唯⼀的⼯⼚类；\n3.单例模式保证在⼀个JVM中，该对象只有⼀个实例存在；\npublic class Singleton &#123;    /* 持有私有静态实例，防⽌被引⽤，此处赋值为null，⽬的是实现延迟加载 */    private state Singleton instance = null;    /* 私有构造⽅法，防⽌被实例化 */    private Singleton()&#123;&#125;    /* 静态⼯程⽅法，创建实例 */    public static Singleton getInstance()&#123;        if(instance == null)&#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;\n\n1、饿汉式：类初始化时创建单例，线程安全，适⽤于单例占内存⼩的场景，否则推荐使⽤懒汉式延迟加载；\npublic class Singleton &#123;    private static Singleton instance = new Singleton();    private Singleton()&#123;&#125;    public static Singleton getInstance()&#123;return instance;&#125;&#125;\n\n2、懒汉式：需要创建单例实例的时候再创建，需要考虑线程安全(性能不太好)：\npublic class Singleton&#123;    private static Singleton instance = null;    private Singleton()&#123;&#125;    public static synchronized Singleton getInstance()&#123;        if(null == instance)&#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;\n\n3、双重检验锁：效率⾼；(解决问题：假如两个线程A、B，A执⾏了if (instance &#x3D;&#x3D; null)语句，它会认为单例对象没有创建，此时线程切到B也执⾏了同样的语句，B也认为单例对象没有创建，然后两个线程依次执⾏同步代码块，并分别创建了⼀个单例对象。)\npublic class Singleton &#123;    private static volatile Singleton instance = null;//volatile的⼀个语义是禁⽌指令重排序优化    private Singleton()&#123;&#125;    public static Singleton getInstance() &#123;        if(instance == null)&#123;            synchronized(Singleton.class)&#123;                if(instance == null)&#123;                    instance = new Singleton();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;\n\n4、静态内部类⽅式：可以同时保证延迟加载和线程安全。\npublic class Singleton &#123;    private static class SingletonHolder&#123;        public static Singleton instance = new Singleton();    &#125;    private Singleton()&#123;&#125;    public static Singleton getInstance()&#123;        return SingletonHolder.instance;    &#125;&#125;\n\n5、枚举：使⽤枚举除了线程安全和防⽌反射调⽤构造器之外，还提供了⾃动序列化机制，防⽌反序列化的时候创建新的对象。\npublic enum Singleton&#123;    instance;    public void mothod()&#123;&#125;&#125;\n\n4.原型模式(对⼀个原型对象进⾏复制、克隆产⽣类似新对象)：将⼀个对象作为原型，对其进⾏复制、克隆，产⽣⼀个和元对象类似的新对象；\n 1、核⼼：它的核⼼是原型类Prototype，需要实现Cloneable接⼝，和重写Object类中的clone⽅法；\n 2、作⽤：使⽤原型模式创建对象⽐直接new⼀个对象在性能上要好的多，因为Object类的clone⽅法是⼀个本地⽅法，它直接操作内存中的⼆进制流，特别是复制⼤对象时，性能的差别⾮常明显。\n5.适配器模式将某个类的接⼝转换成客户端期望的另⼀个接⼝表示，⽬的是消除由于接⼝不匹配所造成的类的兼容性问题\n1、类的适配器模式：\nSource拥有一个方法，目标接口Targetable,通过Adapter类，将Source功能扩展到Targetable\npublic class Source&#123;    public void method1()&#123;        System.out.println(&quot;this is original method!&quot;);    &#125;&#125;public interface Targetable &#123;    //与原类中方法相同    public void method1();    //新类的方法    public void method2();&#125;public class Adapter extends Source implements Targetable &#123;    @Override    public void method2()&#123;        System.out.println(&quot;this is the targetable method!&quot;);    &#125;&#125;\n\n2、对象的适配器模式：\npublic class Wrapper implements Targetable &#123;    private Source source;        public Wrapper(Source source)&#123;        super();        this.source = source;    &#125;        @Override    public void method2()&#123;        System.out.println(&quot;this is the targetable method!&quot;);    &#125;&#125;\n\n3、接⼝的适配器模式：\npublic interface Sourceable &#123;    public void method1();    public void method2();    public void method3();&#125;public abstract class Wrapper2 implements Sourceable &#123;    public void method1()&#123;&#125;    public void method2()&#123;&#125;    public void method3()&#123;&#125;&#125;public class SourceSub1 extends Wrapper2 &#123;    public void method1()&#123;        System.out.println(&quot;the sourceable interface&#x27;s first Sub1!&quot;)    &#125;&#125;public class SourceSub2 extends Wrapper2 &#123;    public void method2()&#123;        System.out.println(&quot;the sourceable interface&#x27;s second Sub2!&quot;)    &#125;&#125;\n\n 4、使⽤场景：\n 1、类的适配器模式：当希望将⼀个类转换成满⾜另⼀个新接⼝的类时，可以使⽤类的适配器模式，创建⼀个新类，继承原有的类，实现新的接⼝即可。\n 2、对象的适配器模式：当希望将⼀个对象转换成满⾜另⼀个新接⼝的对象时，可以创建⼀个Wrapper类，持有原类的⼀个实例，在Wrapper类的⽅法中，调⽤实例的⽅法就⾏。\n 3、接⼝的适配器模式：当不希望实现⼀个接⼝中所有的⽅法时，可以创建⼀个抽象类Wrapper，实现所有⽅法，我们写别的类的时候，继承抽象类即可。 \n","categories":["面试"],"tags":["学习"]},{"title":"268. 丢失的数字","url":"/java4u/2021/08/20/268.%20%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","content":"268. 丢失的数字给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n示例 1：\n输入：nums &#x3D; [3,0,1]输出：2解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n示例 2：\n输入：nums &#x3D; [0,1]输出：2解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n示例 3：\n输入：nums &#x3D; [9,6,4,2,3,5,7,0,1]输出：8解释：n &#x3D; 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。\n示例 4：\n输入：nums &#x3D; [0]输出：1解释：n &#x3D; 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。\n提示：\nn &#x3D;&#x3D; nums.length1 &lt;&#x3D; n &lt;&#x3D; 10^40 &lt;&#x3D; nums[i] &lt;&#x3D; nnums 中的所有数字都 独一无二\n进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?\n题解/** * 0~n的合计为 (1+n)*n/2 * 合计值减去数组的值，结果即为丢失的值 * @param nums * @return */public int missingNumber(int[] nums) &#123;    int n = nums.length;    int sum = (n + 1) * n / 2;    for(int i : nums)&#123;        sum -= i;    &#125;    return sum;&#125;/** * 2个相同的数可以使用异或消除 * [3,0,1] * 0^3^1^0^2^1 * 0^0 1^1 res^2 3^nums.length * * @param nums * @return */public int missingNumber2(int[] nums) &#123;    int res = 0;    for(int i = 0; i &lt; nums.length; i++ )        res ^= nums[i] ^ i;    return res ^ nums.length;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","位运算"]},{"title":"137. 只出现一次的数字 II","url":"/java4u/2021/08/19/137.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%20II/","content":"137. 只出现一次的数字 II给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。\n示例 1：\n输入：nums &#x3D; [2,2,3,2]输出：3示例 2：\n输入：nums &#x3D; [0,1,0,1,0,1,99]输出：99\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 10^4-2^31 &lt;&#x3D; nums[i] &lt;&#x3D; 2^31 - 1nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次\n进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n题解/** * 观察[a,a,a,b,b,b,c,c,c]与[a,a,a,b,b,b,c]之间相差2个c * 可以将数组的数字去重，再乘以3，在减去之前的数组，得到的值就是2倍的目标值 * @param nums * @return */public int singleNumber(int[] nums) &#123;    long sum = Arrays.stream(nums).distinct().mapToLong(num -&gt; (long) num).sum() * 3;    long sum1 = Arrays.stream(nums).mapToLong(num -&gt; (long) num).sum();    return (int)((sum-sum1)/2);&#125;/** * 将数组排序，之后遍历 * 当nums[n]==nums[n+1]，可以跳过后3个 * @param nums * @return */public int singleNumber2(int[] nums) &#123;    Arrays.sort(nums);    int n = nums.length;    for (int i = 0; i &lt; n; i+=3) &#123;        if(i == n-1 || nums[i] != nums[i+1])&#123;            return nums[i];        &#125;    &#125;    return 0;&#125;/** * 由于数组中的元素都在 int（即 32 位整数）范围内，因此我们可以依次计算答案的每一个二进制位是 0 还是 1。 * 具体地，考虑答案的第 i 个二进制位（i 从 0 开始编号），它可能为 0 或 1。对于数组中非答案的元素， * 每一个元素都出现了 3 次，对应着第 i 个二进制位的 3 个 0 或 3 个 1，无论是哪一种情况， * 它们的和都是 3 的倍数（即和为 0 或 3）。因此： * 答案的第 i 个二进制位就是数组中所有元素的第 i 个二进制位之和除以 3 的余数。 * 这样一来，对于数组中的每一个元素 x，我们使用位运算 (x &gt;&gt; i) &amp; 1 得到 x 的第 i 个二进制位， * 并将它们相加再对 3 取余，得到的结果一定为 0 或 1，即为答案的第 i 个二进制位。 * @param nums * @return */public int singleNumber3(int[] nums) &#123;    int ans = 0;    for (int i = 0; i &lt; 32; ++i) &#123;        int total = 0;        for (int num: nums) &#123;            //从最后一位不断向前取末位的值            total += ((num &gt;&gt; i) &amp; 1);        &#125;        if (total % 3 != 0) &#123;            //将模3的值加到结果上            ans |= (1 &lt;&lt; i);        &#125;    &#125;    return ans;&#125;/** * 我们可以使用一个「黑盒」存储当前遍历过的所有整数。「黑盒」的第 i 位为 &#123;0,1,2&#125; 三者之一，表示当前遍历过的所有整数的第 i 位之和除以 3 的余数。 * 但由于二进制表示中只有 0 和 1 而没有 2，因此我们可以考虑在「黑盒」中使用两个整数来进行存储，即： * 黑盒中存储了两个整数 a 和 b，且会有三种情况： * a 的第 i 位为 0 且 bb 的第 i 位为 0，表示 0； * a 的第 i 位为 0 且 b 的第 i 位为 1，表示 1； * a 的第 i 位为 1 且 b 的第 i 位为 0，表示 2。 * 为了方便叙述，我们用 (00) 表示 a 的第 i 位为 0 且 b 的第 i 位为 0，其余的情况类似。 * 当我们遍历到一个新的整数 x 时，对于 x 的第 i 位 ix，如果 ix=0，那么 a 和 b 的第 i 位不变； * 如果 ix=1，那么 a 和 b 的第 i 位按照 (00)→(01)→(10)→(00) 这一循环进行变化 * * TODO抄的答案，木有理解 * * @param nums * @return */public int singleNumber4(int[] nums) &#123;    int a = 0, b = 0, tmp = 0;    for (int next : nums) &#123;        tmp = (a &amp; ~next) | (b &amp; next);        b = (~a &amp; ~b &amp; next) | (b &amp; ~next);        a = tmp;    &#125;    return b;&#125;public int singleNumber5(int[] nums) &#123;    int a = 0, b = 0;    for (int next : nums) &#123;        b = (b ^ next) &amp; ~a;        a = (a ^ next) &amp; ~b;    &#125;    return b;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","位运算"]},{"title":"136. 只出现一次的数字","url":"/java4u/2021/08/18/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","content":"136. 只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n说明：\n你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n示例 1:\n输入: [2,2,1]输出: 1\n示例 2:\n输入: [4,1,2,1,2]输出: 4\n题解/** * 异域中同位如果值相同（都是0或者都是1）则为0，不同（一个是0，一个是1）为1 * 5    0 0 0 1 0 1 * 3    0 0 0 0 1 1 * 5^3  0 0 0 1 1 0 * * 已知任何数a与0异或得到该数   a^0=a *     任何数a与a异或得0      a^a=0 * 异或操作满足交换律和结合律    a^b^a=(a^a)^b=0^b=b * 通过交换律将出现一次的整数移到数组末尾， * 不断进行异或操作，将一直得到0，最后得到的值就是唯一出现一次的值 * @param nums * @return */public int singleNumber(int[] nums) &#123;    int res = 0;    for(int num : nums)&#123;        res ^=num;    &#125;    return res;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","位运算"]},{"title":"191. 位1的个数","url":"/java4u/2021/08/17/191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/","content":"191. 位1的个数编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。\n提示：\n请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。\n示例 1：\n输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。\n示例 2：\n输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。\n示例 3：\n输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。\n提示：\n输入必须是长度为 32 的 二进制串 。\n进阶：\n如果多次调用这个函数，你将如何优化你的算法？\n题解/** * 我们只需要让这个掩码每次向左移动一位，然后与目标值求“&amp;”，就可以判断目标值的当前位是不是1 * 比如21的二进制    00010101   移到掩码和当前位进行计算 *     00010101 *     00000001 * *     00010101 *     00000010 * *     00010101 *     00000100 * 这里判断 n&amp;mask 的时候，千万不要错写成 (n&amp;mask) == 1，因为这里你对比的是十进制数 * @param n * @return */public int hammingWeight(int n) &#123;    int result = 0;    //初始化掩码为1    int mask = 1;    for (int i = 0; i &lt; 32; i++) &#123;        //对比的是十进制数,不为0就表示当前位为1        if ((n &amp; mask) != 0) &#123;            result++;        &#125;        mask = mask &lt;&lt; 1;    &#125;    return result;&#125;/** * 对于任意一个数，将 n 和 n-1 进行 &amp; 运算，我们都可以把 n 中最低位的 1 变成 0 * 31     0011111 * 30     0011110 * 31&amp;30  0011110 * * 28     0011100 * 27     0011011 * 28&amp;27  0011000 * 不断进行操作即可 */public int hammingWeight2(int n) &#123;    int res = 0;    //考虑负数补码的问题    while (n != 0)&#123;        n = n &amp; (n-1);        res++;    &#125;    return res;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","位运算"]},{"title":"JVM","url":"/java4u/2021/08/16/2.jvm/","content":"1、jvm调优：\\1. 调优时机：\na. heap 内存（⽼年代）持续上涨达到设置的最⼤内存值；\nb. Full GC 次数频繁；\nc. GC 停顿时间过⻓（超过1秒）；\nd. 应⽤出现OutOfMemory 等内存异常；\ne. 应⽤中有使⽤本地缓存且占⽤⼤量内存空间；\nf. 系统吞吐量与响应性能不⾼或下降。\n\\2. 调优原则：\na. 多数的Java应⽤不需要在服务器上进⾏JVM优化；\nb. 多数导致GC问题的Java应⽤，都不是因为我们参数设置错误，⽽是代码问题；\nc. 在应⽤上线之前，先考虑将机器的JVM参数设置到最优（最适合）；\nd. 减少创建对象的数量；\ne. 减少使⽤全局变量和⼤对象；\nf. JVM优化是到最后不得已才采⽤的⼿段；\ng. 在实际使⽤中，分析GC情况优化代码⽐优化JVM参数更好；\n\\3. 调优⽬标：\na. GC低停顿；\nb. GC低频率；\nc. 低内存占⽤；\nd. ⾼吞吐量；\n\\4. 调优步骤：\na. 分析GC⽇志及dump⽂件，判断是否需要优化，确定瓶颈问题点；\nb. 确定jvm调优量化⽬标；\nc. 确定jvm调优参数（根据历史jvm参数来调整）；\nd. 调优⼀台服务器，对⽐观察调优前后的差异；\ne. 不断的分析和调整，知道找到合适的jvm参数配置；\nf. 找到最合适的参数，将这些参数应⽤到所有服务器，并进⾏后续跟踪。\n2、jvm调优参数：\\1. 设定堆内存⼤⼩，这是最基本的。\n\\2. -Xms：启动JVM时的堆内存空间。\n\\3. -Xmx：堆内存最⼤限制。\n\\4. 设定新⽣代⼤⼩。\n\\5. 新⽣代不宜太⼩，否则会有⼤量对象涌⼊⽼年代。\n\\6. -XX:NewRatio：新⽣代和⽼年代的占⽐。\n\\7. -XX:NewSize：新⽣代空间。\n\\8. -XX:SurvivorRatio：伊甸园空间和幸存者空间的占⽐。\n\\9. -XX:MaxTenuringThreshold：对象进⼊⽼年代的年龄阈值。\n\\10. 设定垃圾回收器\n年轻代：-XX:+UseParNewGC。\n⽼年代：-XX:+UseConcMarkSweepGC。\nCMS可以将STW时间降到最低，但是不对内存进⾏压缩，有可能出现“并⾏模式失败”。⽐如⽼年代空间还有300MB空间，但是⼀些10MB的对象⽆法被顺序的存储。这时候会触发压缩处理，但是CMS GC模式下的压缩处理时间要⽐Parallel GC⻓很多。G1采⽤”标记-整理“算法，解决了内存碎⽚问题，建⽴了可预测的停顿时间类型，能让使⽤者指定在⼀个⻓度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。\n3、触发full gc的场景及应对策略：\\1. System.gc()⽅法的调⽤，应对策略：通过-XX:+DisableExplicitGC来禁⽌调⽤System.gc ;\n\\2. ⽼年代代空间不⾜，应对策略：让对象在Minor GC阶段被回收，让对象在新⽣代多存活⼀段时间，不要创建过⼤的对象及数组;\n\\3. 永⽣区空间不⾜，应对策略：增⼤PermGen空间；\n\\4. GC时出现promotionfailed和concurrent mode failure，应对策略：增⼤survivor space；\n\\5. Minor GC后晋升到旧⽣代的对象⼤⼩⼤于⽼年代的剩余空间，应对策略：增⼤Tenured space 或下调CMSInitiatingOccupancyFraction&#x3D;60；\n\\6. 内存持续增涨达到上限导致Full GC，应对策略：通过dumpheap 分析是否存在内存泄漏。\n4、如何查看jvm内存使⽤情况：可以使⽤JDK⾃带的JConsole、JVisualVM、JMap、JHat等⼯具，或者使⽤第三⽅⼯具，⽐如 Eclipse Memory Analyzer\n5、jvm中哪些地⽅会出现oom？分别说说oom的可能原因？1. java堆溢出（heap）：a. Java堆内存主要⽤来存放运⾏过程中所以的对象，该区域OOM异常⼀般会有如下错误信息：\njava.lang.OutofMemoryError:Java heap space\nb. 此类错误⼀般通过Eclipse Memory Analyzer分析OOM时dump的内存快照就能分析出来，到底是由于程序原因导致的内存泄露，还是由于没有估计好JVM内存的⼤⼩⽽导致的内存溢出。\nc. 另外，Java堆常⽤的JVM参数：\n1 -Xms：初始堆⼤⼩，默认值为物理内存的1&#x2F;64(&lt;1GB)，默认(MinHeapFreeRatio参数可以调整)空余堆内存⼩于40%时，JVM就会增⼤堆直到\n2 -Xmx：最⼤堆⼤⼩，默认值为物理内存的1&#x2F;4(&lt;1GB)，默认(MaxHeapFreeRatio参数可以调整)空余堆内存⼤于70%时，JVM会减少堆直到\n3 -Xmn：年轻代⼤⼩(1.4or lator)，此处的⼤⼩是（eden + 2 survivor space)，与jmap -heap中显示的New gen是不同的。\n2. 栈溢出（stack）：a. 栈⽤来存储线程的局部变量表、操作数栈、动态链接、⽅法出⼝等信息。如果请求栈的深度不⾜时抛出的错误会包含类似下⾯的信息：\n1 java.lang.StackOverflowError。\nb. 另外，由于每个线程占的内存⼤概为1M，因此线程的创建也需要内存空间。操作系统可⽤内存-Xmx-MaxPermSize即是栈可⽤的内存，如果申请创建的线程⽐较多超过剩余内存的时候，也会抛出如下类似错误：java.lang.OutofMemoryError: unable to create new native thread\nc. 相关的JVM参数有：\n1 -Xss: 每个线程的堆栈⼤⼩,JDK5.0以后每个线程堆栈⼤⼩为1M,以前每个线程堆栈⼤⼩为256K. \n2 在相同物理内存下,减⼩这个值能⽣成更多的线程.但是操作系统对⼀个进程内的线程数还是有限制的,不能⽆限⽣成,经验值在3000~5000\nd. 可能原因：\ni. 递归：递归⾥⽤到的局部变量存储在堆栈中，堆栈的访问效率⾼，速度快，但空间有限，递归太多变量需要⼀直⼊栈⽽不出栈，导致需要的内存空间⼤于堆栈的空间，栈空间是2M，堆空间内存空间。\n3. 运⾏时常量溢出（constant）：a. 运⾏时常量保存在⽅法区，存放的主要是编译器⽣成的各种字⾯量和符号引⽤，但是运⾏期间也可能将新的常量放⼊池中，⽐如String类的intern⽅法。如果该区域OOM，错误结果会包含类似下⾯的信息：\n1 java.lang.OutofMemoryError: PermGen space\nb. 相关的JVM参数有：\n1 -XX:PermSize：设置持久代(perm gen)初始值，默认值为物理内存的1&#x2F;64\n2 -XX:MaxPermSize：设置持久代最⼤值，默认为物理内存的1&#x2F;4\n4. ⽅法区溢出：a. ⽅法区主要存储被虚拟机加载的类信息，如类名、访问修饰符、常量池、字段描述、⽅法描述等。理论上在JVM启动后该区域⼤⼩应该⽐较稳定，但是⽬前很多框架，⽐如Spring和Hibernate等在运⾏过程中都会动态⽣成类，因此也存在OOM的⻛险。如果该区域OOM，错误结果会包含类似下⾯的信息：1 java.lang.OutofMemoryError: PermGen space\nb. 相关的JVM参数有：\n1 -XX:PermSize：设置持久代(perm gen)初始值，默认值为物理内存的1&#x2F;64\n2 -XX:MaxPermSize：设置持久代最⼤值，默认为物理内存的1&#x2F;4\n6、synchronized和ReentrantLock的实现机制？synchronized⽤的锁是存在Java对象头⾥的\n一。synchronized属于独占式悲观锁通过JVM隐式实现，只允许同一时刻只有一个线程操作资源。\nJava中每个对象都隐式包含一个monitor（监视器）对象加锁的过程其实就是竞争monitor的过程，当线程进入字节码monitiorenter指令后线程将持有monitor对象，执行monitorexit时释放monitor对象当其他线程没有拿到monitor对象时，则需要阻塞等待获取该对象。\n二。ReentrantLock是Lock的默认实现方式之一\n是基于AQS(Abstrack Queued Synchronizer,队列同步器) 实现的默认是通过非公平锁实现的，它的内部有一个state的状态字段用于表示锁是否被占用，如果0则表示锁未被占用，此时线程就可以吧state改为1，并成功获得锁而其他未获得锁的线程只能去排队等待获取资源\n锁升级：锁升级就是从偏向锁到轻量级锁再到重量级锁升级的过程 ，这是JDK1.6提供的优化功能，也称之为锁膨胀。偏向锁：指在无竞争的情况下设置的一种锁状态，意思是他会偏向于第一个获取它的线程，当锁对象第一次被获取到之后，会在此对象头中设置标示为“01”,标示偏向锁模式，并且在对象头中记录此线程的ID偏向锁可以提高带有同步，但无竞争的程序性能，但如果在多数锁总会被不同的线程访问时，偏向锁模式就比较多余了\n在jdk1.6之前，synchronized是通过操作系统的互斥量（mutex lock）来实现的，这种实现方式需要再用户态和核心态之间做转换，有很大的性能消耗，这种传统实现锁的方式被称之为重量锁。轻量锁是通过比较并交换（CAS，Compare and Swap） 来实现的 它对比的是线程和对象的MarkWord(对象头中的一个区域)，如果更新成功则表示当前线程成功拥有此锁，如果失败，虚拟机会先检查对象的MarkWord是否指向当前线程栈帧。如果是，则说明当前线程已经拥有此锁，否则，则说明此锁已经被其他线程占用。\n","categories":["面试"],"tags":["学习"]},{"title":"231. 2 的幂","url":"/java4u/2021/08/16/231.%202%20%E7%9A%84%E5%B9%82/","content":"231. 2 的幂给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。\n如果存在一个整数 x 使得 n &#x3D;&#x3D; 2^x ，则认为 n 是 2 的幂次方。\n示例 1：\n输入：n &#x3D; 1输出：true解释：2^0 &#x3D; 1\n示例 2：\n输入：n &#x3D; 16输出：true解释：2^4 &#x3D; 16\n示例 3：\n输入：n &#x3D; 3输出：false示例 4：\n输入：n &#x3D; 4输出：true\n示例 5：\n输入：n &#x3D; 5输出：false\n提示：\n-2^31 &lt;&#x3D; n &lt;&#x3D; 2^31 - 1\n进阶：你能够不使用循环&#x2F;递归解决此问题吗？\n题解/** * 观察2的幂次数，除了最高位都是0 * 1        1 * 2       10 * 4      100 * 8     1000 * 16   10000 * * 对应幂次数减去1的数 * 0        0 * 1        1 * 3       11 * 7      111 * 15    1111 * * 2组数求位运算 *       1 &amp; 0 = 0 *      10 &amp; 01 = 00 *     100 &amp; 011 = 000 *    1000 &amp; 0111 = 0000 *   10000 &amp; 01111 = 00000 * * 对于N为2的幂的数，都有 N&amp;(N-1)==0 * @param n * @return */public boolean isPowerOfTwo(int n) &#123;    if(n &lt; 1)return false;    return (n&amp;(n-1))==0;&#125;","categories":["数据结构与算法"],"tags":["leetcode","位运算"]},{"title":"连续n个数的和","url":"/java4u/2021/08/16/%E8%BF%9E%E7%BB%ADn%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C/","content":"连续n个数的和求 1 2 … n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n示例 1：\n输入: n &#x3D; 3 输出: 6\n示例 2：\n输入: n &#x3D; 9 输出: 45\n限制：\n1 &lt;&#x3D; n &lt;&#x3D; 10000\n题解/** * 连续加合可以使用递归 * &amp;&amp;的特性,A&amp;&amp;B * 如果A为true，返回B的布尔值（继续往下执行） * 如果A为false，直接返回false（相当于短路） * @param n * @return */public int sumNums(int n) &#123;    System.out.println(&quot;start:&quot;+n);    boolean b = n &gt; 0 &amp;&amp; ((n  += sumNums(n - 1)) &gt; 0);    System.out.println(&quot;end:&quot;+n);    return n;&#125;/** * n(n+1)/2 * @param n * @return */public int sumNums2(int n) &#123;    return ((int)(Math.pow(n, 2)+n)&gt;&gt;1);&#125;","categories":["数据结构与算法"],"tags":["leetcode","位运算"]},{"title":"剑指 Offer 57 - II. 和为s的连续正数序列","url":"/java4u/2021/08/12/%E5%89%91%E6%8C%87%20Offer%2057%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/","content":"剑指 Offer 57 - II. 和为s的连续正数序列输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。\n序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。\n示例 1：\n输入：target &#x3D; 9输出：[[2,3,4],[4,5]]\n示例 2：\n输入：target &#x3D; 15输出：[[1,2,3,4,5],[4,5,6],[7,8]]\n限制：\n1 &lt;&#x3D; target &lt;&#x3D; 10^5\n题解/** * 维持一个滑动的窗口，小于目标值就右移右指针，大于目标值就右移左指针 * 找到目标值，就记录从左到右的值，之后左移左指针，循环操作 * 对于任意一个正整数，总是小于它的中值与中值+1的和，当左指针大于目标值一半时，停止操作 * @param target * @return */public int[][] findContinuousSequence(int target) &#123;    int l = 1;    int r = 1;    //窗口合计值    int win = 0;    List&lt;int[]&gt; list = new ArrayList&lt;&gt;();    while (l &lt;= target/2)&#123;        if(win &lt; target)&#123;            win += r;            r++;        &#125; else if(win &gt; target)&#123;            win -= l;            l++;        &#125; else &#123;            int[] arr = new int[r-l];            for (int i = l; i &lt; r; i++) &#123;                arr[i-l] = i;            &#125;            list.add(arr);            win -= l;            l++;        &#125;    &#125;    return list.toArray(new int[list.size()][]);&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","滑动窗口"]},{"title":"438. 找到字符串中所有字母异位词","url":"/java4u/2021/08/10/438.%20%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","content":"438. 找到字符串中所有字母异位词给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。\n示例 1:\n输入: s &#x3D; “cbaebabacd”, p &#x3D; “abc”输出: [0,6]解释:起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。\n 示例 2:\n输入: s &#x3D; “abab”, p &#x3D; “ab”输出: [0,1,2]解释:起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。\n提示:\n1 &lt;&#x3D; s.length, p.length &lt;&#x3D; 3 * 10^4s 和 p 仅包含小写字母\n题解/** * 使用map存储经过的字符 * 比较2个map是否相等 * @param s * @param p * @return */public List&lt;Integer&gt; findAnagrams3(String s, String p) &#123;    List&lt;Integer&gt; res = new LinkedList&lt;&gt;();    int m = s.length(), n = p.length();    if (m &lt; n) return res;    Map&lt;Character, Integer&gt; s_map = new HashMap&lt;&gt;();    Map&lt;Character, Integer&gt; p_map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; n; i++) &#123;        s_map.put(s.charAt(i), s_map.getOrDefault(s.charAt(i), 0) + 1);        p_map.put(p.charAt(i), p_map.getOrDefault(p.charAt(i), 0) + 1);    &#125;    for (int i = -1; i &lt; m - n; i++) &#123;        if (i &gt;= 0) &#123;            s_map.put(s.charAt(i), s_map.get(s.charAt(i)) - 1);            s_map.put(s.charAt(i + n), s_map.getOrDefault(s.charAt(i + n), 0) + 1);        &#125;        boolean isAnagrams = true;        for (Map.Entry&lt;Character, Integer&gt; entry : p_map.entrySet()) &#123;            if(s_map.containsKey(entry.getKey()))&#123;                isAnagrams = s_map.get(entry.getKey()).equals(entry.getValue());            &#125;else&#123;                isAnagrams = false;            &#125;            if (!isAnagrams) break;        &#125;        if (isAnagrams) res.add(i + 1);    &#125;    return res;&#125;/** * 判断字母异位词，我们需要保证窗口中的字母出现次数与目标串中的字母出现次数一致。 * 这里因为字母只有26个，直接使用数组来替代map进行存储 * @param s * @param p * @return */public List&lt;Integer&gt; findAnagrams2(String s, String p) &#123;    if (s == null || p == null || s.length() &lt; p.length()) return new ArrayList&lt;&gt;();    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    int[] pArr = new int[26];    int[] sArr = new int[26];    for (int i = 0; i &lt; p.length(); i++) &#123;        sArr[s.charAt(i) - &#x27;a&#x27;]++;        pArr[p.charAt(i) - &#x27;a&#x27;]++;    &#125;    int i = 0;    int j = p.length();    // 窗口大小固定为p的长度    while (j &lt; s.length()) &#123;        if (isSame(pArr, sArr))            list.add(i);        //sArr[s.charAt(i) - &#x27;a&#x27;]-- 原左指针位置处字母减1，表示字母移出        sArr[s.charAt(i) - &#x27;a&#x27;]--;        i++;        //sArr[s.charAt(j) - &#x27;a&#x27;]++ 原右指针位置处字母加1，表示字母移入        sArr[s.charAt(j) - &#x27;a&#x27;]++;        j++;    &#125;    // j=s.length-1尾部的情况需要判断    if (isSame( pArr, sArr))        list.add(i);    return list;&#125;public boolean isSame(int[] arr1, int[] arr2) &#123;    for (int i = 0; i &lt; arr1.length; ++i)        if (arr1[i] != arr2[i])            return false;    return true;&#125;/** * 使用map储存字符的出现次数（会超时） * @param s * @param p * @return */public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;    List&lt;Integer&gt; ret = new ArrayList&lt;&gt;();    int len = s.length();    int k = p.length();    if(len &lt; k)return ret;    int l = 0;    int r = k -1;    while (r &lt; len)&#123;        //遍历左指针到右指针所有的字符        String str = s.substring(l,r+1);        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();        for(Character c : str.toCharArray())&#123;            map.merge(c, 1, Integer::sum);        &#125;        if(isSame(map, p))&#123;            ret.add(l);        &#125;        l++;        r++;    &#125;    return ret;&#125;private boolean isSame(Map&lt;Character, Integer&gt; map, String p)&#123;    for(Character c : p.toCharArray())&#123;        if(map.get(c) == null || map.get(c) == 0)&#123;            return false;        &#125;else&#123;            map.put(c, map.get(c)-1);        &#125;    &#125;    return true;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","滑动窗口"]},{"title":"239. 滑动窗口最大值","url":"/java4u/2021/08/06/239.%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/","content":"239. 滑动窗口最大值给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n示例 1：\n输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置                最大值\n---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7\n\n示例 2：\n输入：nums &#x3D; [1], k &#x3D; 1输出：[1]\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5-10^4 &lt;&#x3D; nums[i] &lt;&#x3D; 10^41 &lt;&#x3D; k &lt;&#x3D; nums.length\n题解只要遍历该数组，同时在双端队列的头去维护当前窗口的最大值（在遍历过程中，发现当前元素比队列中的元素大，就将原来队列中的元素祭天），在整个遍历的过程中我们再记录下每一个窗口的最大值到结果数组中。最终结果数组就是我们想要的，整体图解如下。\n假设 nums &#x3D; [1,3,-1,-3,5,3,6,7]，和 k &#x3D; 3\n\n/** * 遍历数组的同时，在双端队列的头部维护当前窗口的最大值，遍历的同时。发现当前元素比队列的元素大 * 就将原队列元素祭天 * 在双向队列中维护一个从大到小的排序（数组的下标，之后要通过下标判断队首是否在窗口内） * * 假设 nums = [1,3,-1,-3,5,3,6,7]，和 k = 3 * 数组                   双端队列        RESULT * 1 3,-1,-3,5,3,6,7        1 * 1 3 -1,-3,5,3,6,7        3 * 1,3 -1 -3,5,3,6,7        3,-1        3 * 1,3,-1 -3 5,3,6,7      3,-1,-1       3,3 * 1,3,-1,-3 5 3,6,7        5           3,3,5 * 1,3,-1,-3,5 3 6,7        5,3         3,3,5,5 * 1,3,-1,-3,5,3 6 7        6           3,3,5,5,6 * 1,3,-1,-3,5,3,6 7        7           3,3,5,5,6,7 * @param nums * @param k * @return */public int[] maxSlidingWindow(int[] nums, int k) &#123;    if(nums == null || nums.length &lt; 2) return nums;    // 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序    LinkedList&lt;Integer&gt; queue = new LinkedList();    // 结果数组    int[] result = new int[nums.length-k+1];    // 遍历nums数组    for(int i = 0;i &lt; nums.length;i++)&#123;        // 保证从大到小 如果前面数小则需要依次弹出，直至满足要求        while(!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i])&#123;            queue.pollLast();        &#125;        // 添加当前值对应的数组下标        queue.addLast(i);        // 判断当前队列中队首的值是否有效        if(queue.peek() &lt;= i-k)&#123;            queue.poll();        &#125;        // 当窗口长度为k时 保存当前窗口中最大值        if(i+1 &gt;= k)&#123;            result[i+1-k] = nums[queue.peek()];        &#125;    &#125;    return result;&#125;public int[] maxSlidingWindow2(int[] nums, int k) &#123;    int n = nums.length;    Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;();    for (int i = 0; i &lt; k; ++i) &#123;        while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;            deque.pollLast();        &#125;        deque.offerLast(i);    &#125;    int[] ans = new int[n - k + 1];    ans[0] = nums[deque.peekFirst()];    for (int i = k; i &lt; n; ++i) &#123;        while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;            deque.pollLast();        &#125;        deque.offerLast(i);        while (deque.peekFirst() &lt;= i - k) &#123;            deque.pollFirst();        &#125;        ans[i - k + 1] = nums[deque.peekFirst()];    &#125;    return ans;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","滑动窗口"]},{"title":"46. 全排列","url":"/java4u/2021/08/05/46.%20%E5%85%A8%E6%8E%92%E5%88%97/","content":"46. 全排列给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n示例 1：\n输入：nums &#x3D; [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n示例 2：\n输入：nums &#x3D; [0,1]输出：[[0,1],[1,0]]\n示例 3：\n输入：nums &#x3D; [1]输出：[[1]]\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 6-10 &lt;&#x3D; nums[i] &lt;&#x3D; 10nums 中的所有整数 互不相同\n题解List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();/** * 回溯就是状态枚举和状态复原 * 使用DFS实现回溯 * for 选择in 选择列表: *     # 做选择 *     将该选择从选择列表移除 *     路径.add(选择) *     backtrack(路径, 选择列表) *     # 撤销选择 *     路径.remove(选择) *     将该选择再加入选择列表 * @param nums * @return */public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;    dfs(nums, new ArrayList&lt;&gt;());    return ans;&#125;private void dfs(int[] nums, List&lt;Integer&gt; tmp) &#123;    System.out.println(Arrays.toString(nums) + &quot;,&quot; + tmp);    if (tmp.size() == nums.length) &#123;        ans.add(new ArrayList&lt;&gt;(tmp));    &#125; else &#123;        for (int num : nums) &#123;            //不能选择已经选择了的数字  排除不合法的选择            if (!tmp.contains(num)) &#123;                // 做选择                tmp.add(num);                // 进入下一层决策树                dfs(nums, tmp);                //回到上一位时，我们要就把上一次的选择结果撤销掉   取消选择                tmp.remove(tmp.size() - 1);            &#125;        &#125;    &#125;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","回溯"]},{"title":"814. 二叉树剪枝","url":"/java4u/2021/08/04/814.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/","content":"814. 二叉树剪枝给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。\n返回移除了所有不包含 1 的子树的原二叉树。\n节点 node 的子树为 node 本身加上所有 node 的后代。\n示例 1：\n输入：root &#x3D; [1,null,0,0,1]输出：[1,null,0,null,1]解释：只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。\n示例 2：\n输入：root &#x3D; [1,0,1,0,0,0,1]输出：[1,null,1,null,1]\n示例 3：\n输入：root &#x3D; [1,1,0,1,1,0,1,0]输出：[1,1,0,1,1,null,1]\n提示：\n树中节点的数目在范围 [1, 200] 内Node.val 为 0 或 1\n题解/** * 迭代节点，当节点左右子树为空且节点值为0，需要剪枝 * 前序遍历  根在前，从左往右 * 中序遍历  根在中，从左往右 * 后序遍历  根在后，从左往右 * @param root * @return */public TreeNode pruneTree(TreeNode root) &#123;    return deal(root);&#125;private TreeNode deal(TreeNode root) &#123;    if(root == null) return null;    //需要使用后序遍历，最后删除根节点    //提前删除根节点会导致无法获取到右节点    root.left = deal(root.left);    root.right = deal(root.right);    if(root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == 0)&#123;        root = null;    &#125;    return root;&#125;","categories":["数据结构与算法"],"tags":["leetcode","二叉树"]},{"title":"222. 完全二叉树的节点个数","url":"/java4u/2021/08/03/222.%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/","content":"222. 完全二叉树的节点个数给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。\n示例 1：\n输入：root &#x3D; [1,2,3,4,5,6]输出：6\n示例 2：\n输入：root &#x3D; []输出：0\n示例 3：\n输入：root &#x3D; [1]输出：1\n提示：\n树中节点的数目范围是[0, 5 * 10^4]0 &lt;&#x3D; Node.val &lt;&#x3D; 5 * 10^4题目数据保证输入的树是 完全二叉树\n进阶：遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？\n题解/** * 对于完全二叉树，前h-1层一定为满二叉树，前h-1层节点数为 2^h-1 * 则h层第一个节点编号为 2^h  对应的二进制表示第h位为1其余位都为0 * 2^1  2  10 * 2^2  4  100 * 2^3  8  1000 * 2^4 16  10000 * 2^h     100.....000 * 最底层节点数在2^h 2^(h+1)-1之间 * *     1            h = 0 *    / \\ *   2   3          h = 1 *  / \\  / * 4  5 6           h = 2 * 现在这个树中的值都是节点的编号，最底下的一层的编号是[2^h ，2^h - 1]，现在h = 2，也就是4, 5, 6, 7。 * 4, 5, 6, 7对应二进制分别为 100 101 110 111 不看最左边的1，从第二位开始，0表示向左，1表示向右， * 正好可以表示这个节点相对于根节点的位置。 * 比如4的 00 就表示从根节点 向左 再向左。6的 10 就表示从根节点 向右 再向左 * * 那么想访问最后一层的节点就可以从节点的编号的二进制入手。从第二位开始的二进制位表示了最后一层的节点相对于根节点的位置。 * 那么就需要一个bits = 2^(h - 1) 上面例子中的bits就是2，对应二进制为010。这样就可以从第二位开始判断。 * （树三层高，需要向左或向右走两次才能到叶子） * 比如看5这个节点存不存在，先通过位运算找到编号为5的节点相对于根节点的位置。010 &amp; 101 发现第二位是0， * 说明从根节点开始，第一步向左走。之后将bit右移一位，变成001。001 &amp; 101 发现第三位是1，那么第二步向右走。 * 最后bit为0，说明已经找到编号为5的这个节点相对于根节点的位置，看这个节点是不是空，不是说明存在，exist返回真 * 编号为5的节点存在，说明总节点数量一定大于等于5。所以二分那里low = mid * * 再比如看7存不存在，010 &amp; 111 第二位为1，第一部从根节点向右；001 &amp; 111 第三位也为1，第二步继续向右。 * 然后判断当前节点是不是null，发现是null，exist返回假。 * 编号为7的节点不存在，说明总节点数量一定小于7。所以high = mid - 1 * @param root */public int countNodes2(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int level = 0;    TreeNode node = root;    while (node.left != null) &#123;        level++;        node = node.left;    &#125;    int low = 1 &lt;&lt; level, high = (1 &lt;&lt; (level + 1)) - 1;    while (low &lt; high) &#123;        int mid = (high - low + 1) / 2 + low;        if (exists(root, level, mid)) &#123;            low = mid;        &#125; else &#123;            high = mid - 1;        &#125;    &#125;    return low;&#125;public boolean exists(TreeNode root, int level, int k) &#123;    int bits = 1 &lt;&lt; (level - 1);    TreeNode node = root;    while (node != null &amp;&amp; bits &gt; 0) &#123;        if ((bits &amp; k) == 0) &#123;            node = node.left;        &#125; else &#123;            node = node.right;        &#125;        bits &gt;&gt;= 1;    &#125;    return node != null;&#125;/** * 比较二叉树左右子树高度 * 如果相等（左子树必然被填满）则左子树为满的二叉树 节点数量为 2^h-1,迭代右子树 * 如果不相等则右子树为满二叉树，迭代左子树 * * 1 &lt;&lt; h  ==&gt;   1 * 2^h * * @param root * @return */public int countNodes(TreeNode root) &#123;    if (root == null) return 0;    int rightHigh = countHigh(root.right);    int leftHigh = countHigh(root.left);    if (leftHigh == rightHigh) &#123;        return (1 &lt;&lt; leftHigh) + countNodes(root.right);    &#125; else &#123;        return countNodes(root.left) + (1 &lt;&lt; rightHigh);    &#125;&#125;/** * 计算满二叉树的高度 * * @param root * @return */private int countHigh(TreeNode root) &#123;    int high = 0;    while (root != null) &#123;        high++;        root = root.left;    &#125;    return high;&#125;","categories":["数据结构与算法"],"tags":["leetcode","二叉树"]},{"title":"450. 删除二叉搜索树中的节点","url":"/java4u/2021/08/03/450.%20%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","content":"450. 删除二叉搜索树中的节点给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n一般来说，删除节点可分为两个步骤：\n\n首先找到需要删除的节点；\n如果找到了，删除它。\n\n示例 1:\n输入：root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 3输出：[5,4,6,2,null,null,7]解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7]另一个正确答案是 [5,2,6,null,4,null,7]。  \n示例 2:\n输入: root &#x3D; [5,3,6,2,4,null,7], key &#x3D; 0输出: [5,3,6,2,4,null,7]解释: 二叉树不包含值为 0 的节点\n示例 3:\n输入: root &#x3D; [], key &#x3D; 0输出: []\n提示:\n节点数的范围 [0, 10^4]-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5节点值唯一root 是合法的二叉搜索树-10^5 &lt;&#x3D; key &lt;&#x3D; 10^5\n进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。\n题解public TreeNode deleteNode2(TreeNode root, int key) &#123;    if (root == null) &#123;        return null;    &#125;    // Find the target node    TreeNode cur = root, prev = null;    while (cur != null) &#123;        if (cur.val == key) &#123;            break;        &#125; else &#123;            prev = cur;            cur = cur.val &lt; key ? cur.right : cur.left;        &#125;    &#125;    if (cur == null) &#123;        return root;    &#125;    // Find replacement, the rightest node in left subtree    TreeNode rep;    if (cur.left == null) &#123;        rep = cur.right;    &#125; else &#123;        if (cur.left.right == null) &#123;            cur.left.right = cur.right;            rep = cur.left;        &#125; else &#123;            TreeNode repPrev = cur;            rep = cur.left;            while (rep.right != null) &#123;                repPrev = rep;                rep = rep.right;            &#125;            repPrev.right = rep.left;            rep.left = cur.left;            rep.right = cur.right;        &#125;    &#125;    if (prev != null) &#123;        if (prev.left == cur) &#123;            prev.left = rep;        &#125; else &#123;            prev.right = rep;        &#125;    &#125;    return root.val == key ? rep : root;&#125;public TreeNode deleteNode(TreeNode root, int key) &#123;    if (root == null) return null;    // delete from the right subtree    if (key &gt; root.val) root.right = deleteNode(root.right, key);        // delete from the left subtree    else if (key &lt; root.val) root.left = deleteNode(root.left, key);        // delete the current node    else &#123;        // the node is a leaf        if (root.left == null &amp;&amp; root.right == null) root = null;            // the node is not a leaf and has a right child        else if (root.right != null) &#123;            //用后继节点替代当前节点的值            root.val = successor(root);            //从当前节点的右节点开始找后继节点删除            root.right = deleteNode(root.right, root.val);        &#125;        // the node is not a leaf, has no right child, and has a left child        else &#123;            root.val = predecessor(root);            root.left = deleteNode(root.left, root.val);        &#125;    &#125;    return root;&#125;/** * 获取节点的后继节点 * 大于当前节点最小的节点 * @param root * @return */public int successor(TreeNode root) &#123;    root = root.right;    while (root.left != null) root = root.left;    return root.val;&#125;/** * 前继节点 * 比节点小的最大节点 * @param root * @return */public int predecessor(TreeNode root) &#123;    root = root.left;    while (root.right != null) root = root.right;    return root.val;&#125;/** * 找到要被删除的节点 * 三种情况： * 1.要删除的节点为叶子节点，可以直接删除 * 2.要删除的节点不是叶子节点且拥有右节点，则该节点可以由该节点的后继节点进行替代， * 该后继节点位于右子树中较低的位置。然后可以从后继节点的位置递归向下操作以删除后继节点。 * 3.要删除的节点不是叶子节点，且没有右节点但是有左节点。这意味着它的后继节点在它的上面， * 但是我们并不想返回。我们可以使用它的前驱节点进行替代，然后再递归的向下删除前驱节点。 * * 不通过 * 使用后继节点代替该节点后，并没有删除掉后继节点 * * @param root * @param key * @return */public TreeNode deleteNode3(TreeNode root, int key) &#123;    if (root == null) return null;    TreeNode cur = root,pre = root;    //找到被删除节点    while (cur != null) &#123;        if(cur.val == key) &#123;            break;        &#125;else if(cur.val &gt; key) &#123;            pre = cur;            cur = cur.left;        &#125;else &#123;            pre = cur;            cur = cur.right;        &#125;    &#125;    if(cur == null)return null;    if(cur.right == null &amp;&amp; cur.left == null) &#123;        cur = null;        //拥有右节点，用后继节点代替该节点    &#125;else if(cur.right != null)&#123;        TreeNode successor = successorNode(cur);    &#125;else&#123;        TreeNode predecessor = predecessorNode(cur);    &#125;    return root;&#125;public TreeNode successorNode(TreeNode root) &#123;    root = root.right;    while (root.left != null) root = root.left;    return root;&#125;public TreeNode predecessorNode(TreeNode root) &#123;    root = root.left;    while (root.right != null) root = root.right;    return root;&#125;","categories":["数据结构与算法"],"tags":["leetcode","二叉树"]},{"title":"700. 二叉搜索树中的搜索","url":"/java4u/2021/07/28/700.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/","content":"700. 二叉搜索树中的搜索给定二叉搜索树（BST）的根节点 root 和一个整数值 val。\n你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。\n示例 1:\n输入：root &#x3D; [4,2,7,1,3], val &#x3D; 2输出：[2,1,3]\n示例 2:\n输入：root &#x3D; [4,2,7,1,3], val &#x3D; 5输出：[]\n提示：\n数中节点数在 [1, 5000] 范围内1 &lt;&#x3D; Node.val &lt;&#x3D; 10^7root 是二叉搜索树1 &lt;&#x3D; val &lt;&#x3D; 10^7\n题解//递归：重复调用函数自身实现循环称为递归；//迭代：利用变量的原值推出新值称为迭代，或者说迭代是函数内某段代码实现循环；//递归public TreeNode searchBST(TreeNode root, int val) &#123;    if(root == null)return null;    if(root.val &gt; val)&#123;        return searchBST(root.left, val);    &#125;else if(root.val &lt; val)&#123;        return searchBST(root.right, val);    &#125;else &#123;        return root;    &#125;&#125;//迭代public TreeNode searchBST2(TreeNode root, int val) &#123;    while (root != null) &#123;        if (root.val == val) &#123;            return root;        &#125; else if (root.val &gt; val) &#123;            root = root.left;        &#125; else &#123;            root = root.right;        &#125;    &#125;    return null;&#125;","categories":["数据结构与算法"],"tags":["leetcode","二叉树"]},{"title":"98. 验证二叉搜索树","url":"/java4u/2021/07/28/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"98. 验证二叉搜索树给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\n示例 1：\n输入：root &#x3D; [2,1,3]输出：true\n示例 2：\n输入：root &#x3D; [5,1,4,null,null,3,6]输出：false解释：根节点的值是 5 ，但是右子节点的值是 4 。\n提示：\n树中节点数目范围在[1, 10^4] 内-2^31 &lt;&#x3D; Node.val &lt;&#x3D; 2^31 - 1\n题解/** * 除了验证左节点小于根节点，还需传入上界和下界限制 * 子节点不能超过所有父节点的限制 * 向下遍历时，左节点上界缩小，左节点不能大于父节点 * 右节点下界扩大，右节点不能小于父节点 * @param root * @return */public boolean isValidBST(TreeNode root) &#123;    long min = Long.MIN_VALUE;    long max = Long.MAX_VALUE;    return validBST(root, min, max);&#125;private boolean validBST(TreeNode root, long min, long max)&#123;    if(root == null) return true;    if(root.val &lt;= min || root.val &gt;= max) return false;    return validBST(root.left, min, root.val) &amp;&amp; validBST(root.right, root.val, max);&#125;","categories":["数据结构与算法"],"tags":["leetcode","二叉树"]},{"title":"102. 二叉树的层序遍历","url":"/java4u/2021/07/27/102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"102. 二叉树的层序遍历给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n示例 1：\n输入：root &#x3D; [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]\n示例 2：\n输入：root &#x3D; [1]输出：[[1]]\n示例 3：\n输入：root &#x3D; []输出：[]\n提示：\n树中节点数目在范围 [0, 2000] 内-1000 &lt;&#x3D; Node.val &lt;&#x3D; 1000\n题解/** * BFS使用队列实现 * 将根节点存入队列，通过消耗队尾，插入队头的方式遍历二叉树 * @param root * @return */public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;    if(root == null) return new ArrayList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    //队尾插入    queue.offer(root);    while (!queue.isEmpty()) &#123;        int len = queue.size();        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for (int i = 1; i &lt;= len; i++) &#123;            //队首取出            TreeNode treeNode = queue.poll();            if (treeNode.left != null) &#123;                queue.offer(treeNode.left);            &#125;            if (treeNode.right != null) &#123;                queue.offer(treeNode.right);            &#125;            list.add(treeNode.val);        &#125;        res.add(list);    &#125;    return res;&#125;","categories":["数据结构与算法"],"tags":["leetcode","二叉树"]},{"title":"58. 最后一个单词的长度","url":"/java4u/2021/07/24/58.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/","content":"58. 最后一个单词的长度给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n示例 1：\n输入：s &#x3D; “Hello World”输出：5解释：最后一个单词是“World”，长度为5。\n示例 2：\n输入：s &#x3D; “   fly me   to   the moon  “输出：4解释：最后一个单词是“moon”，长度为4。\n示例 3：\n输入：s &#x3D; “luffy is still joyboy”输出：6解释：最后一个单词是长度为6的“joyboy”。\n提示：\n1 &lt;&#x3D; s.length &lt;&#x3D; 10^4s 仅有英文字母和空格 ‘ ‘ 组成s 中至少存在一个单词\n题解public int lengthOfLastWord(String s) &#123;    if (s.length() == 0) return 0;    int len = s.length();    int count = 0;    for (int i = len - 1; i &gt;= 0; i--) &#123;        if (s.charAt(i) == &#x27; &#x27;) &#123;            //字符末尾也可能存在空格            //遇到空格可以直接跳过            if (count == 0) continue;            break;        &#125;        count++;    &#125;    return count;&#125;public int lengthOfLastWord2(String s) &#123;    s = s.trim();    int start = s.lastIndexOf(&quot; &quot;) + 1;    return s.substring(start).length();&#125;public int lengthOfLastWord3(String s) &#123;    String[] words = s.split(&quot; &quot;);    if (words.length &lt; 1) return 0;    return words[words.length - 1].length();&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","字符串"]},{"title":"796. 旋转字符串","url":"/java4u/2021/07/24/796.%20%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"796. 旋转字符串给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。\ns 的 旋转操作 就是将 s 最左边的字符移动到最右边。\n例如, 若 s &#x3D; ‘abcde’，在旋转一次之后结果就是’bcdea’ 。\n示例 1:\n输入: s &#x3D; “abcde”, goal &#x3D; “cdeab”输出: true\n示例 2:\n输入: s &#x3D; “abcde”, goal &#x3D; “abced”输出: false\n提示:\n1 &lt;&#x3D; s.length, goal.length &lt;&#x3D; 100s 和 goal 由小写英文字母组成\n题解/** * 暴力解法，不断移到目标字符 * * @param s * @param goal * @return */public boolean rotateString(String s, String goal) &#123;    if (s.length() == 0 &amp;&amp; goal.length() == 0) return true;    int len = s.length();    for (int i = 0; i &lt; len; i++) &#123;        String first = s.substring(0, i);        String last = s.substring(i, len);        if ((last + first).equals(goal)) &#123;            return true;        &#125;    &#125;    return false;&#125;/** * 观察字符串    a b c d e * b c d e a * c d e a b * d e a b c * e a b c d * a b c d e * a b c d e a b c d e      A+A 包含所有A通过旋转得到的所有情况 * 只需要判断 B 是否为 A + A 的子串就可以了 * * @param s * @param goal * @return */public boolean rotateString2(String s, String goal) &#123;    return s.length() == goal.length() &amp;&amp; (s + s).contains(goal);&#125;/** * 通过上面的解题，可以转换为 B是否为 A+A的子串 * 通过KMP解题 * * @param A 目标串 * @param B 模式串 * @return */public boolean rotateString3(String A, String B) &#123;    int N = A.length();    if (N != B.length()) return false;    if (N == 0) return true;    //Compute shift table    int[] shifts = new int[N + 1];    Arrays.fill(shifts, 1);    int left = -1;    for (int right = 0; right &lt; N; ++right) &#123;        while (left &gt;= 0 &amp;&amp; (B.charAt(left) != B.charAt(right)))            left -= shifts[left];        shifts[right + 1] = right - left++;    &#125;    //Find match of B in A+A    int matchLen = 0;    for (char c : (A + A).toCharArray()) &#123;        while (matchLen &gt;= 0 &amp;&amp; B.charAt(matchLen) != c)            matchLen -= shifts[matchLen];        if (++matchLen == N) return true;    &#125;    return false;&#125;public int KMP(String ts, String ps) &#123;    char[] t = ts.toCharArray();    char[] p = ps.toCharArray();    int i = 0; // 主串的位置    int j = 0; // 模式串的位置    int[] next = getNext(ps);    while (i &lt; t.length &amp;&amp; j &lt; p.length) &#123;        if (j == -1 || t[i] == p[j]) &#123; // 当j为-1时，要移动的是i，当然j也要归0            i++;            j++;        &#125; else &#123;            // i不需要回溯了            // i = i - j + 1;            j = next[j]; // j回到指定位置        &#125;    &#125;    if (j == p.length) &#123;        return i - j;    &#125; else &#123;        return -1;    &#125;&#125;/** * 获取模式串的next表 *  i * abaabcac *  abaabcac *  j * @param p * @return */private int[] getNext(String p) &#123;    int[] next = new int[p.length() + 1];    next[0] = -1;    int i = 0, j = -1;    while (i &lt; p.length()) &#123;        if (j == -1 || p.charAt(i) == p.charAt(j)) &#123;            //如果匹配上，我们把 i 和 j 都加一,并且写表            ++i;            ++j;            next[i] = j;        &#125; else &#123;            //如果没有匹配上，就把 j 回溯到 j 当前指向的前一个位置的 index 处            j = next[j];        &#125;    &#125;    return next;&#125;\n\nKMP\n如果按照暴力匹配。此时目标串我们应该回到 B 这个位置，模式串应直接回到头。但是按照 KMP 的思路，在我们在第一次匹配后，因为 BC 匹配成功了，所以我们知道了 BC 不等于 A那既然已知了 BC 不等于 A，我们就没必要用 A 和 BC 进行匹配了。那我们直接用 A 越过前面不需要匹配的 BC：\n\n不断向后移动，直到匹配\n\n在KMP中，如果模式串和目标串没有匹配成功，目标串不回溯在匹配过程中，跳过不可能成功的尝试（next数组）\n\n\n\n\n序号\n0\n1\n2\n3\n4\n5\n6\n7\n\n\n\n模式串\na\nb\na\na\nb\nc\na\nc\n\n\nshift\n1\n1\n2\n2\n3\n3\n6\n6\n\n\npmt\n0\n0\n1\n1\n2\n0\n1\n0\n\n\nnext\n-1\n0\n0\n1\n1\n2\n0\n1\n\n\nindex-shift&#x3D;next\nnext表表示模式串真前缀（不含括自身）和真后缀匹配的数量，移动时就可以将前缀和后缀对齐即可，如图：\n\n","categories":["数据结构与算法"],"tags":["leetcode","字符串"]},{"title":"剑指 Offer 17. 打印从1到最大的n位数","url":"/java4u/2021/07/21/%E5%89%91%E6%8C%87%20Offer%2017.%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/","content":"剑指 Offer 17. 打印从1到最大的n位数输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n示例 1:\n输入: n &#x3D; 1输出: [1,2,3,4,5,6,7,8,9]\n说明：\n用返回一个整数列表来代替打印n 为正整数\n题解/**     * 简单解法，获取最高位，一直打印     * 可能的问题：超过int范围的大数？     */    public int[] printNumbers2(int n) &#123;        int len = (int) Math.pow(10, n);        int[] res = new int[len - 1];        for (int i = 1; i &lt; len; i++) &#123;            res[i - 1] = i;        &#125;        return res;    &#125;    /**     * 使用字符存放大数，对最低位的值不断递增     * 对最低位 nSum 的值递增（也就是字符串加1运算），当大于等于10时，     * 我们把进位标识改为1，同时恢复对 nSum 减10（29-31）     * 通过判断首位是否进位来判断到达最大的n位数情况。比如 n=4，只有对 9999 加 1，才会对第一个字符进位     *     * @param n     */    public void printNumbers(int n) &#123;        //声明字符数组,用来存放一个大数        char[] number = new char[n];        Arrays.fill(number, &#x27;0&#x27;);        while (!incrementNumber(number)) &#123;            saveNumber(number); //存储数值        &#125;    &#125;    private boolean incrementNumber(char[] number) &#123;        //循环体退出标识        boolean isBreak = false;        //进位标识        int carryFlag = 0;        int l = number.length;        for (int i = l - 1; i &gt;= 0; i--) &#123;            //取第i位的数字转化位int            int nSum = number[i] - &#x27;0&#x27; + carryFlag;            if (i == l - 1) &#123;                //最低位加1                ++nSum;            &#125;            if (nSum &gt;= 10) &#123;                //当i为0时，说明已经到了字符最前端 999 9999                //进位的数不需要打印，循环停止                if (i == 0) &#123;                    isBreak = true;                &#125; else &#123;                    //进位之后减10，并把进位标识设置为1                    nSum -= 10;                    carryFlag = 1;                    number[i] = (char) (&#x27;0&#x27; + nSum);                &#125;            &#125; else &#123;                number[i] = (char) (nSum + &#x27;0&#x27;);                break;            &#125;        &#125;        return isBreak;    &#125;    private void saveNumber(char[] number) &#123;        boolean isBegin0 = true;        for (char c : number) &#123;            if (isBegin0 &amp;&amp; c != &#x27;0&#x27;) &#123;                isBegin0 = false;            &#125;            if (!isBegin0) &#123;                // 到这里并没有继续往下实现一个存储数组的版本，是因为原题其实就是要求打印数值。                // 这道题目在leetcode上被改动成返回int数组的形式，也只是为了测试方便，                // 本身leetcode并没有提供对应的大数测试样例，也是担心其内存溢出。                // 总之大家知道本题的考察点所在就可以了。                System.out.print(c);            &#125;        &#125;        System.out.println();    &#125;","categories":["数据结构与算法"],"tags":["leetcode","字符串"]},{"title":"支付平台方案","url":"/java4u/2021/07/07/%E6%94%AF%E4%BB%98%E5%B9%B3%E5%8F%B0%E6%96%B9%E6%A1%88/","content":"场景：重庆广电对接第三方支付平台（诚毅）的流程与方案\n1.页面整体修改\n1）页面提供定时轮询，查询订单状态    持续轮询    支付成功：按钮修改为关闭页面\n2）页面下方提供一个可变化的按钮，根据订单状态修改按钮样式\n\n2.后端服务\n1）表设计  添加业务处理状态\n2）对外提供修改订单的服务\n3）业务完成更新业务处理状态\n\n3.补偿   对外接口   CSF服务\n1）支付成功修改订单状态    轮询 订单表   业务未处理  已充值  –》补偿（预存）\n2）退费页面\n轮询表中的数据对于超出某个时间的数据属于异常数据，对异常数据进行退费处理（同时添加退费页面）\n\n","categories":["方案"],"tags":["支付"]},{"title":"28. 实现 strStr()","url":"/java4u/2021/06/29/28.%20%E5%AE%9E%E7%8E%B0%20strStr()/","content":"28. 实现 strStr()实现 strStr() 函数。\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。\n说明：\n当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。\n示例 1：\n输入：haystack &#x3D; “hello”, needle &#x3D; “ll”输出：2\n示例 2：\n输入：haystack &#x3D; “aaaaa”, needle &#x3D; “bba”输出：-1\n示例 3：\n输入：haystack &#x3D; “”, needle &#x3D; “”输出：0\n提示：\n1 &lt;&#x3D; haystack.length, needle.length &lt;&#x3D; 10^4haystack 和 needle 仅由小写英文字符组成\nSunday匹配假若我们的目标串为：Here is a little Hao模式串为：little一般来讲，字符串匹配算法第一步，都是把目标串和模式串对齐\n\n而对于SUNDAY算法，我们从头部开始比较，一旦发现不匹配，直接找到主串中位于模式串后面的第一个字符，即下面绿色的 “s”。（这里说明一下，为什么是找模式串后面的第一个字符。在把模式串和目标串对齐后，如果发现不匹配，那肯定需要移动模式串。问题是需要移动多少步。各字符串匹配算法之间的差别也来自于这个地方，对于KMP，是建立部分匹配表来计算。BM，是反向比较计算移动量。对于SUNDAY，就是找到模式串后的第一个字符。因为，无论模式串移动多少步，模式串后的第一个字符都要参与下一次比较，也就是这里的 “s”）\n\n找到了模式串后的第一个字符 “s”，接下来该怎么做？我们需要查看模式串中是否包含这个元素，如果不包含那就可以跳过一大片，从该字符的下一个字符开始比较。\n\n因为仍然不匹配（空格和l），我们继续重复上面的过程。找到模式串的下一个元素：t\n\n现在有意思了，我们发现 t 被包含于模式串中，并且 t 出现在模式串倒数第3个。所以我们把模式串向前移动3个单位：\n\n匹配成功，总结：\n\n对齐目标串和模式串，从前向后匹配\n关注主串中位于模式串后面的第一个元素（核心）\n如果关注的字符没有在子串中出现则直接跳过\n否则开始移动模式串，移动位数 &#x3D; 子串长度 - 该字符最右出现的位置(以0开始)\n\n题解/**     * Sunday 匹配     * 对齐目标串和模式串，从前向后匹配     * 关注主串中位于模式串后面的第一个元素（核心）     * 如果关注的字符没有在子串中出现则直接跳过     * 否则开始移动模式串，移动位数 = 子串长度 - 该字符最右出现的位置(以0开始)     *                     01234567890123456789     * @param origin 目标串 Here is a little Hao     * @param aim    模式串 little     * @return     */    public int strStr(String origin, String aim) &#123;        if (origin == null || aim == null) &#123;            return 0;        &#125;        if (origin.length() &lt; aim.length()) &#123;            return -1;        &#125;        //目标串匹配索        int originIndex = 0;        //模式串匹配索引        int aimIndex = 0;        // 成功匹配完终止条件：所有aim均成功匹配        while (aimIndex &lt; aim.length()) &#123;            // 针对origin匹配完，但aim未匹配完情况处理 如 mississippi sippia            if (originIndex &gt; origin.length() - 1) &#123;                return -1;            &#125;            if (origin.charAt(originIndex) == aim.charAt(aimIndex)) &#123;                // 匹配则index均加1                originIndex++;                aimIndex++;            &#125; else &#123;                //在我们上面的样例中，第一次计算值为6(s)，第二次值为13(t)                int nextCharIndex = originIndex - aimIndex + aim.length();                //判断下一个目标字符（上面图里的那个绿框框）是否存在。                if (nextCharIndex &lt; origin.length()) &#123;                    // 判断目标字符在模式串中匹配到，返回最后一个匹配的index                    int step = aim.lastIndexOf(origin.charAt(nextCharIndex));                    if (step == -1) &#123;                        // 不存在的话，设置到目标字符的下一个元素                        originIndex = nextCharIndex + 1;                    &#125; else &#123;                        // 存在的话，移动对应的数字（参考上文中的存在公式）                        originIndex = nextCharIndex - step;                    &#125;                    //模式串总是从第一个开始匹配                    aimIndex = 0;                &#125; else &#123;                    return -1;                &#125;            &#125;        &#125;        return originIndex - aimIndex;    &#125;","categories":["数据结构与算法"],"tags":["leetcode","字符串"]},{"title":"387. 字符串中的第一个唯一字符","url":"/java4u/2021/06/28/387.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/","content":"387. 字符串中的第一个唯一字符给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。\n示例 1：\n输入: s &#x3D; “leetcode”输出: 0\n示例 2:\n输入: s &#x3D; “loveleetcode”输出: 2\n示例 3:\n输入: s &#x3D; “aabb”输出: -1\n提示:\n1 &lt;&#x3D; s.length &lt;&#x3D; 10^5s 只包含小写字母\n题解/** * 遍历字符串，记录字符第一次出现的位置 * 当字符再次出现，将字符的位置置为-1 * 最后遍历数组，查找不是0或-1的字符 * * @param s * @return */public int firstUniqChar(String s) &#123;    if (s == null || s.length() == 0) return -1;    int[] arr = new int[26];    char[] chars = s.toCharArray();    for (int i = 0; i &lt; chars.length; i++) &#123;        char ch = chars[i];        if (arr[ch - &#x27;a&#x27;] != 0) &#123;            arr[ch - &#x27;a&#x27;] = -1;        &#125; else &#123;            //存放字符的位置向右移动1位，让第一位和初始区分            arr[ch - &#x27;a&#x27;] = i + 1;        &#125;    &#125;    //需要找到不是0或-1 的最小值    int min = Integer.MAX_VALUE;    for (int j : arr) &#123;        if (j != 0 &amp;&amp; j != -1) &#123;            min = Math.min(min, --j);        &#125;    &#125;    return min == Integer.MAX_VALUE ? -1 : min;&#125;/** * 只包含小写字母，可以申明一个26的数组 * 第一次遍历记录每个字母最后一次出现的位置 * 第二次遍历获取字母第一次出现的位置，不同为-1，相同即为要找的位置 * * @param s * @return */public int firstUniqChar2(String s) &#123;    if (s == null || s.length() == 0) return -1;    int[] arr = new int[26];    char[] chars = s.toCharArray();    //第一次遍历 记录每个字母最后一次出现的位置    for (int i = 0; i &lt; chars.length; i++) &#123;        char ch = chars[i];        arr[ch - &#x27;a&#x27;] = i;    &#125;    //第二次遍历获取字母第一次出现的位置 与 最后一次出现的位置进行比较    for (int j = 0; j &lt; chars.length; j++) &#123;        char ch2 = chars[j];        if (arr[ch2 - &#x27;a&#x27;] == j) &#123;            return j;        &#125; else &#123;            arr[ch2 - &#x27;a&#x27;] = -1;        &#125;    &#125;    return -1;&#125;/** * 我们可以对字符串进行两次遍历。 * &lt;p&gt; * 在第一次遍历时，我们使用哈希映射统计出字符串中每个字符出现的次数。 * 在第二次遍历时，我们只要遍历到了一个只出现一次的字符，那么就返回它的索引，否则在遍历结束后返回 -1−1。 * * @param s * @return */public int firstUniqChar3(String s) &#123;    Map&lt;Character, Integer&gt; frequency = new HashMap&lt;Character, Integer&gt;();    for (int i = 0; i &lt; s.length(); ++i) &#123;        char ch = s.charAt(i);        frequency.put(ch, frequency.getOrDefault(ch, 0) + 1);    &#125;    for (int i = 0; i &lt; s.length(); ++i) &#123;        if (frequency.get(s.charAt(i)) == 1) &#123;            return i;        &#125;    &#125;    return -1;&#125;/** * 我们可以对方法一进行修改，使得第二次遍历的对象从字符串变为哈希映射。 * 具体地，对于哈希映射中的每一个键值对，键表示一个字符，值表示它的首次出现的索引（如果该字符只出现一次） * 或者 −1（如果该字符出现多次）。当我们第一次遍历字符串时，设当前遍历到的字符为 c，如果 c 不在哈希映射中， * 我们就将 c 与它的索引作为一个键值对加入哈希映射中， * 否则我们将 c 在哈希映射中对应的值修改为 −1。 * 在第一次遍历结束后，我们只需要再遍历一次哈希映射中的所有值，找出其中不为 −1 的最小值， * 即为第一个不重复字符的索引。如果哈希映射中的所有值均为 −1，我们就返回 −1。 * * @param s * @return */public int firstUniqChar4(String s) &#123;    Map&lt;Character, Integer&gt; position = new HashMap&lt;Character, Integer&gt;();    int n = s.length();    for (int i = 0; i &lt; n; ++i) &#123;        char ch = s.charAt(i);        if (position.containsKey(ch)) &#123;            position.put(ch, -1);        &#125; else &#123;            position.put(ch, i);        &#125;    &#125;    int first = n;    for (Map.Entry&lt;Character, Integer&gt; entry : position.entrySet()) &#123;        int pos = entry.getValue();        if (pos != -1 &amp;&amp; pos &lt; first) &#123;            first = pos;        &#125;    &#125;    if (first == n) &#123;        first = -1;    &#125;    return first;&#125;    ","categories":["数据结构与算法"],"tags":["leetcode","字符串"]},{"title":"344. 反转字符串","url":"/java4u/2021/06/26/344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"344. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n示例 1：\n输入：s &#x3D; [“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”]\n示例 2：\n输入：s &#x3D; [“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”]\n提示：\n1 &lt;&#x3D; s.length &lt;&#x3D; 10^5s[i] 都是 ASCII 码表中的可打印字符\n题解//使用双指针交换字符public void reverseString(char[] s) &#123;    if(s == null || s.length == 0)return;    int left = 0;    int right = s.length-1;    while (left &lt; right)&#123;        char temp = s[left];        s[left] = s[right];        s[right] = temp;        left++;        right--;    &#125;&#125;","categories":["数据结构与算法"],"tags":["leetcode","字符串"]},{"title":"120. 三角形最小路径和","url":"/java4u/2021/06/23/120.%20%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","content":"120. 三角形最小路径和给定一个三角形 triangle ，找出自顶向下的最小路径和。\n每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。\n示例 1：\n输入：triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]输出：11解释：如下面简图所示：\n   2  3 4 6 5 74 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。\n示例 2：\n输入：triangle &#x3D; [[-10]]输出：-10\n提示：\n1 &lt;&#x3D; triangle.length &lt;&#x3D; 200triangle[0].length &#x3D;&#x3D; 1triangle[i].length &#x3D;&#x3D; triangle[i - 1].length + 1-10^4 &lt;&#x3D; triangle[i][j] &lt;&#x3D; 10^4\n进阶：\n你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？\n题解/** *    2             2 *   3 4    转换下   3 4 *  6 5 7           6 5 7 * 4 1 8 3          4 1 8 3 * 即每层的路径就是上层和上层左边的位置移动来 * dp[i][j]表示每格最小路径和 * 我们用 f[i][j] 表示从三角形顶部走到位置 (i,j) 的最小路径和。这里的位置 (i,j) * 指的是三角形中第 i 行第 j 列（均从 0 开始编号）的位置。 * 由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置 (i,j)， * 上一步就只能在位置 (i−1,j−1) 或者位置 (i−1,j)。 * 我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为： * f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j] * 其中 c[i][j] 表示位置 (i,j) 对应的元素值。 * 注意第 i 行有 i+1 个元素，它们对应的 j 的范围为 [0,i]。 * 当 j=0 或 j=i 时，上述状态转移方程中有一些项是没有意义的。 * 例如当 j=0 时，f[i−1][j−1] 没有意义，因此状态转移方程为： * f[i][0]=f[i−1][0]+c[i][0] * 即当我们在第 i 行的最左侧时，我们只能从第 i−1 行的最左侧移动过来。 * 当 j=i 时，f[i−1][j] 没有意义，因此状态转移方程为： * f[i][i]=f[i−1][i−1]+c[i][i] * 即当我们在第 i 行的最右侧时，我们只能从第 i−1 行的最右侧移动过来。 * 最终的答案即为 f[n−1][0] 到 f[n−1][n−1] 中的最小值，其中 n 是三角形的行数。 * * @param triangle * @return */public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    int h = triangle.size();    int l = triangle.get(h-1).size();    int[][] dp = new int[h][l];    int pre = triangle.get(0).get(0);    dp[0][0] = pre;    for (int i = 1; i &lt; h; i++) &#123;        List&lt;Integer&gt; t = triangle.get(i);        for (int j = 0; j &lt; t.size(); j++) &#123;            if(j == 0)&#123;                dp[i][j] = dp[i-1][j] + t.get(j);            &#125;else if(j == t.size()-1)&#123;                dp[i][j] = dp[i-1][j-1] + t.get(j);            &#125;else&#123;                dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + t.get(j);            &#125;        &#125;    &#125;    int min = Integer.MAX_VALUE;    for (int k = 0; k &lt; l; k++) &#123;        min = Math.min(min, dp[h - 1][k]);    &#125;    return min;&#125;//换一种写法 看上去更好看public int minimumTotal2(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    int n = triangle.size();    int[][] f = new int[n][n];    f[0][0] = triangle.get(0).get(0);    for (int i = 1; i &lt; n; ++i) &#123;        f[i][0] = f[i - 1][0] + triangle.get(i).get(0);        for (int j = 1; j &lt; i; ++j) &#123;            f[i][j] = Math.min(f[i - 1][j - 1], f[i - 1][j]) + triangle.get(i).get(j);        &#125;        f[i][i] = f[i - 1][i - 1] + triangle.get(i).get(i);    &#125;    int minTotal = f[n - 1][0];    for (int i = 1; i &lt; n; ++i) &#123;        minTotal = Math.min(minTotal, f[n - 1][i]);    &#125;    return minTotal;&#125;/** * 动态规则都可以将二维数组压缩成一维数组，减少空间 * 三角形自顶而下计算，其实只需要上一层的数据就可以进行计算 * * 不通过 * 下层dp由上层计算而来，所以每次计算下层的dp都会被上层左侧的结果影响 * 需要保留最近的一次计算结果即维持一个二维数组 * @param triangle * @return */public int minimumTotal3(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    int h = triangle.size();    int l = triangle.get(h-1).size();    int[] dp = new int[l];    dp[0]=triangle.get(0).get(0);    for (int i = 1; i &lt; h; ++i) &#123;        List&lt;Integer&gt; t = triangle.get(i);        for (int j = 0; j &lt; t.size(); j++) &#123;            if(j==0)&#123;                dp[j]+=triangle.get(i).get(j);            &#125;else if(j==t.size()-1)&#123;                dp[j]=dp[j-1]+triangle.get(i).get(j);            &#125;else&#123;                dp[j]=Math.min(dp[j-1],dp[j])+triangle.get(i).get(j);            &#125;        &#125;    &#125;    int min = dp[0];    for (int k = 0; k &lt; l; k++) &#123;        min = Math.min(min, dp[k]);    &#125;    return min;&#125;//使用二维数组压缩//判断有点多，只是判断行的奇偶性，可以取模优化public int minimumTotal4(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    int h = triangle.size();    int l = triangle.get(h-1).size();    int[][] dp = new int[2][l];    dp[0][0]=triangle.get(0).get(0);    if(h==1)return dp[0][0];    dp[1][0]=dp[0][0]+triangle.get(1).get(0);    dp[1][1]=dp[0][0]+triangle.get(1).get(1);    if(h==2)return Math.min(dp[1][0],dp[1][1]);    for (int i = 2; i &lt; h; ++i) &#123;        List&lt;Integer&gt; t = triangle.get(i);        for (int j = 0; j &lt; t.size(); j++) &#123;            if(j==0)&#123;                if(i%2==1)&#123;                    dp[1][j]=dp[0][j]+triangle.get(i).get(j);                &#125;else&#123;                    dp[0][j]=dp[1][j]+triangle.get(i).get(j);                &#125;            &#125;else if(j==t.size()-1)&#123;                if(i%2==1)&#123;                    dp[1][j]=dp[0][j-1]+triangle.get(i).get(j);                &#125;else&#123;                    dp[0][j]=dp[1][j-1]+triangle.get(i).get(j);                &#125;            &#125;else&#123;                if(i%2==1)&#123;                    dp[1][j]=Math.min(dp[0][j-1],dp[0][j])+triangle.get(i).get(j);                &#125;else&#123;                    dp[0][j]=Math.min(dp[1][j-1],dp[1][j])+triangle.get(i).get(j);                &#125;            &#125;        &#125;    &#125;    int min = Integer.MAX_VALUE;    if(h%2==0)&#123;        for (int k = 0; k &lt; l; k++) &#123;            min = Math.min(min, dp[1][k]);        &#125;    &#125;else&#123;        for (int k = 0; k &lt; l; k++) &#123;            min = Math.min(min, dp[0][k]);        &#125;    &#125;    return min;&#125;public int minimumTotal5(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    int n = triangle.size();    int[][] f = new int[2][n];    f[0][0] = triangle.get(0).get(0);    for (int i = 1; i &lt; n; ++i) &#123;        //用 1-当前行数模2 来确定数据放在哪行        int curr = i % 2;        int prev = 1 - curr;        f[curr][0] = f[prev][0] + triangle.get(i).get(0);        for (int j = 1; j &lt; i; ++j) &#123;            f[curr][j] = Math.min(f[prev][j - 1], f[prev][j]) + triangle.get(i).get(j);        &#125;        f[curr][i] = f[prev][i - 1] + triangle.get(i).get(i);    &#125;    int minTotal = f[(n - 1) % 2][0];    for (int i = 1; i &lt; n; ++i) &#123;        minTotal = Math.min(minTotal, f[(n - 1) % 2][i]);    &#125;    return minTotal;&#125;//还是可以压缩成1维数组//每次计算的时候从该行最后开始计算//因为dp计算结果是从上面和左侧计算来的，右侧结果不会影响public int minimumTotal6(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    int n = triangle.size();    int[] f = new int[n];    f[0] = triangle.get(0).get(0);    for (int i = 1; i &lt; n; ++i) &#123;        f[i] = f[i - 1] + triangle.get(i).get(i);        for (int j = i - 1; j &gt; 0; --j) &#123;            f[j] = Math.min(f[j - 1], f[j]) + triangle.get(i).get(j);        &#125;        f[0] += triangle.get(i).get(0);    &#125;    int minTotal = f[0];    for (int i = 1; i &lt; n; ++i) &#123;        minTotal = Math.min(minTotal, f[i]);    &#125;    return minTotal;&#125;","categories":["数据结构与算法"],"tags":["leetcode","动态规划"]},{"title":"300. 最长递增子序列","url":"/java4u/2021/06/22/300.%20%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","content":"300. 最长递增子序列给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。\n示例 1：\n输入：nums &#x3D; [10,9,2,5,3,7,101,18]输出：4解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n示例 2：\n输入：nums &#x3D; [0,1,0,3,2,3]输出：4\n示例 3：\n输入：nums &#x3D; [7,7,7,7,7,7,7]输出：1\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 2500-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104\n进阶：\n你能将算法的时间复杂度降低到 O(n log(n)) 吗?\n题解/** * 定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度， * 注意 nums[i] 必须被选取。 * 被选中的nums[i]可能大于等于或小于前面的数 * 即以nums[i]结尾的最长序列是由前面子集最优解推算出来 * * 我们从小到大计算 dp 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值，则状态转移方程为： * dp[i]=max(dp[j])+1,其中0≤j&lt;i且num[j]&lt;num[i] * 即考虑往 dp[0…i−1] 中最长的上升子序列后面再加一个 nums[i]。 * 由于 dp[j] 代表 nums[0…j] 中以 nums[j] 结尾的最长上升子序列， * 所以如果能从 dp[j] 这个状态转移过来，那么 nums[i] 必然要大于 nums[j]， * 才能将 nums[i] 放在 nums[j] 后面以形成更长的上升子序列。 * * 最后，整个数组的最长上升子序列即所有 dp[i] 中的最大值。 * LISlength=max(dp[i]),其中0≤i&lt;n * * @param nums * @return */public int lengthOfLIS(int[] nums) &#123;    if (nums.length == 0) &#123;        return 0;    &#125;    int[] dp = new int[nums.length];    dp[0] = 1;    int maxans = 1;    for (int i = 1; i &lt; nums.length; i++) &#123;        dp[i] = 1;        //dp[i]的值由之前dp[j](0&lt;j&lt;i)得到        //只要当nums[i]&gt;nums[j]时，可以将i拼在序列后        //当nums[i]&lt;=nums[j]时，无法将i拼在序列后，        //不满足nums[i]被选中的条件，不考虑        for (int j = 0; j &lt; i; j++) &#123;            if (nums[i] &gt; nums[j]) &#123;                //dp[i]是dp[j]+1的最大值                dp[i] = Math.max(dp[i], dp[j] + 1);            &#125;        &#125;        maxans = Math.max(maxans, dp[i]);    &#125;    return maxans;&#125;","categories":["数据结构与算法"],"tags":["leetcode","动态规划"]},{"title":"53. 最大子数组和","url":"/java4u/2021/06/19/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","content":"53. 最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1：\n输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。示例 2：\n输入：nums &#x3D; [1]输出：1示例 3：\n输入：nums &#x3D; [5,4,-1,7,8]输出：23\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 105-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104\n进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n题解/** * dp[i]：表示以 nums[i] 结尾的连续子数组的最大和 * dp[n]表示当前最大子序和，他由dp[n-1]和nums[n]计算来 * dp[n]=dp[n-1]+nums[n] * 但如果dp[n-1]小于0，则当前结果还会变小 * 由于是连续的子序，我们需要判断是之前的dp[n-1]与当前数相加，还是 nums[n]独自成序 * 得到状态转移方程： * dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]) * 得到每个以nums[i]结尾的和，需要得到最大的和，需要遍历 * @param nums * @return */public int maxSubArray(int[] nums) &#123;    int max = Integer.MIN_VALUE;    int len = nums.length;    int[]dp = new int[len];    dp[0]=nums[0];    for (int i = 1; i &lt; len; i++) &#123;        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);    &#125;    for (int j = 0; j &lt; len; j++) &#123;        max = Math.max(max, dp[j]);    &#125;    return max;&#125;","categories":["数据结构与算法"],"tags":["leetcode","动态规划"]},{"title":"70. 爬楼梯","url":"/java4u/2021/06/19/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/","content":"70. 爬楼梯假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n示例 1：\n输入：n &#x3D; 2输出：2解释：有两种方法可以爬到楼顶。\n\n1 阶 + 1 阶\n2 阶\n\n示例 2：\n输入：n &#x3D; 3输出：3解释：有三种方法可以爬到楼顶。\n\n1 阶 + 1 阶 + 1 阶\n1 阶 + 2 阶\n2 阶 + 1 阶\n\n提示：\n1 &lt;&#x3D; n &lt;&#x3D; 45\n题解/**     * 我们用 f(x) 表示爬到第 x-1 级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，     * 所以我们可以列出如下式子：     * f(x)=f(x−1)+f(x−2)     * @param n     * @return     */    public int climbStairs(int n) &#123;        if(n&lt;2)return 1;        int[]dp=new int[n];        dp[0]=1;        dp[1]=2;        for(int i=2;i&lt;n;i++)&#123;            dp[i]=dp[i-1]+dp[i-2];        &#125;        return dp[n-1];    &#125;    /**     * f(x) 只和 f(x−1) 与 f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)     * @param n     * @return     */    public int climbStairs2(int n) &#123;        int first = 0, second = 0, third = 1;        for (int i = 1; i &lt;= n; ++i) &#123;            first = second;            second = third;            third = first + second;        &#125;        return third;    &#125;","categories":["数据结构与算法"],"tags":["leetcode","动态规划"]},{"title":"高频题","url":"/java4u/2021/06/18/0.%E9%AB%98%E9%A2%91%E9%A2%98/","content":"1.必须深入了解的知识点a. java集合数据结构b.jvm：gc、内存模型、堆分代1）jstat查看 gc实时执行情况  jstat -gc 12538 5000每5 秒一次显示进程号为 12538的 java进成的 GC情况 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT32256.0 2560.0  0.0   2463.4 106496.0 101729.1  175104.0   53176.1   53808.0 52602.9 6192.0 5861.0     11    0.260   2      0.114    0.37432256.0 2560.0  0.0   2463.4 106496.0 102152.2  175104.0   53176.1   53808.0 52602.9 6192.0 5861.0     11    0.260   2      0.114    0.37432256.0 2560.0  0.0   2463.4 106496.0 102152.2  175104.0   53176.1   53808.0 52602.9 6192.0 5861.0     11    0.260   2      0.114    0.37432256.0 2560.0  0.0   2463.4 106496.0 102217.7  175104.0   53176.1   53808.0 52602.9 6192.0 5861.0     11    0.260   2      0.114    0.37432256.0 2560.0  0.0   2463.4 106496.0 102217.7  175104.0   53176.1   53808.0 52602.9 6192.0 5861.0     11    0.260   2      0.114    0.374\nS0C年轻代中第一个survivor区的容量 (字节)S1C年轻代中第二个survivor区的容量 (字节)S0U年轻代中第一个survivor区目前已使用空间 (字节)S1U年轻代中第二个survivor区目前已使用空间 (字节)EC年轻代中Eden的容量 (字节)EU年轻代中Eden目前已使用空间 (字节)OCOld代的容量 (字节)OUOld代目前已使用空间 (字节)YGC从应用程序启动到采样时年轻代中gc次数YGCT从应用程序启动到采样时年轻代中gc所用时间(s)FGC从应用程序启动到采样时old代(全gc)gc次数FGCT从应用程序启动到采样时old代(全gc)gc所用时间(s)GCT从应用程序启动到采样时gc用的总时间(s)\n    jstat -gccapacity 2060    堆内存统计\n\n    2）使用  jmap -heap pid ，可以查看各个代的内存使用情况\n\nc. 多线程：volatile、java.util.concurrent包d. spring：启动、时间e. redis：分布式锁、lua保证原⼦性、集群redis支持的数据结构：\n\nBinary-safe strings.\n\nLists: collections of string elements sorted according to the order of insertion. They are basically linked lists.\n\nSets: collections of unique, unsorted string elements.\n\nSorted sets, similar to Sets but where every string element is associated to a floating number value, called score. The elements are always taken sorted by their score, so unlike Sets it is possible to retrieve a range of elements (for example you may ask: give me the top 10, or the bottom 10).\n\nHashes, which are maps composed of fields associated with values. Both the field and the value are strings. This is very similar to Ruby or Python hashes.\n\nRedis实现分布式锁Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。\n当且仅当 key 不存在，将 key 的值设为 value。若给定的 key 已经存在，则 SETNX 不做任何动作\nSETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。\n返回值：设置成功，返回 1 。设置失败，返回 0 。\n\n使用SETNX完成同步锁的流程及事项如下：\n使用SETNX命令获取锁，若返回0（key已存在，锁已存在）则获取失败，反之获取成功\n为了防止获取锁后程序出现异常，导致其他线程&#x2F;进程调用SETNX命令总是返回0而进入死锁状态，需要为该key设置一个“合理”的过期时间\n释放锁，使用DEL命令将锁数据删除\n\n\nf. 消息队列：kafkag. Springcloudh. mysql搜索引擎，索引B+tree2. java基础：a. nio模型b. java反射c. java8特性d. java中有哪些集合？各⾃的数据结构？e. 说说你⽤过的设计模式​\t单例模式\n​\t模板模式\nf. jdk以及spring中看过哪些设计模式工厂模式：\n​\tJDK构造线程池\n​\tspring创建BEAN\n3. jvm：a. jvm结构，以及每⼀部分的作⽤b. jvm中哪些部分会出现oom，出现的可能原因\njava.lang.OutOfMemoryError: Java heap space ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。\njava.lang.OutOfMemoryError: PermGen space 或 java.lang.OutOfMemoryError：MetaSpace ——&gt;java方法区，（java8 元空间）溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize&#x3D;64m -XX:MaxPermSize&#x3D;256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。\njava.lang.StackOverflowError ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。\n\nc. 哪些对象会被存放到⽼年代？JVM - song.yan - 博客园 (cnblogs.com)\nd. 什么时候触发full gc？e. GC算法分类f. 类加载机制以及类加载器，双亲委派机制。g. ⼀个对象被实例化后，在堆中的流转流程（堆结构以及GC流程）h. jvm调优，写调优参数。4. spring：a. spring bean的⽣命周期b. 如何实现spring aop？c. springboot启动流程？d. Spring中BeanFactory和FactoryBean有什么区别，factorybean原理？e. spring事件f. 作⽤域spring，如果是request⽅式，a依赖b，a是单例⽅式，b是request，回怎么样5. 多线程：a. 乐观锁、悲观锁b. 三种分布式锁原理1）基于数据库实现分布式锁：\n要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。\n2）基于缓存（redis，memcached，tair）实现分布式锁3）基于Zookeeper实现分布式锁\nc. 线程池原理，java有哪⼏种线程池？如何创建？d. synchronized特性1）一个线程可以多次执行 synchronized ，重复获取同一把锁\nsynchronized 是可重入锁，每部锁对象中会有一个计数器记录线程获取几次锁啦，在执行完同步代码块时，计数器的数量会 -1，直到计数器的数量为0，就释放这个锁；\n2）不可中断是指，当一个线程获得锁后，另一个线程一直处于等待或阻塞状态，前一个线程不释放锁，后一个线程会一直阻塞或等待，不可被中断；\ne. volatile原理f. ThreadlocalThreadLocal的静态内部类ThreadLocalMap为每个Thread都维护了一个数组table，ThreadLocal确定了一个数组下标，而这个下标就是value存储的对应位置\n//set 方法public void set(T value) &#123;      //获取当前线程      Thread t = Thread.currentThread();      //实际存储的数据结构类型      ThreadLocalMap map = getMap(t);      //如果存在map就直接set，没有则创建map并set      if (map != null)          map.set(this, value);      else          createMap(t, value);  &#125;  //getMap方法ThreadLocalMap getMap(Thread t) &#123;      //thred中维护了一个ThreadLocalMap      return t.threadLocals; &#125; //createMapvoid createMap(Thread t, T firstValue) &#123;      //实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals      t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;\n\n//Entry为ThreadLocalMap静态内部类，对ThreadLocal的若引用//同时让ThreadLocal和储值形成key-value的关系static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;    /** The value associated with this ThreadLocal. */    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;           super(k);            value = v;    &#125;&#125;//ThreadLocalMap构造方法ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;        //内部成员数组，INITIAL_CAPACITY值为16的常量        table = new Entry[INITIAL_CAPACITY];        //位运算，结果与取模相同，计算出需要存放的位置        //threadLocalHashCode比较有趣        int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);        table[i] = new Entry(firstKey, firstValue);        size = 1;        setThreshold(INITIAL_CAPACITY);&#125;\n\nThreadLocalMap时创建了一个长度为16的Entry数组。通过hashCode与length位运算确定出一个索引值i，这个i就是被存储在table数组中的位置\ng. ConcurrentHashMap(3条消息) HashMap？ConcurrentHashMap？相信看完这篇没人能难住你！_Java团长的博客-CSDN博客\nh. HashMap为何线程不安全i. java.util.concurrent包下有哪些类？6. 数据结构：a. HashMap数据结构？b. ConcurrentHashMap数据结构（jdk1.7 &amp;1.8）？c. ⼆叉树、平衡树、红⿊树d. B-tree、B+treee. TreeMap(红黑树)7. 微服务：a. 画springcloud⼯作原理图b. 描述各个组件的作⽤及原理c. ⼼跳机制在应用启动后，节点们将会向Eureka Server发送心跳,默认周期为30秒，如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中把这个服务节点移除(默认90秒)。\nd. 限流⽅法：记术器：计算单元到时间内访问接口的次数，如果达到次数，则限制访问。\n令牌桶：令牌桶算法是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。可控制流量也可以控制并发量。\n漏桶：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃，总容量是不变的，但是输出的速率是固定的，无论你上面的流入的多快，下面的出口只有这么大，就像水坝开闸放水一样\ne. 服务熔断、降级与隔离的实现原理f. eureka优缺点g. dubbo的负载均衡⽅式8. 数据库：a. mysql存储引擎有哪些？他们的区别？b. 数据库隔离级别有哪些，并说下什么是脏读、不可重复读、幻读？c. 数据库事务的四⼤特性ACID？d. mysql调优⽅案？e. 在代码中，我们如何实现事务？f. 如果在⼀个事务中，代码业务流程很⻓，会有什么问题吗？为什么会出现这种问题？9. zookeeper：a. 选举算法b. 分布式锁实现原理、优缺点\n利用节点名称的唯一性来实现互斥锁\n\nZooKeeper抽象出来的节点结构是一个和unix文件系统类似的小型的树状的目录结构。ZooKeeper机制规定：同一个目录下只能有一个唯一的文件名。例如：我们在Zookeeper目录&#x2F;test目录下创建，两个客户端创建一个名为Lock节点，只有一个能够成功。\n算法思路: 利用名称唯一性，加锁操作时，只需要所有客户端一起创建&#x2F;test&#x2F;Lock节点，只有一个创建成功，成功者获得锁。解锁时，只需删除&#x2F;test&#x2F;Lock节点，其余客户端再次进入竞争创建节点，直到所有客户端都获得锁。由上述算法容易看出，由于客户端会同时收到&#x2F;test&#x2F;Lock被删除的通知，重新进入竞争创建节点，故存在”惊群现象”。\n\n利用临时顺序节点实现分布式锁的一般做法\n\n首先介绍一下，Zookeeper中有一种节点叫做顺序节点，故名思议，假如我们在&#x2F;lock&#x2F;目录下创建节3个点，ZooKeeper集群会按照提起创建的顺序来创建节点，节点分别为&#x2F;lock&#x2F;0000000001、&#x2F;lock&#x2F;0000000002、&#x2F;lock&#x2F;0000000003释放锁时，判断当前自己创建的节点是否是最小的节点，直至下次通知\n缺点：客户端无端的接受到过多的和自己不相关的事件通知\n\n利用临时顺序节点实现互斥锁的改进实现\n\n下面是改进后的分布式锁实现，和之前的实现方式唯一不同之处在于，这里设计成每个锁竞争者，只需要关注”locknode”节点下序号比自己小的那个节点是否存在即可。\n算法思路：对于加锁操作，可以让所有客户端都去&#x2F;lock目录下创建临时顺序节点，如果创建的客户端发现自身创建节点序列号是&#x2F;lock&#x2F;目录下最小的节点，则获得锁。否则，监视比自己创建节点的序列号小的节点（比自己创建的节点小的最大节点），进入等待\nc. 服务发现与移除原理Zookeeper的Watch机制\n客户端调用getData方法向服务器获取某个Znode节点的数据时，设置watch为true。服务端接到请求后，返回节点的数据，并在维护的WatchTable中插入被Watch的Znode路径以及Watcher（watch该Znode的客户端）；\n当被Watch的Znode被删除或者更新之后，Zookeeper服务器会查找Watch Table，找到在Znode上对应的所有Watcher，异步通知对应的客户端，并且删除Watch Table中对应的Key：Value\nZookeeper服务注册与发现流程浅析Zookeeper的服务注册与发现，主要应用的是Zookeeper的Znode数据模型和Watcher机制，主要分为如下几个步骤：\n服务注册：服务提供者（Provider）启动时，会向Zookeeper服务端注册服务信息，即会在Zookeeper服务器上创建一个服务节点，并在节点上存储服务的相关数据（如服务提供者的ip地址、端口等），比如注册一个用户注册服务（user&#x2F;register）:\n服务发现：服务消费者（Consumer）启动时，会根据本身依赖的服务信息，向Zookeeper服务端获取注册的服务信息并设置Watch，获取到注册的服务信息之后将服务提供者信息缓存在本地，调用服务时直接根据从Zookeeper注册中心获取到的服务注册信息调用服务，比如发现用户注册服务（user&#x2F;register）并调用。\n\n服务通知：当服务提供者因为某种原因宕机或不提供服务之后，Zookeeper服务注册中心的对应服务节点会被删除，因为服务消费者在获取服务信息的时候在对应节点上设置了Watch，因此节点删除之后会触发对应的Watcher，Zookeeper注册中心会异步向服务所关联的所有服务消费者发出节点删除的通知，服务消费者根据收到的通知更新缓存的服务列表。\n10. redis：a. 实现机制b. 分布式锁，以及要考虑的问题c. 除了加锁，如何使多个redis命令具有原⼦性（lua脚本）d. redis持久化的原理e. 分布式锁，使⽤redis的⽅式，但是redis是集群的，会有不同步的问题，官⽅⽂档是怎么解决的11. 消息中间件：a. 常⻅消息中间件的区别b. kafka的实现原理一个典型的kafka集群包含若干Producer（可以是应用节点产生的消息，也可以是通过Flume收集日志产生的事件），若干个Broker（kafka支持水平扩展）、若干个Consumer Group，以及一个zookeeper集群。kafka通过zookeeper管理集群配置及服务协同。Producer使用push模式将消息发布到broker，consumer通过监听使用pull模式从broker订阅并消费消息。\n\n1）Broker Kafka集群包含一个或多个服务器，这种服务器被称为broker。broker端不维护数据的消费状态，提升了性能。直接使用磁盘进行存储，线性读写，速度快：避免了数据在JVM内存和系统内存之间的复制，减少耗性能的创建对象和垃圾回收。 2）Producer 负责发布消息到Kafka broker 3）Consumer 消息消费者，向Kafka broker读取消息的客户端，consumer从broker拉取(pull)数据并进行处理。 4）Topic 每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处） 5）Partition Parition是物理上的概念，每个Topic包含一个或多个Partition. 6）Consumer Group 每个Consumer属于一个特定的Consumer Group（可为每个Consumer指定group name，若不指定group name则属于默认的group） 7）Topic &amp; Partition Topic在逻辑上可以被认为是一个queue，每条消费都必须指定它的Topic，可以简单理解为必须指明把这条消息放进哪个queue里。为了使得Kafka的吞吐率可以线性提高，物理上把Topic分成一个或多个Partition，每个Partition在物理上对应一个文件夹，该文件夹下存储这个Partition的所有消息和索引文件。若创建topic1和topic2两个topic，且分别有13个和19个分区，则整个集群上会相应会生成共32个文件夹（本文所用集群共8个节点，此处topic1和topic2 replication-factor均为1）。\nc. RabbitMQ消息模型1.基本消息模型 simple\n2.work消息模型 工作队列或者竞争消费者模式\n3.订阅模型（1）订阅模型-Fanout   广播（2）订阅模型-Direct:\n（3）订阅模型-Topic\nd. RabbitMQ如何保证消息可靠性\n从图上我们大概可以看出来一个消息会经历四个节点，只有保证这四个节点的可靠性才能保证整个系统的可靠性。\n1.生产者发出后保证到达了MQ。\n2.MQ收到消息保证分发到了消息对应的Exchange。\n3.Exchange分发消息入队之后保证消息的持久性。\n4.消费者收到消息之后保证消息的正确消费。\n🔍生产者发送消息到MQ失败RabbitMQ引入了事务机制和发送方确认机制（publisher confirm），由于事务机制过于耗费性能所以一般不用，这里我着重讲述发送方确认机制\n📔MQ接收失败或者路由失败\n消息找不到对应的Exchange。\n找到了Exchange但是找不到对应的Queue。\n\n这两种情况都可以用RabbitMQ提供的mandatory参数来解决，它会设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。\n我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)。\n📑消息入队之后MQ宕机消息的持久化要做，但是不能只做消息的持久化，还要做队列的持久化和Exchange的持久化。\n📌消费者无法正常消费打开手动消息确认之后，只要我们这条消息没有成功消费，无论中间是出现消费者宕机还是代码异常，只要连接断开之后这条信息还没有被消费那么这条消息就会被重新放入队列再次被消费\n💡消息可靠性案例\n12. 分布式：a. 介绍⼏种分布式事务，以及优缺点。2PC2PC（Two-phase commit protocol），中文叫二阶段提交。 二阶段提交是一种强一致性设计，2PC 引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段。\n\n2PC 是一种尽量保证强一致性的分布式事务，因此它是同步阻塞的，而同步阻塞就导致长久的资源锁定问题，总体而言效率低，并且存在单点故障问题，在极端条件下存在数据不一致的风险。\n3PC 3PC 相对于 2PC 做了一定的改进：引入了参与者超时机制，并且增加了预提交阶段使得故障恢复之后协调者的决策复杂度降低，但整体的交互过程更长了，性能有所下降，并且还是会存在数据不一致问题。\nTCCTCC 指的是Try - Confirm - Cancel。\n\nTry 指的是预留，即资源的预留和锁定，注意是预留。\nConfirm 指的是确认操作，这一步其实就是真正的执行了。\nCancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。\n\n本地消息表消息事务\nb. 分布式服务的原则，什么情况下要使⽤分布式开发。c. 使⽤⾃增ID和UUID作为主键有什么不同13. 源码：说说你看过的源码，其中有⽤到什么思想，以及设计模式？CSF调用：\n1.判断是否有本地配置配置文件中的服务返回结果，有直接返回结果\n2.校验操作员信息\n3.获取远程调用类Caller\n4.创建请求（存入入参，操作员信息，分页信息）\n5.由StubAdapter获取Client\n6.开始远程调用\n7.通过HystrixCommand开始调用\n熔断器相关配置\n&lt;CircuitBreaker&gt;   &lt;!-- 熔断器开关 --&gt;   &lt;Item name=&quot;enable&quot; value=&quot;false&quot; /&gt;   &lt;!-- 主机熔断时间窗口内请求失败率 --&gt;   &lt;Item name=&quot;host.error.threshold.percentage&quot; value=&quot;80&quot; /&gt;   &lt;!-- 服务熔断时间窗口请求失败率 --&gt;   &lt;Item name=&quot;service.error.threshold.percentage&quot; value=&quot;80&quot; /&gt;   &lt;!-- 熔断器统计时间窗口 --&gt;   &lt;Item name=&quot;statistics.window&quot; value=&quot;10000&quot; /&gt;   &lt;!-- 时间窗口内触发熔断请求次数开关 --&gt;   &lt;Item name=&quot;request.volume.threshold&quot; value=&quot;30&quot; /&gt;   &lt;!-- 是否开启线程池隔离模式 --&gt;   &lt;Item name=&quot;thread.isolation.enable&quot; value=&quot;true&quot; /&gt;&lt;/CircuitBreaker&gt;\n\n14.⽹络相关：a. tcp三次握⼿、四次挥⼿\n第一次握手：建立连接时，客户端发送syn包（syn&#x3D;j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n第二次握手：服务器收到syn包，必须确认客户的SYN（ack&#x3D;j+1），同时自己也发送一个SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；\n第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。\n\n1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。2）服务器收到连接释放报文，发出确认报文，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。5）客户端收到服务器的连接释放报文后，必须发出确认，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。\nb. http机制c. https机制15.项⽬亮点：16.画架构图：17.平时看过什么书？","categories":["面试"],"tags":["学习"]},{"title":"141. 环形链表","url":"/java4u/2021/06/18/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","content":"141. 环形链表给你一个链表的头节点 head ，判断链表中是否有环。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。\n如果链表中存在环 ，则返回 true 。 否则，返回 false 。\n示例 1：\n输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。\n示例 2：\n输入：head &#x3D; [1,2], pos &#x3D; 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。\n示例 3：\n输入：head &#x3D; [1], pos &#x3D; -1输出：false解释：链表中没有环。\n提示：\n链表中节点的数目范围是 [0, 10^4]-10^5 &lt;&#x3D; Node.val &lt;&#x3D; 10^5pos 为 -1 或者链表中的一个 有效索引 。\n进阶：你能用 O(1)（即，常量）内存解决此问题吗？\n题解/** * 使用快慢指针去遍历链表 * 快指针在慢指针前面的位置，移动快慢指针，判断两指针是否相遇 * @param head * @return */public boolean hasCycle(ListNode head) &#123;    if (head == null || head.next == null) &#123;        return false;    &#125;    ListNode slow = head;    ListNode fast = head.next;    //快慢指针在不同位置，就可以根据2指针是否相等来判断相遇    while (slow != fast) &#123;        if (fast == null || fast.next == null) &#123;            return false;        &#125;        slow = slow.next;        fast = fast.next.next;    &#125;    return true;&#125;/** * 哈希表 * HashSet不能添加重复的元素，当调用add（Object）方法时候， * 首先会调用Object的hashCode方法判hashCode是否已经存在，如不存在则直接插入元素； * 如果已存在则调用Object对象的equals方法判断是否返回true，如果为true则说明元素已经存在，如为false则插入元素。 * @param head * @return */public boolean hasCycle2(ListNode head) &#123;    Set&lt;ListNode&gt; seen = new HashSet&lt;ListNode&gt;();    while (head != null) &#123;        if (!seen.add(head)) &#123;            return true;        &#125;        head = head.next;    &#125;    return false;&#125;","categories":["数据结构与算法"],"tags":["leetcode","链表"]},{"title":"19.删除链表的倒数第 N 个结点","url":"/java4u/2021/06/17/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%20N%20%E4%B8%AA%E7%BB%93%E7%82%B9/","content":"19. 删除链表的倒数第 N 个结点给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例 1：\n输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2输出：[1,2,3,5]\n示例 2：\n输入：head &#x3D; [1], n &#x3D; 1输出：[]\n示例 3：\n输入：head &#x3D; [1,2], n &#x3D; 1输出：[1]\n提示：\n链表中结点的数目为 sz1 &lt;&#x3D; sz &lt;&#x3D; 300 &lt;&#x3D; Node.val &lt;&#x3D; 1001 &lt;&#x3D; n &lt;&#x3D; sz\n进阶：你能尝试使用一趟扫描实现吗？\n哨兵节点哨兵节点，其实就是一个附加在原链表最前面用来简化边界条件的附加节点，它的值域不存储任何东西，只是为了操作方便而引入。\n比如原链表为a-&gt;b-&gt;c，则加了哨兵节点的链表即为x-&gt;a-&gt;b&gt;c，\n那我们为什么需要引入哨兵节点呢?举个例子，比如我们要删除某链表的第一个元素，常见的删除链表的操作是找到要删元素的前一个元素，假如我们记为 pre。我们通过：\npre.Next &#x3D; pre.Next.Next来进行删除链表的操作。但是此时若是删除第一个元素的话，你就很难进行了，因为按道理来讲，此时第一个元素的前一个元素就是nil（空的），如果使用pre就会报错。那如果此时你设置了哨兵节点的话，此时的pre就是哨兵节点了。这样对于链表中的任何一个元素，你要删除都可以通过pre.Next&#x3D;pre.Next.Next的方式来进行，这就是哨兵节点的作用。\n\n题解/** * 首先我们定义好哨兵节点result，指向哨兵节点的目标元素指针cur，以及目标指针cur的前一个指针pre，此时pre指向nil。 * 接下来我们开始遍历整个链表。 * 当head移动到距离目标元素cur的距离为N-1时，同时开始移动cur。 * 当链表遍历完之后，此时head指向nil，这时的cur就是我们要找的待删除的目标元素。 * 最后我们通过pre.Next = pre.Next.Next完成删除操作，就完成了整个解题过程。 * @param head * @param n * @return */public ListNode removeNthFromEnd(ListNode head, int n) &#123;    //哨兵节点    ListNode result = new ListNode(0);    result.next = head;    //要被删除的节点    ListNode cur = result;    //被删除节点前一个节点    ListNode pre = null;    //先将head移动到距离cur为n-1的位置    for(int i =0;i&lt;n-1;i++)&#123;        head = head.next;    &#125;    //将cur和head节点同时后移，直到head指向链表节尾    while (head != null)&#123;        head = head.next;        pre = cur;        cur = cur.next;    &#125;    //此时cur就是要被删除的节点    pre.next = pre.next.next;    return result.next;&#125;","categories":["数据结构与算法"],"tags":["leetcode","链表"]},{"title":"21. 合并两个有序链表","url":"/java4u/2021/06/17/21.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","content":"21. 合并两个有序链表将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n示例 1：\n输入：l1 &#x3D; [1,2,4], l2 &#x3D; [1,3,4]输出：[1,1,2,3,4,4]\n示例 2：\n输入：l1 &#x3D; [], l2 &#x3D; []输出：[]\n示例 3：\n输入：l1 &#x3D; [], l2 &#x3D; [0]输出：[0]\n提示：\n两个链表的节点数目范围是 [0, 50]-100 &lt;&#x3D; Node.val &lt;&#x3D; 100l1 和 l2 均按 非递减顺序 排列\n题解/** * 取一个哨兵节点为初始节点，比较后面节点的大小，那个小，将小的节点放在哨兵节点后面 * @param l1 * @param l2 * @return */public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;    ListNode preHead = new ListNode(0);    ListNode cur = preHead;    int n1 = 0;    int n2 = 0;    while (l1 != null || l2 != null) &#123;        if(l1 == null)&#123;            preHead.next = l2;            break;        &#125;        if (l2 == null)&#123;            preHead.next = l1;            break;        &#125;        n1 = l1.val;        n2 = l2.val;        if(n1 &lt; n2)&#123;            preHead.next = new ListNode(n1);            l1 = l1.next;        &#125;else&#123;            preHead.next = new ListNode(n2);            l2 = l2.next;        &#125;        preHead = preHead.next;    &#125;    return cur.next;&#125;//不需要取出要拼接的节点数据去新建节点//直接将值大的节点拼接到当前节点//最后合并未合并完的节点即可public ListNode mergeTwoLists2(ListNode l1, ListNode l2) &#123;    ListNode prehead = new ListNode(-1);    ListNode prev = prehead;    while (l1 != null &amp;&amp; l2 != null) &#123;        if (l1.val &lt;= l2.val) &#123;            prev.next = l1;            l1 = l1.next;        &#125; else &#123;            prev.next = l2;            l2 = l2.next;        &#125;        prev = prev.next;    &#125;    // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可    prev.next = l1 == null ? l2 : l1;    return prehead.next;&#125;","categories":["数据结构与算法"],"tags":["leetcode","链表"]},{"title":"66. 加一","url":"/java4u/2021/06/10/66.%20%E5%8A%A0%E4%B8%80/","content":"66. 加一给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。\n最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n示例 1：\n输入：digits &#x3D; [1,2,3]输出：[1,2,4]解释：输入数组表示数字 123。\n示例 2：\n输入：digits &#x3D; [4,3,2,1]输出：[4,3,2,2]解释：输入数组表示数字 4321。\n示例 3：\n输入：digits &#x3D; [0]输出：[1]\n提示：\n1 &lt;&#x3D; digits.length &lt;&#x3D; 1000 &lt;&#x3D; digits[i] &lt;&#x3D; 9\n题解public int[] plusOne(int[] digits) &#123;    //溢出值    int y = 1;    int len = digits.length;    for (int i = len -1; i &gt;= 0; i--) &#123;        int cur = digits[i] + y;        if(y&gt;0)&#123;            y--;        &#125;        if(cur &gt;= 10)&#123;            digits[i] = 0;            y++;        &#125;else&#123;            digits[i] = cur;        &#125;    &#125;    if(y&gt;0)&#123;        int[] ret = new int[len+1];        System.arraycopy(ret,0,ret,1,len);        ret[0] = 1;        return ret;    &#125;else&#123;        return digits;    &#125;&#125;/** * 除 9 之外的数字加一； * 数字 9。 * 只有9、99等特殊数字需要进位 * @param digits * @return */public int[] plusOne2(int[] digits) &#123;    for (int i = digits.length - 1; i &gt;= 0; i--) &#123;        digits[i]++;        digits[i] = digits[i] % 10;        //没有发生进位的情况，直接返回数组   如 9+1=10    99+1=100        if (digits[i] != 0) return digits;    &#125;    //进位则直接新建数组    digits = new int[digits.length + 1];    digits[0] = 1;    return digits;&#125;","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"27. 移除元素","url":"/java4u/2021/06/09/27.%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","content":"27. 移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n&#x2F;&#x2F; nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len &#x3D; removeElement(nums, val);\n&#x2F;&#x2F; 在函数里修改输入数组对于调用者是可见的。&#x2F;&#x2F; 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i &#x3D; 0; i &lt; len; i++) {    print(nums[i]);}\n示例 1：\n输入：nums &#x3D; [3,2,2,3], val &#x3D; 3输出：2, nums &#x3D; [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums &#x3D; [2,2,3,3] 或 nums &#x3D; [2,2,0,0]，也会被视作正确答案。\n示例 2：\n输入：nums &#x3D; [0,1,2,2,3,0,4,2], val &#x3D; 2输出：5, nums &#x3D; [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n提示：\n0 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 500 &lt;&#x3D; val &lt;&#x3D; 100\n题解/**     * 双指针     * 思路及算法     *     * 由于题目要求删除数组中等于 val 的元素，因此输出数组的长度一定小于等于输入数组的长度，     * 我们可以把输出的数组直接写在输入数组上。可以使用双指针：     * 右指针 right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。     * 如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，     * 然后将左右指针同时右移；     * 如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。     * 整个过程保持不变的性质是：区间 [0,left) 中的元素都不等于 val。当左右指针遍历完输入数组以后，     * left 的值就是输出数组的长度。     * 这样的算法在最坏情况下（输入数组中没有元素等于 val），左右指针各遍历了数组一次。     *     * @param nums     * @param val     * @return     */    public int removeElement2(int[] nums, int val) &#123;        int n = nums.length;        int left = 0;        for (int right = 0; right &lt; n; right++) &#123;            if (nums[right] != val) &#123;                nums[left] = nums[right];                left++;            &#125;        &#125;        return left;    &#125;    /**     * 双指针优化     * 思路     *     * 如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5]，当 val 为 1 时，     * 我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。     * 实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，     * 同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。     * 实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。     *     * 算法     * 如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 left 的位置，     * 然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的     * 值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值     * 不等于 val 为止。     * 当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。     * 这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，     * 方法二避免了需要保留的元素的重复赋值操作。     *     * @param nums     * @param val     * @return     */    public int removeElement3(int[] nums, int val) &#123;        int left = 0;        int right = nums.length;        while (left &lt; right) &#123;            if (nums[left] == val) &#123;                nums[left] = nums[right - 1];                right--;            &#125; else &#123;                left++;            &#125;        &#125;        return left;    &#125;    /**     * 不通过     * @param nums     * @param val     * @return     */    public int removeElement(int[] nums, int val) &#123;        //结束位置        int e = nums.length;        for (int i = 0; i &lt; e; i++) &#123;            if(nums[i] == val)&#123;                System.arraycopy(nums,i+1,nums,i,nums.length-i-1);                e--;            &#125;        &#125;        return e;    &#125;","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"189. 轮转数组","url":"/java4u/2021/06/08/189.%20%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/","content":"189. 轮转数组给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n示例 1:\n输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3输出: [5,6,7,1,2,3,4]解释:向右轮转 1 步: [7,1,2,3,4,5,6]向右轮转 2 步: [6,7,1,2,3,4,5]向右轮转 3 步: [5,6,7,1,2,3,4]\n示例 2:\n输入：nums &#x3D; [-1,-100,3,99], k &#x3D; 2输出：[3,99,-1,-100]解释:向右轮转 1 步: [99,-1,-100,3]向右轮转 2 步: [3,99,-1,-100]\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 10^5-2^31 &lt;&#x3D; nums[i] &lt;&#x3D; 2^31 - 10 &lt;&#x3D; k &lt;&#x3D; 10^5\n进阶：\n尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？\n题解/**     * 使用额外的数组     * 我们可以使用额外的数组来将每个元素放至正确的位置。用 n 表示数组的长度，我们遍历原数组，     * 将原数组下标为 i 的元素放至新数组下标为 n(i+k)modn 的位置，最后将新数组拷贝至原数组即可。     *     * @param nums     * @param k     */    public void rotate2(int[] nums, int k) &#123;        int n = nums.length;        int[] newArr = new int[n];        for (int i = 0; i &lt; n; ++i) &#123;            newArr[(i + k) % n] = nums[i];        &#125;        System.arraycopy(newArr, 0, nums, 0, n);    &#125;    public void rotate(int[] nums, int k) &#123;        //反转数组        int len = nums.length;        int[] roNums = new int[len];        for (int i = 0; i &lt; len; i++) &#123;            roNums[i] = nums[len -i -1];        &#125;        //反转前k个数        for (int j = 0; j &lt; k; j++) &#123;            nums[j] = roNums[k - j - 1];        &#125;        //反转k位后面的几个数        for (int l = k; l &lt; len; l++) &#123;            nums[l] = roNums[len - l + k -1];        &#125;    &#125;    public void rotate3(int[] nums, int k) &#123;        k %= nums.length;        reverse(nums, 0, nums.length - 1);        reverse(nums, 0, k - 1);        reverse(nums, k, nums.length - 1);    &#125;    public void reverse(int[] nums, int start, int end) &#123;        while (start &lt; end) &#123;            int temp = nums[start];            nums[start] = nums[end];            nums[end] = temp;            start += 1;            end -= 1;        &#125;    &#125;    /**     * 环状替换     * 方法一中使用额外数组的原因在于如果我们直接将每个数字放至它最后的位置，这样被放置位置的元素会被覆盖从而丢失。     * 因此，从另一个角度，我们可以将被替换的元素保存在变量 temp 中，从而避免了额外数组的开销。     * 我们从位置 0 开始，最初令temp=nums[0]。根据规则，位置 0 的元素会放至 (0+k)modn 的位置，     * 令 x=(0+k)modn，此时交换 temp 和 nums[x]，完成位置 x 的更新。然后，我们考察位置 x，并交换 temp 和 nums[(x+k)modn]，     * 从而完成下一个位置的更新。不断进行上述过程，直至回到初始位置 0。     * 容易发现，当回到初始位置 0 时，有些数字可能还没有遍历到，此时我们应该从下一个数字开始重复的过程，可是这个时候怎么才算遍历结束呢？     * 我们不妨先考虑这样一个问题：从 0 开始不断遍历，最终回到起点 0 的过程中，我们遍历了多少个元素？     * 由于最终回到了起点，故该过程恰好走了整数数量的圈，不妨设为 a 圈；再设该过程总共遍历了 b 个元素。因此，我们有 an=bk，即 an 一定为 n,k 的公倍数。     * 又因为我们在第一次回到起点时就结束，因此 a 要尽可能小，故 an 就是 n,k 的最小公倍数 lcm(n,k)，因此 b 就为 lcm(n,k)/k。     * 这说明单次遍历会访问到 lcm(n,k)/k 个元素。为了访问到所有的元素，我们需要进行遍历的次数为 gcd(n,k)     * 其中gcd 指的是最大公约数。     *     * @param nums     * @param k     */    public void rotate4(int[] nums, int k) &#123;        int n = nums.length;        k = k % n;        int count = gcd(k, n);        for (int start = 0; start &lt; count; ++start) &#123;            int current = start;            int prev = nums[start];            do &#123;                int next = (current + k) % n;                int temp = nums[next];                nums[next] = prev;                prev = temp;                current = next;            &#125; while (start != current);        &#125;    &#125;    /**     * 取xy的最大公约数     * @param x   3     * @param y   7     * @return     */    public int gcd(int x, int y) &#123;        return y &gt; 0 ? gcd(y, x % y) : x;    &#125;","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"122. 买卖股票的最佳时机 II","url":"/java4u/2021/06/07/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/","content":"122. 买卖股票的最佳时机 II给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n返回 你能获得的 最大 利润 。\n示例 1：\n输入：prices &#x3D; [7,1,5,3,6,4]输出：7解释：在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6 - 3 &#x3D; 3 。     总利润为 4 + 3 &#x3D; 7 。\n示例 2：\n输入：prices &#x3D; [1,2,3,4,5]输出：4解释：在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5 - 1 &#x3D; 4 。     总利润为 4 。\n示例 3：\n输入：prices &#x3D; [7,6,4,3,1]输出：0解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。\n提示：\n1 &lt;&#x3D; prices.length &lt;&#x3D; 3 * 1040 &lt;&#x3D; prices[i] &lt;&#x3D; 104\n题解/** *考虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。 * 定义状态 dp[i][0] 表示第 i 天交易完后手里没有股票的最大利润， * dp[i][1] 表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。 * 考虑 dp[i][0] 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票， * 即 dp[i−1][0]，或者前一天结束的时候手里持有一支股票，即 dp[i−1][1]，这时候我们要将其卖出， * 并获得 prices[i] 的收益。因此为了收益最大化，我们列出如下的转移方程： * dp[i][0]=max&#123;dp[i−1][0],dp[i−1][1]+prices[i]&#125; * 再来考虑 dp[i][1]，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即dp[i−1][1]， * 或者前一天结束时还没有股票，即 dp[i−1][0]，这时候我们要将其买入，并减少 prices[i] 的收益。 * 可以列出如下的转移方程： * dp[i][1]=max&#123;dp[i−1][1],dp[i−1][0]−prices[i]&#125; * 对于初始状态，根据状态定义我们可以知道第 0 天交易结束的时候 dp[0][0]=0，dp[0][1]=−prices[0]。 * 因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益， * 因此这时候 dp[n−1][0] 的收益必然是大于 dp[n−1][1] 的，最后的答案即为 dp[n−1][0]。 * * @param prices * @return */public int maxProfit(int[] prices) &#123;    int n = prices.length;    int[][] dp = new int[n][2];    //没有股票最大利益    dp[0][0] = 0;    //有股票最大利益    dp[0][1] = -prices[0];    for (int i = 1; i &lt; n; ++i) &#123;        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);    &#125;    return dp[n - 1][0];&#125;/** * 贪心 * 计算一段时间的最大利润，即计算每个区间最大的贡献度，即取每个区间大于0的贡献度的加合 * @param prices * @return */public int maxProfit2(int[] prices)&#123;    int sum = 0;    for(int i= 1;i&lt;prices.length;i++)&#123;        sum += Math.max(prices[i]-prices[i-1], 0);    &#125;    return sum;&#125; ","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"350. 两个数组的交集 II","url":"/java4u/2021/06/03/350.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/","content":"350. 两个数组的交集 II给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n示例 1：\n输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2,2]\n示例 2:\n输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[4,9]\n提示：\n1 &lt;&#x3D; nums1.length, nums2.length &lt;&#x3D; 10000 &lt;&#x3D; nums1[i], nums2[i] &lt;&#x3D; 1000\n进阶：\n如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小，哪种方法更优？如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n题解/** * map映射 * 由于同一个数字在两个数组中都可能出现多次，因此需要用哈希表存储每个数字出现的次数。 * 对于一个数字，其在交集中出现的次数等于该数字在两个数组中出现次数的最小值。 * 首先遍历第一个数组，并在哈希表中记录第一个数组中的每个数字以及对应出现的次数， * 然后遍历第二个数组，对于第二个数组中的每个数字，如果在哈希表中存在这个数字，则将该数字添加到答案， * 并减少哈希表中该数字出现的次数。 * 为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。 * @param nums1 * @param nums2 * @return */public static int[] intersect(int[] nums1, int[] nums2) &#123;    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i : nums1) &#123;        if (!map.containsKey(i)) &#123;            map.put(i, 1);        &#125;else&#123;            map.put(i, map.get(i)+1);        &#125;    &#125;    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    for (int j : nums2) &#123;        if(map.containsKey(j))&#123;            Integer integer = map.get(j);            if(integer == 0)&#123;                map.remove(j);                continue;            &#125;            list.add(j);            map.put(j, map.get(j) - 1);        &#125;    &#125;    return list.stream().mapToInt(Integer::intValue).toArray();&#125;/** * 优化 * 1.先遍历短的数组求出现次数，在遍历长的数组求交集 * 2.map.getOrDefault() 根据key从map取值，没有得到默认值 * 3.Arrays.copyOfRange  使用System.arraycopy拷贝数组 * * @param nums1 * @param nums2 * @return */public int[] intersect2(int[] nums1, int[] nums2) &#123;    if (nums1.length &gt; nums2.length) &#123;        return intersect(nums2, nums1);    &#125;    Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();    for (int num : nums1) &#123;        int count = map.getOrDefault(num, 0) + 1;        map.put(num, count);    &#125;    int[] intersection = new int[nums1.length];    int index = 0;    for (int num : nums2) &#123;        int count = map.getOrDefault(num, 0);        if (count &gt; 0) &#123;            intersection[index++] = num;            count--;            if (count &gt; 0) &#123;                map.put(num, count);            &#125; else &#123;                map.remove(num);            &#125;        &#125;    &#125;    return Arrays.copyOfRange(intersection, 0, index);&#125;/** * 优化 排序好的数组 * 使用2个指针判断2个数组中的值，相等同时向后移 * 不相等，小的指针向后移 * @param nums1 * @param nums2 * @return */public int[] intersect3(int[] nums1, int[] nums2) &#123;    Arrays.sort(nums1);    Arrays.sort(nums2);    int len1 = nums1.length;    int len2 = nums2.length;    int[] res = new int[len1];    int i = 0;    int j = 0;    int index = 0;    while (i&lt;len1 &amp;&amp; j&lt;len2)&#123;        if(nums1[i]==nums2[j])&#123;            res[index++]=nums1[i];            i++;            j++;        &#125;else if(nums1[i] &lt; nums2[j])&#123;            i++;        &#125;else &#123;            j++;        &#125;    &#125;    return Arrays.copyOfRange(res, 0, index);&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"Dubbo","url":"/java4u/2021/05/15/dubbo/","content":"核心功能1)面向接口代理的高性能RPC调用:\n提供高性能的基于代理的远程调用能力，服务以接口为粒度，为开发者屏蔽远程调用底层细节。\n2)智能容错和负载均衡:\n内置多种负载均衡策略，智能感知下游节点健康状况，显著减少调用延迟，提高系统吞吐量。\n3)服务自动注册和发现:\n支持多种注册中心服务，服务实例上下线实时感知。\n4)高度可扩展能力:\n遵循微内核+插件的设计原则，所有核心能力如Protocol、Transport、Serialization被设计为扩展点，平等对待内置实现和第三方实现。\n5)运行期流量调度:\n内置条件、脚本等路由策略，通过配置不同的路由规则，轻松实现灰度发布，同机房优先等功能。\n6)可视化的服务治理与运维:\n提供丰富服务治理、运维工具：随时查询服务元数据、服务健康状态及调用统计，实时下发路由策略、调整配置参数。\n架构\n\n服务容器负责启动，加载，运行服务提供者。\n服务提供者在启动时，向注册中心注册自己提供的服务。\n服务消费者在启动时，向注册中心订阅自己所需的服务。\n注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n项目实例1user-rpc-service-api 项目：服务接口，定义 Dubbo Service API 接口，提供给消费者使用\n2user-rpc-service-provider 项目：服务提供者，实现 user-rpc-service-api 项目定义的 Dubbo Service API 接口，提供相应的服务\n3user-rpc-service-consumer 项目：服务消费者，会调用 user-rpc-service-provider 项目提供的 Dubbo Service 服务\n原理（1）读取配置将服务装载容器中，然后准备注册服务，dubbo先读配置文件解析服务\n1)dubbo标签的解析主要用到了DubboNamespaceHandler 这个类\n\n2）所有dubbo标签都统一使用DubboBeanDefinitionParser进行解析，将XML标签解析为BEAN对象。在初始化时将BEAN对象转换为url格式，进行不同协议的服务暴露和引用\n\n（2）serviceBean是何时暴露服务的服务提供者暴露一个服务的详细过程\n\n首先ServiceConfig类拿到对外提供服务的实际类ref(如：HelloWorldImpl),然后通过ProxyFactory类的getInvoker方法使用ref生成一个AbstractProxyInvoker实例，\n到这一步就完成具体服务到Invoker的转化。接下来就是Invoker转换到Exporter的过程。\nDubbo处理服务暴露的关键就在Invoker转换到Exporter的过程(如上图中的红色部分)，下面我们以Dubbo和RMI这两种典型协议的实现来进行说明：\nDubbo的实现：\nDubbo协议的Invoker转为Exporter发生在DubboProtocol类的export方法，它主要是打开socket侦听服务，并接收客户端发来的各种请求，通讯细节由Dubbo自己实现。\nRMI的实现：\nRMI协议的Invoker转为Exporter发生在RmiProtocol类的export方法，它通过Spring或Dubbo或JDK来实现RMI服务，通讯细节这一块由JDK底层来实现，这就省了不少工作量。\n服务消费者消费一个服务的详细过程\n首先ReferenceConfig类的init方法调用Protocol的refer方法生成Invoker实例(如上图中的红色部分)，这是服务消费的关键。\n接下来把Invoker转换为客户端需要的接口(如：HelloWorld)。\ndubbo工作流程\n\n服务提供者在启动的时候，会通过读取一些配置将服务实例化。\nProxy 封装服务调用接口，方便调用者调用。客户端获取 Proxy 时，可以像调用本地服务一样，调用远程服务。\nProxy 在封装时，需要调用 Protocol 定义协议格式，例如：Dubbo Protocol。\n将 Proxy 封装成 Invoker，它是真实服务调用的实例。\n将 Invoker 转化成 Exporter，Exporter 只是把 Invoker包装了一层，是为了在注册中心中暴露自己，方便消费者使用。\n将包装好的 Exporter 注册到注册中心。\n服务消费者建立好实例，会到服务注册中心订阅服务提供者的元数据。元数据包括服务 IP 和端口以及调用方式(Proxy)。\n消费者会通过获取的 Proxy 进行调用。通过服务提供方包装过程可以知道，Proxy 实际包装了 Invoker 实体，因此需要使用Invoker 进行调用。\n在 Invoker 调用之前，通过 Directory 获取服务提供者的 Invoker列表。在分布式的服务中有可能出现同一个服务，分布在不同的节点上。\n通过路由规则了解，服务需要从哪些节点获取。\nInvoker 调用过程中，通过 Cluster 进行容错，如果遇到失败策略进行重试。\n调用中，由于多个服务可能会分布到不同的节点，就要通过 LoadBalance 来实现负载均衡。\nInvoker 调用之前还需要经过 Filter，它是一个过滤链，用来处理上下文，限流和计数的工作。\n生成过滤以后的 Invoker。\n用 Client 进行数据传输。\nCodec 会根据 Protocol 定义的协议，进行协议的构造。\n构造完成的数据，通过序列化 Serialization 传输给服务提供者。\nRequest 已经到达了服务提供者，它会被分配到线程池(ThreadPool)中进行处理。\nServer 拿到请求以后查找对应的 Exporter(包含有 Invoker)。\n由于 Export 也会被 Filter 层层包裹\n通过 Filter 以后获得 Invoker\n最后，对服务提供者实体进行调用。\n\nRPC 工作原理\nRPC的设计由Client，Client stub，Network ，Server stub，Server构成。 其中Client就是用来调用服务的，Cient stub是用来把调用的方法和参数序列化的（因为要在网络中传输，必须要把对象转变成字节），Network用来传输这些信息到Server stub， Server stub用来把这些信息反序列化的，Server就是服务的提供者，最终调用的就是Server提供的方法。\nDubbo高级特性地址缓存注册中心挂了，服务是否可以正常访问？\n可以，dubbo服务消费者第一次调用时，会将服务提供方缓存到本地，以后调用时不会访问注册中心。当服务提供者地址发送变化时，注册中心才会通知消费者\n超时与重试调用服务时如果发送阻塞、等待的情况，消费者会一直等待在峰值时刻，大量请求同时请求消费者，而线程得不到释放，会造成线程的堆积dubbo利用超时机制来解决这个问题，自动断开超时的请求\n多版本使用version控制使用同一个接口的不同版本\n负载均衡dubbo提供4种负载均衡方式：\n\nRandom 根据权重随机\nRoundRobin 按权重轮询\nLeastActive 最少活跃调用数\nConsistentHash 一致性Hash,相同参数的请求发到同一个提供者\n\n集群容错集群容错模式：\n\nFailover Cluster 失败重试。出现失败时，重试其他服务器（一般用于读操作）\nFailfast Cluster 只发起一次调用（一般用写操作）\nFailsafe Cluster 出现异常直接忽略，返回空结果\nFailback Cluster 失败自动恢复，记录失败请求，定时重发\nForking Cluster 并行调用多个服务器，只要一个成功即返回\n\n服务降级mock&#x3D;”force:return null”  不再调用(停掉不重要的服务)mock&#x3D;”fail:return null” 失败之后返回null不报错\n","categories":["框架"],"tags":["学习","源码"]},{"title":"RPC","url":"/java4u/2021/04/23/RPC/","content":"RPC就是要像调用本地的函数一样去调远程函数\n1.Call ID映射。本地调用中，函数体是直接通过函数指针来指定的在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码\n2.序列化和反序列化。客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。\n3.网络传输。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西\n&#x2F;&#x2F; Client端&#x2F;&#x2F;    int l_times_r &#x3D; Call(ServerAddr, Multiply, lvalue, rvalue)\n\n将这个调用映射为Call ID。这里假设用最简单的字符串当Call ID的方法\n将Call ID，lvalue和rvalue序列化。可以直接将它们的值以二进制形式打包\n把2中得到的数据包发送给ServerAddr，这需要使用网络传输层\n等待服务器返回结果\n如果服务器调用成功，那么就将结果反序列化，并赋给l_times_r\n\n&#x2F;&#x2F; Server端\n\n在本地维护一个Call ID到函数指针的映射call_id_map，可以用std::map&lt;std::string, std::function&lt;&gt;&gt;\n等待请求\n得到一个请求后，将其数据包反序列化，得到Call ID\n通过在call_id_map中查找，得到相应的函数指针\n将lvalue和rvalue反序列化后，在本地调用Multiply函数，得到结果\n将结果序列化后通过网络返回给Client\n\nSCF调用方式：    callMap(svcName, data)\nIServiceOutput call(String svcName, BizVisit visit, Object datas, Paging page)\n\nIServiceOutput out = CallerProvider.getCaller(svcName).call(visit, datas, page, false);\n\nMap&lt;String, Object&gt; response = this.invokeService(this.createRequest(visit, data, page));\n\nIClientSV client = CsfServiceFactory.getService(this.getSvcName());\nMap&lt;String, Object&gt; result = (Map)client.service(param);\n\n获取返回值\n\n","categories":["分布式"],"tags":["RPC"]},{"title":"OAuth","url":"/java4u/2021/04/22/OAuth/","content":"OAuth是一个关于授权（authorization）的开放网络标准\n场景：拍的照片发给Google，云拍照需要用到Google上的照片，需要授权\n名词定义：\n\n第三方应用，”客户端“，即云拍照\nHTTP service: 服务提供商，即Google\nResource Owner:资源拥有者，即用户\nUser Agent:用户代理，即浏览器\nAuthorization server:认证服务器\nResource server:资源服务器\n\nOAuth思路：\n\n在客户端与服务提供商之间设置授权层，客户端不直接登陆服务提供商，只登陆授权层\n客户端登陆授权层所用的令牌，指定令牌的权限范围和有效期\n\n运行流程：\n\n（A）用户打开客户端以后，客户端要求用户给予授权。\n（B）用户同意给予客户端授权。\n（C）客户端使用上一步获得的授权，向认证服务器申请令牌。\n（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。\n（E）客户端使用令牌，向资源服务器申请获取资源。\n（F）资源服务器确认令牌无误，同意向客户端开放资源。\n\n客户端授权模式\n\n授权码模式\n简化模式\n密码模式\n客户端模式\n\n授权码模式：    通过客户端的后台服务器，与”服务提供商”的认证服务器进行互动\n\n（A）用户访问客户端，后者将前者导向认证服务器。\n（B）用户选择是否给予客户端授权。\n（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的”重定向URI”（redirection URI），  同时附上一个授权码。\n（D）客户端收到授权码，附上早先的”重定向URI”，向认证服务器申请令牌。  这一步是在客户端的后台的服务器上完成的，对用户不可见。\n（E）认证服务器核对了授权码和重定向URI，确认无误后，  向客户端发送访问令牌（access token）和更新令牌（refresh token）。\n\n","categories":["security"],"tags":["OAuth"]},{"title":"Z 字形变换","url":"/java4u/2021/02/01/6.%20Z%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","content":"6. Z 字形变换将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下：\nP   A   H   NA P L S I I GY   I   R\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”PAHNAPLSIIGYIR”。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例 1：\n输入：s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 3输出：”PAHNAPLSIIGYIR”\n示例 2：输入：s &#x3D; “PAYPALISHIRING”, numRows &#x3D; 4输出：”PINALSIGYAHRPI”解释：P     I    NA   L S  I GY A   H RP     I\n示例 3：\n输入：s &#x3D; “A”, numRows &#x3D; 1输出：”A”\n提示：\n1 &lt;&#x3D; s.length &lt;&#x3D; 1000s 由英文字母（小写和大写）、’,’ 和 ‘.’ 组成1 &lt;&#x3D; numRows &lt;&#x3D; 1000\n题解/** * 从左到右迭代字符，将Z型字符添加到它所在的行，在从上到下，合并各个行 * 行号上下限为 0~numRows-1 * 到达上下限，反向递增或递减 * L   C   I   R      list[0] * E T O E S I I G    list[1] * E   D   H   N      list[2] * * @param s * @param numRows * @return */public String convert2(String s, int numRows) &#123;    if (numRows &lt; 2) return s;    List&lt;StringBuilder&gt; rows = new ArrayList&lt;StringBuilder&gt;();    for (int i = 0; i &lt; numRows; i++) rows.add(new StringBuilder());    int i = 0, flag = -1;    for (char c : s.toCharArray()) &#123;        rows.get(i).append(c);        if (i == 0 || i == numRows - 1) flag = -flag;        i += flag;    &#125;    StringBuilder res = new StringBuilder();    for (StringBuilder row : rows) res.append(row);    return res.toString();&#125;","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"加密解码","url":"/java4u/2020/12/18/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/","content":"通过特定的算法，将数据明文加密成复杂的密文\n一。简介单项加密和双向加密。单项加密指通过对数据进行摘要计算生成密文，密文不可逆推还原，比如有Base64、MD5、SHA等\n单项加密使用场景\n用户密码保护:在保存用户密码时，不记录密码本身，只记录密码的MD5结果（即使数据库被盗也无法反推出明文）\n文件完整性校验：先在发送端计算一次文件的MD5，并把结果发送给接收端，接收端在接受文件后也计算一次MD5，两次结果一致文件完整。\n云盘秒传：云盘上传时计算MD5，并在自己的数据库中搜索一下 MD5是否存在，存在则使用已有的文件就可以了，从而实现云盘秒传。\n数字签名：发布程序时同时发布其MD5，下载后比较MD5是否相同，就可知道程序是否被篡改。\n\n双向加密则相反，指可以把密文逆推还原成明文，其中双向加密又分为对称加密和非对称加密。对称加密是指数据使用者必须拥有同样的密钥才可以进行加密解密，就像大家共同约定了一组暗号一样，对称加密的手段有DES、3DES、AES、IDEA、RC4、RC5等而非对称加密相对于对称加密而言，无需拥有同一组密钥，它是一种“信息公开的密钥交换协议”。非对称加密需要公开密钥和私有密钥两组密钥，公开密钥和私有密钥是配对起来的，也就是说使用公开密钥进行数据加密，只有对应的私有密钥才能进行解密。此类的加密手段有RSA、DSA等\n","categories":["加密解码"],"tags":["学习"]},{"title":"TPC/IP","url":"/java4u/2020/11/09/TCP%20IP/","content":"一 TCP&#x2F;IP模型TCP&#x2F;IP参考模型是一个抽象的分层模型，这个模型中，所有的TCP&#x2F;IP系列网络协议都归类到4个抽象的“层”中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务\n\n由上到下，层层包装\n\n应用层 http&#x2F;ftp协议\n传输层 TCP&#x2F;UDP协议 经过TCP层加上TCP首部，产生TCP段（segment）\n网络层 IP协议 TCP segment经过IP层再加上IP首部，产生IP数据包（datagram）\n链路层 未待传送数据加入以太网协议头 IP datagram通过链路层，经以太网驱动程序处理后，加上以太网首部+尾部，产生以太网帧（frame），以太网帧的长度在46~1500之间\n\n\n发送端发送数据时，数据层层封装发送给接收端。接收端收到数据后，要执行跟发送端相反的解封操作，把首尾部剥离，获取传递的原始数据\n二 数据链路层把网络层数据加头和尾，封装成帧，包含源MAC地址和目的MAC地址\n三 网络层1.1 以IP数据格式传输，地址标识就是IP地址\n1.2 TTL生存时间，穿过多少个路由后被抛弃\n2.ARP及RARP协议 根据IP地址获取MAC地址的协议\n3.ICMP协议 当传送IP数据包发生错误，ICMP会把错误信息封包传送回主机\n四 传输层 TCP&#x2F;UDP协议\n\n\n\nTCP\nUDP\n\n\n\n可靠性\n可靠\n不可靠\n\n\n连接性\n面向连接\n无连接\n\n\n报文\n面向字节流\n面向报文\n\n\n效率\n传输效率低\n传输效率高\n\n\n双工性\n全双工\n一对一&#x2F;一对多&#x2F;多对一&#x2F;多对多\n\n\n流量控制\n滑动窗口\n无\n\n\n拥塞控制\n慢开始&#x2F;拥塞避免\n快重传&#x2F;快恢复\n\n\n传输速度\n慢\n快\n\n\n应用场景\n对效率要求低\\对准确性要求高\n对效率要求高\n\n\n五 应用层每一个应用层（TCP&#x2F;IP参考模型的最高层）协议一般都会使用到两个传输层协议之一： 面向连接的TCP传输控制协议和无连接的包传输的UDP用户数据报文协议。 常用的应用层协议有：\n运行在TCP协议上的协议：\n\nHTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。\nHTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。\nFTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。\nPOP3（Post Office Protocol, version 3，邮局协议），收邮件用。\nSMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。\nTELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。\nSSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。\n\n运行在UDP协议上的协议：\n\nBOOTP（Boot Protocol，启动协议），应用于无盘设备。\nNTP（Network Time Protocol，网络时间协议），用于网络同步。\nDHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。\n\n其他：\n\nDNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。\nECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。\nSNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。\nARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。\n\n","categories":["网络"],"tags":["TPC/IP"]},{"title":"线程池","url":"/java4u/2020/10/27/%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"前言线程池是什么线程池（Thread Pool）是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。\n线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。这种做法，一方面避免了处理任务时创建销毁线程开销的代价，另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。\n使用线程池可以带来一系列好处：\n\n降低资源消耗：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。\n提高响应速度：任务到达时，无需等待线程创建即可立即执行。\n提高线程的可管理性：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。\n提供更多更强大的功能：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。\n\n二、线程池核心设计与实现2.1 总体设计ThreadPoolExecutor的UML类图\n\nThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。\nThreadPoolExecutor运行机制如下图所示：\n\n线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。\n2.2 生命周期管理线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\nctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：\n// Packing and unpacking ctlprivate static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;\n\n2.3 任务执行机制2.3.1 任务调度首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。其执行过程如下：\n\n首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。\n如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。\n如果workerCount &gt;&#x3D; corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。\n如果workerCount &gt;&#x3D; corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。\n如果workerCount &gt;&#x3D; maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。\n\n2.3.2 任务缓冲任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。\n阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。\n2.3.3 任务申请由上文的任务分配部分可知，任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。\n线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，其执行流程如下图所示：\n\ngetTask这部分进行了多次判断，为的是控制线程的数量，使其符合线程池的状态。如果线程池现在不应该持有那么多线程，则会返回null值。工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。\n2.3.4 任务拒绝任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。\n2.4 Worker线程管理2.4.1 Worker线程线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。我们来看一下它的部分代码：\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable&#123;        /** Thread this worker is running in.  Null if factory fails. */        final Thread thread;        /** Initial task to run.  Possibly null. */        Runnable firstTask;&#125;\n\nWorker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。Worker执行任务的模型如下图所示：\n\n线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。\n​Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。\n1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。\n在线程回收过程中就使用到了这种特性，回收过程如下图所示：\n\n2.4.2 Worker线程增加增加线程是通过线程池中的addWorker方法，该方法的功能就是增加一个线程，该方法不考虑线程池是在哪个阶段增加的该线程，这个分配线程的策略是在上个步骤完成的，该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。addWorker方法有两个参数：firstTask、core。firstTask参数用于指定新增的线程执行的第一个任务，该参数可以为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，其执行流程如下图所示：\n\n2.4.3 Worker线程回收线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。\ntry &#123;        while (task != null || (task = getTask()) != null) &#123;                //执行任务        &#125; finally &#123;            processWorkerExit(w, completedAbruptly);        &#125;&#125;\n\n线程回收的工作是在processWorkerExit方法完成的。事实上，在这个方法中，将线程引用移出线程池就已经结束了线程销毁的部分。但由于引起线程销毁的可能性有很多，线程池还要判断是什么引发了这次销毁，是否要改变线程池的现阶段状态，是否要根据新状态，重新分配线程。\n2.4.4 Worker线程执行任务在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：\n1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。\n执行流程如下图所示：\n\n","categories":["线程池"],"tags":["学习"]},{"title":"WSDL","url":"/java4u/2020/10/16/WSDL/","content":"WSDL（网络服务描述语言，Web Services Description Language）是一门基于 XML 的语言，用于描述 Web Services 以及如何对它们进行访问\n文档结构      web service 执行的操作       web service 使用的消息         web service 使用的数据类型       web service 使用的通信协议\n&lt;definitions&gt;\t&lt;types&gt;\t\tdefinition of types........\t&lt;/types&gt;\t&lt;message&gt;\t\tdefinition of a message....\t&lt;/message&gt;\t&lt;portType&gt;\t\tdefinition of a port.......\t&lt;/portType&gt;\t&lt;binding type=&quot;glossaryTerms&quot; name=&quot;b1&quot;&gt;      name 属性定义 binding 的名称，而 type 属性指向用于 binding 的端口，在这个例子中是 &quot;glossaryTerms&quot; 端口。\t&lt;soap:binding style=&quot;document&quot;\ttransport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt;    style 属性可取值 &quot;rpc&quot; 或 &quot;document&quot;。在这个例子中我们使用 document。transport 属性定义了要使用的 SOAP 协议。在这个例子中我们使用 HTTP。\t  &lt;operation&gt;\t\t&lt;soap:operation\t\t soapAction=&quot;http://example.com/getTerm&quot; /&gt;\t\t&lt;input&gt;\t\t  &lt;soap:body use=&quot;literal&quot; /&gt;\t\t&lt;/input&gt;\t\t&lt;output&gt;\t\t  &lt;soap:body use=&quot;literal&quot; /&gt;\t\t&lt;/output&gt;\t  &lt;/operation&gt;\t&lt;/binding&gt;&lt;/definitions&gt;\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;wsdl:definitions xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot; xmlns:tns=&quot;http://impl.cxf.aisino.com/&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; xmlns:ns2=&quot;http://cxf.apache.org/bindings/xformat&quot; xmlns:ns1=&quot;http://cxf.aisino.com/&quot; targetNamespace=&quot;http://impl.cxf.aisino.com/&quot; name=&quot;EInvWebServiceImplService&quot;&gt;\t&lt;wsdl:import namespace=&quot;http://cxf.aisino.com/&quot; location=&quot;http://222.190.120.106:10001/TestGome_SlProj/webService/eInvWS?wsdl=IEInvWebService.wsdl&quot;&gt; &lt;/wsdl:import&gt;\t\t&lt;wsdl:binding name=&quot;EInvWebServiceImplServiceSoapBinding&quot; type=&quot;ns1:IEInvWebService&quot;&gt;\t\t&lt;soap:binding transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; style=&quot;document&quot;/&gt;\t\t&lt;wsdl:operation name=&quot;gomeData&quot;&gt;\t\t\t&lt;soap:operation style=&quot;document&quot; soapAction=&quot;&quot;/&gt;\t\t\t&lt;wsdl:input name=&quot;gomeData&quot;&gt;\t\t\t\t&lt;soap:body use=&quot;literal&quot;/&gt;\t\t\t&lt;/wsdl:input&gt;\t\t\t&lt;wsdl:output name=&quot;gomeDataResponse&quot;&gt;\t\t\t\t&lt;soap:body use=&quot;literal&quot;/&gt;\t\t\t&lt;/wsdl:output&gt;\t\t&lt;/wsdl:operation&gt;\t&lt;/wsdl:binding&gt;\t\t&lt;wsdl:service name=&quot;EInvWebServiceImplService&quot;&gt;\t\t&lt;wsdl:port name=&quot;EInvWebServiceImplPort&quot; binding=&quot;tns:EInvWebServiceImplServiceSoapBinding&quot;&gt;\t\t\t&lt;soap:address location=&quot;http://222.190.120.106:10001/TestGome_SlProj/webService/eInvWS&quot;/&gt;\t\t&lt;/wsdl:port&gt;\t&lt;/wsdl:service&gt;&lt;/wsdl:definitions&gt;\n\n\n","categories":["webservice"],"tags":["WSDL"]},{"title":"14. 最长公共前缀","url":"/java4u/2020/10/12/14.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","content":"14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 “”。\n示例 1：\n输入：strs &#x3D; [“flower”,”flow”,”flight”]输出：”fl”\n示例 2：\n输入：strs &#x3D; [“dog”,”racecar”,”car”]输出：””解释：输入不存在公共前缀。\n提示：\n1 &lt;&#x3D; strs.length &lt;&#x3D; 2000 &lt;&#x3D; strs[i].length &lt;&#x3D; 200strs[i] 仅由小写英文字母组成\n题解/** * 横向比较 * @param strs * @return */public String longestCommonPrefix(String[] strs) &#123;    StringBuilder prefix = new StringBuilder(&quot;&quot;);    for (int i = 0; ; i++) &#123;        int j = 0;        if (j &gt; strs.length - 1 || i &gt; strs[j].length() - 1) break;        char ch = strs[j].charAt(i);        //j从第一个字符向最后一个字符移动        //判断字符是否都是一致的        //当j的长度和str.length一样说明完成遍历，字符都一样        while (j &lt;= strs.length - 1 &amp;&amp; i &lt;= strs[j].length() - 1 &amp;&amp; strs[j].charAt(i) == ch) &#123;            j++;        &#125;        if (j == strs.length) &#123;            prefix.append(ch);        &#125; else &#123;            break;        &#125;    &#125;    return prefix.toString();&#125;/** * 将首个字符串当作基准元素，与之后的字符进行比较 * 若后面的字符不全包含基准元素，则将基准元素末尾减1 * 直到全包含基准元素，则基准元素即为公共前缀 * @param strs * @return */public String longestCommonPrefix2(String[] strs) &#123;    if (strs.length == 0) return &quot;&quot;;    String prefix = strs[0];    for (int i = 1; i &lt; strs.length; i++)        while (strs[i].indexOf(prefix) != 0) &#123;            prefix = prefix.substring(0, prefix.length() - 1);            if (prefix.isEmpty()) return &quot;&quot;;        &#125;    return prefix;&#125;/** * 排序后比较头尾    不通过 * [&quot;abab&quot;,&quot;aba&quot;,&quot;abc&quot;]对于长度一样的场景会出现误判 * 且对于中间的字符都没有判断 * @param strs * @return */public String longestCommonPrefix3(String[] strs)&#123;    Arrays.sort(strs, Comparator.comparingInt(String::length));    int index = 0;    while (index &lt; strs[0].length()            &amp;&amp; (strs[0].charAt(index) == strs[strs.length-1].charAt(index)))&#123;        index++;    &#125;    return strs[0].substring(0,index);&#125;","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"2. 两数相加","url":"/java4u/2020/10/12/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","content":"2. 两数相加给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例 1：\n输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]输出：[7,0,8]解释：342 + 465 &#x3D; 807. \n示例 2：\n输入：l1 &#x3D; [0], l2 &#x3D; [0]输出：[0]\n示例 3：\n输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]输出：[8,9,9,9,0,0,0,1]\n提示：\n每个链表中的节点数在范围 [1, 100] 内0 &lt;&#x3D; Node.val &lt;&#x3D; 9题目数据保证列表表示的数字不含前导零\n题解//加法从最低位开始，遍历链表就是从表头开始进行计算public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;    //哨兵节点    ListNode dummyHead = new ListNode(0);    ListNode p = l1, q = l2, curr = dummyHead;    int carry = 0;    while (p != null || q != null) &#123;        int x = (p != null) ? p.val : 0;        int y = (q != null) ? q.val : 0;        int sum = carry + x + y;        carry = sum / 10;        curr.next = new ListNode(sum % 10);        curr = curr.next;        if (p != null) p = p.next;        if (q != null) q = q.next;    &#125;    if (carry &gt; 0) &#123;        curr.next = new ListNode(carry);    &#125;    return dummyHead.next;&#125;","categories":["数据结构与算法"],"tags":["leetcode","链表"]},{"title":"64. 最小路径和","url":"/java4u/2020/10/12/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","content":"64. 最小路径和给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明：每次只能向下或者向右移动一步。\n示例 1：\n输入：grid &#x3D; [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。\n示例 2：\n输入：grid &#x3D; [[1,2,3],[4,5,6]]输出：12\n提示：\nm &#x3D;&#x3D; grid.lengthn &#x3D;&#x3D; grid[i].length1 &lt;&#x3D; m, n &lt;&#x3D; 2000 &lt;&#x3D; grid[i][j] &lt;&#x3D; 100\n题解/**    * 1 3 1    * 1 5 1    * 4 2 1    * &lt;p&gt;    * 5的位置由 1-&gt;3-&gt;5 或 1-&gt;1-&gt;5移动而来    * 即 dp[i+1][j+1]=Math.min(dp[i+1][j],dp[i][j+1])+grid[i+1][j+1]    * @param grid    * @return    */   public int minPathSum(int[][] grid) &#123;       int m = grid.length;       int n = grid[0].length;       int[][] minPath = new int[m][n];       minPath[0][0] = grid[0][0];       int asum = minPath[0][0];       int bsum = minPath[0][0];       for (int a = 1; a &lt; n; a++) &#123;           asum += grid[0][a];           minPath[0][a] = asum;       &#125;       for (int b = 1; b &lt; m; b++) &#123;           bsum += grid[b][0];           minPath[b][0] = bsum;       &#125;       for (int i = 0; i &lt; m - 1; i++) &#123;           for (int j = 0; j &lt; n - 1; j++) &#123;               minPath[i + 1][j + 1] = grid[i + 1][j + 1] + Math.min(minPath[i + 1][j], minPath[i][j + 1]);           &#125;       &#125;       return minPath[m - 1][n - 1];   &#125;   //直接在入参的数组上进行计算   //不需要初始化和新建数组   public int minPathSum2(int[][] grid) &#123;       for (int i = 0; i &lt; grid.length; i++) &#123;           for (int j = 0; j &lt; grid[0].length; j++) &#123;               if (i == 0 &amp;&amp; j == 0) continue;               else if (i == 0) grid[i][j] = grid[i][j - 1] + grid[i][j];               else if (j == 0) grid[i][j] = grid[i - 1][j] + grid[i][j];               else grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];           &#125;       &#125;       return grid[grid.length - 1][grid[0].length - 1];   &#125;   /**    * 之前内存占用过多    * 其实遍历的grid之前的数据就不使用了    * 可以直接覆盖grid的数据    * 使用一维数组压缩    *    * @param grid    * @return    */   public int minPathSum3(int[][] grid) &#123;       int m = grid.length;       int n = grid[0].length;       int[] dp = new int[n];       dp[0] = grid[0][0];       for (int a = 1; a &lt; n; a++) &#123;           dp[a] = dp[a - 1] + grid[0][a];       &#125;       for (int i = 1; i &lt; m; i++) &#123;           for (int j = 0; j &lt; n; j++) &#123;               if (j == 0) &#123;                   dp[j] += grid[i][j];               &#125; else &#123;                   dp[j] = grid[i][j] + Math.min(dp[j], dp[j - 1]);               &#125;           &#125;       &#125;       return dp[n - 1];   &#125;","categories":["数据结构与算法"],"tags":["leetcode","动态规划"]},{"title":"15. 三数之和","url":"/java4u/2020/10/11/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"15. 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n示例 1：\n输入：nums &#x3D; [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]\n示例 2：\n输入：nums &#x3D; []输出：[]\n示例 3：\n输入：nums &#x3D; [0]输出：[]\n提示：\n0 &lt;&#x3D; nums.length &lt;&#x3D; 3000-10^5 &lt;&#x3D; nums[i] &lt;&#x3D; 10^5\n题解public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; threeList = new ArrayList&lt;&gt;();    if (nums.length &lt; 3) return threeList;    Arrays.sort(nums);    if (nums[0] &gt; 0 || nums[nums.length - 1] &lt; 0) return threeList;    for (int i = 0; i &lt; nums.length - 2; i++) &#123;//最后留2个数组合        if (nums[i] &gt; 0) break;//去除特殊情况        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;//去除重复情况        int l = i + 1;        int r = nums.length - 1;        while (l &lt; r) &#123;            if (nums[i] + nums[l] + nums[r] == 0) &#123;                threeList.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[l], nums[r])));                while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++;                while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--;                l++;                r--;                continue;            &#125;            if (nums[i] + nums[l] + nums[r] &lt; 0) &#123;                l++;                continue;            &#125;            if (nums[i] + nums[l] + nums[r] &gt; 0) &#123;                r--;                continue;            &#125;        &#125;    &#125;    return threeList;&#125;","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"1. 两数之和","url":"/java4u/2020/10/10/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","content":"1. 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。\n示例 1：\n输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。\n示例 2：\n输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2]示例 3：\n输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1]\n提示：2 &lt;&#x3D; nums.length &lt;&#x3D; 10^4-10^9 &lt;&#x3D; nums[i] &lt;&#x3D; 10^9-10^9 &lt;&#x3D; target &lt;&#x3D; 10^9只会存在一个有效答案\n进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n题解public int[] twoSum(int[] nums, int target) &#123;    int[] array = new int[2];    int length = nums.length;    if (length &lt; 2) return array;    for (int i = 0; i &lt; length - 1; i++) &#123;        for (int j = length - 1; j &gt; i; j--) &#123;            if ((nums[i] + nums[j]) == target) &#123;                array[0] = i;                array[1] = j;                return array;            &#125;        &#125;    &#125;    return array;&#125;//2遍hash，遍历数组，将值存入hashmap，第2次遍历数组时，查询map里是否有对应结果public int[] twoSum2(int[] nums, int target) &#123;    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; nums.length; i++) &#123;        map.put(nums[i], i);    &#125;    for (int i = 0; i &lt; nums.length; i++) &#123;        int complement = target - nums[i];        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;            return new int[]&#123;i, map.get(complement)&#125;;        &#125;    &#125;    throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125;//一遍hash，在遍历数组的同时，查询map里是否有对应值public int[] twoSum3(int[] nums, int target) &#123;    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; nums.length; i++) &#123;        int complement = target - nums[i];        if (map.containsKey(complement)) &#123;            return new int[]&#123;map.get(complement), i&#125;;        &#125;        map.put(nums[i], i);    &#125;    throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125;/** * 答案不正确 * 排序会打乱数组顺序 * 返回的数组位置已经是排序后的 * @param nums * @param target * @return */public int[] twoSum4(int[] nums, int target) &#123;    Arrays.sort(nums);    int l = 0;    int r = nums.length-1;    while (l&lt;r)&#123;        if(nums[l]+nums[r]==target)&#123;            return new int[]&#123;l,r&#125;;        &#125;else if(nums[l]+nums[r]&gt;target)&#123;            r--;        &#125;else&#123;            l++;        &#125;    &#125;    return new int[]&#123;&#125;;&#125;","categories":["数据结构与算法"],"tags":["leetcode","数组"]},{"title":"110. 平衡二叉树","url":"/java4u/2020/08/17/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"110. 平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。\n本题中，一棵高度平衡二叉树定义为：\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\n示例 1：\n输入：root &#x3D; [3,9,20,null,null,15,7]输出：true\n示例 2：\n输入：root &#x3D; [1,2,2,3,3,null,null,4,4]输出：false\n示例 3：\n输入：root &#x3D; []输出：true\n提示：\n树中的节点数在范围 [0, 5000] 内-10^4 &lt;&#x3D; Node.val &lt;&#x3D; 10^4\n题解/** * BFS遍历每层二叉树，记录最低和最高高度 * 遍历完比较高度（不行，还需要比较每棵树的高度） * @param root * @return */public boolean isBalanced(TreeNode root) &#123;    if (root == null) return true;    Queue&lt;TreeNode&gt; qu = new LinkedList&lt;TreeNode&gt;();    int minHigh = 1;    int maxHigh = 0;    int high = 1;    qu.offer(root);    while (!qu.isEmpty()) &#123;        TreeNode node = qu.poll();        if (node.left == null &amp;&amp; node.right == null) &#123;            minHigh = Math.min(high, minHigh);        &#125; else &#123;            //有子节点的情况,高度加一            if (node.left == null &amp;&amp; node.right != null) &#123;                minHigh = Math.min(high, minHigh);                qu.offer(node.right);            &#125;            if (node.left != null &amp;&amp; node.right == null) &#123;                minHigh = Math.min(high, minHigh);                qu.offer(node.left);            &#125;            if (node.right != null &amp;&amp; node.left != null) &#123;                qu.offer(node.right);                qu.offer(node.left);            &#125;            high++;        &#125;    &#125;    maxHigh = high;    return (maxHigh - minHigh) &lt; 2;&#125;/** * 自顶向下递归 * 判断每个节点高度，并判断节点是否平衡 * 节点高度： * height(p) =    0   p为空节点 * Max(height(p.left),height(p.right))+1   p不为空 * * @param root * @return */public boolean isBalanced2(TreeNode root) &#123;    if (root == null) &#123;        return true;    &#125; else &#123;        return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced2(root.left) &amp;&amp; isBalanced2(root.right);    &#125;&#125;public int height(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125; else &#123;        return Math.max(height(root.left), height(root.right)) + 1;    &#125;&#125;/** * 自底向上递归 * 先判断左右子树是否均衡，在判断当前根节点是否平衡 * * @param root * @return */public boolean isBalanced3(TreeNode root) &#123;    return height2(root) &gt;= 0;&#125;public int height2(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int leftHeight = height2(root.left);    int rightHeight = height2(root.right);    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;//只要高度差大于1，不平衡则返回-1        return -1;    &#125; else &#123;        return Math.max(leftHeight, rightHeight) + 1;    &#125;&#125;","categories":["数据结构与算法"],"tags":["leetcode","二叉树"]},{"title":"337. 打家劫舍 III","url":"/java4u/2020/08/10/337.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20III/","content":"337. 打家劫舍 III小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。\n除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。\n给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。\n示例 1:\n输入: root &#x3D; [3,2,3,null,3,null,1]输出: 7解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 &#x3D; 7\n示例 2:\n输入: root &#x3D; [3,4,5,1,3,null,1]输出: 9解释: 小偷一晚能够盗取的最高金额 4 + 5 &#x3D; 9\n提示：\n树的节点数在 [1, 10^4] 范围内0 &lt;&#x3D; Node.val &lt;&#x3D; 10^4\n题解/**     *    3     *  2   3     *   3    1     * 不通过  按层进行计算的时候，没有考虑父子节点无法同时选中的情况     * @param root     * @return     */    public int rob(TreeNode root) &#123;        if (root == null) return 0;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();        queue.offer(root);        int pre = 0;        int cur = root.val;        int temp;        while (!queue.isEmpty()) &#123;            int sum = 0;            TreeNode node = queue.poll();            if (node.left != null) &#123;                queue.offer(node.left);                sum += node.left.val;            &#125;            if (node.right != null) &#123;                queue.offer(node.right);                sum += node.right.val;            &#125;            temp = cur;            cur = Math.max(pre + sum, cur);            pre = temp;        &#125;        return cur;    &#125;    /**     * 递归     * 比较 爷+孙 与 父 节点的大小     * 不通过   树的节点数多的时候会超时     * @param root     * @return     */    public int rob2(TreeNode root) &#123;        if (root == null) return 0;        int money = root.val;        if (root.left != null) &#123;            money += (rob2(root.left.left) + rob2(root.left.right));        &#125;        if (root.right != null) &#123;            money += (rob2(root.right.left) + rob2(root.right.right));        &#125;        return Math.max(money, rob2(root.left) + rob2(root.right));    &#125;    /**     * 解决重复计算，使用map记录数据     *     * @param root     * @return     */    public int rob3(TreeNode root) &#123;        HashMap&lt;TreeNode, Integer&gt; memo = new HashMap&lt;&gt;();        return robInternal(root, memo);    &#125;    public int robInternal(TreeNode root, HashMap&lt;TreeNode, Integer&gt; memo) &#123;        if (root == null) return 0;        if (memo.containsKey(root)) return memo.get(root);        int money = root.val;        if (root.left != null) &#123;            money += (robInternal(root.left.left, memo) + robInternal(root.left.right, memo));        &#125;        if (root.right != null) &#123;            money += (robInternal(root.right.left, memo) + robInternal(root.right.right, memo));        &#125;        int result = Math.max(money, robInternal(root.left, memo) + robInternal(root.right, memo));        memo.put(root, result);        return result;    &#125;    /**     * 我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 0 代表不偷，1 代表偷     * 任何一个节点能偷到的最大钱的状态可以定义为     * 当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱     * 当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数     *     * @param root     * @return     */    public int rob4(TreeNode root) &#123;        int[] result = robInternal(root);        return Math.max(result[0], result[1]);    &#125;    public int[] robInternal(TreeNode root) &#123;        if (root == null) return new int[2];        int[] result = new int[2];        int[] left = robInternal(root.left);        int[] right = robInternal(root.right);        result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);        result[1] = left[0] + right[0] + root.val;        return result;    &#125;class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;","categories":["数据结构与算法"],"tags":["leetcode","动态规划"]},{"title":"213. 打家劫舍 II","url":"/java4u/2020/08/07/213.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%20II/","content":"213. 打家劫舍 II你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n示例 1：\n输入：nums &#x3D; [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 &#x3D; 2），然后偷窃 3 号房屋（金额 &#x3D; 2）, 因为他们是相邻的。\n示例 2：\n输入：nums &#x3D; [1,2,3,1]输出：4解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。\n示例 3：\n输入：nums &#x3D; [1,2,3]输出：3\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 1000\n题解/** * 围成圈，计算不包含第一间房间和不包含最后一间房间的最大值 * * @param nums * @return */public int rob(int[] nums) &#123;    int len = nums.length;    if (nums == null || len == 0) return 0;    if (len == 1) return nums[0];    int[] dp = new int[len];    return Math.max(myRob(Arrays.copyOfRange(nums, 0, len - 1)),            myRob(Arrays.copyOfRange(nums, 1, len)));&#125;private int myRob(int[] nums) &#123;    int len = nums.length;    if (nums == null || len == 0) return 0;    if (len == 1) return nums[0];    int[] dp = new int[len];    dp[0] = nums[0];    dp[1] = Math.max(nums[0], nums[1]);    if (len &gt; 2) &#123;        for (int i = 2; i &lt; len; i++) &#123;            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);        &#125;    &#125;    return dp[len - 1];&#125;","categories":["数据结构与算法"],"tags":["leetcode","动态规划"]},{"title":"198. 打家劫舍","url":"/java4u/2020/08/05/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","content":"198. 打家劫舍你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n示例 1：\n输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。\n示例 2：\n输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。\n提示：\n1 &lt;&#x3D; nums.length &lt;&#x3D; 1000 &lt;&#x3D; nums[i] &lt;&#x3D; 400\n题解//动态规划  dp表示偷到当前房屋获取到的最大值//由于不可以在相邻的房屋闯入，所以 至i房屋可盗窃的最大值，要么就是至 i-1 房屋可盗窃的最大值，//要么就是至 i-2 房屋可盗窃的最大值加上当前房屋的值，二者之间取最大值，即：//dp[i] = max(dp[i-2]+nums[i], dp[i-1])public static int rob(int[] nums) &#123;    int len = nums.length;    if (len == 0) return 0;    if (len == 1) return nums[0];    int[] dp = new int[len];    dp[0] = nums[0];    dp[1] = Math.max(nums[0], nums[1]);    for (int i = 2; i &lt; len; i++) &#123;        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);    &#125;    return dp[len - 1];&#125;/** * 滚动数组 * 当前最大金额与前2间房的最大金额有关，只记录前2间房金额 * * @param nums * @return */public int rob2(int[] nums) &#123;    if (nums == null || nums.length == 0) &#123;        return 0;    &#125;    int length = nums.length;    if (length == 1) &#123;        return nums[0];    &#125;    int first = nums[0], second = Math.max(nums[0], nums[1]);    for (int i = 2; i &lt; length; i++) &#123;        int temp = second;        second = Math.max(first + nums[i], second);        first = temp;    &#125;    return second;&#125;","categories":["数据结构与算法"],"tags":["leetcode","动态规划"]},{"title":"104. 二叉树的最大深度","url":"/java4u/2020/07/28/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","content":"104. 二叉树的最大深度给定一个二叉树，找出其最大深度。\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n示例：给定二叉树 [3,9,20,null,null,15,7]，\n  3 / \\9  20  /  \\ 15   7\n\n返回它的最大深度 3 。\n题解/** * 递归，比较左子树和右子树的深度，选择大的加上自身的深度1为最大深度 * 中止条件，没有子节点 * * 在递归中，如果层级过深，我们很可能保存过多的临时变量，导致栈溢出 * 函数调用的参数是通过栈空间来传递的，在调用过程中会占用线程的栈资源。 * 而递归调用，只有走到最后的结束点后函数才能依次退出，而未到达最后的结束点之前， * 占用的栈空间一直没有释放，如果递归调用次数过多，就可能导致占用的栈资源超过线程的最大值， * 从而导致栈溢出，导致程序的异常退出。 * 所以，我们引出下面的话题：如何将递归的代码转化成非递归的形式。 * 这里请记住，99%的递归转非递归，都可以通过栈来进行实现。 * * @param root * @return */public int maxDepth2(TreeNode root) &#123;    return root == null ? 0 : Math.max(maxDepth2(root.left), maxDepth2(root.right)) + 1;&#125;/** * 对二叉树进行DFS遍历，将数据存入栈代替递归 * 先存入右节点在存入左节点（先取出左节点在取出右节点） * @param root * @return */private List&lt;TreeNode&gt; traversal(TreeNode root) &#123;    List&lt;TreeNode&gt; res = new ArrayList&lt;&gt;();    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    stack.add(root);    while (!stack.empty()) &#123;        TreeNode node = stack.pop();        res.add(node);        if (node.right != null) &#123;            stack.push(node.right);        &#125;        if (node.left != null) &#123;            stack.push(node.left);        &#125;    &#125;    return res;&#125;/** * 非递归的DFS，通过栈实现 * 用栈同时存放节点与高度数据，取出节点时同时取出高度 * @param root * @return */public int maxDepth4(TreeNode root) &#123;    if (root == null) return 0;    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    Stack&lt;Integer&gt; level = new Stack&lt;&gt;();    int maxDepth = 0;    stack.push(root);    level.push(1);    while (!stack.isEmpty()) &#123;        //先取出左节点，同时取出节点高度，与最大高度比较        TreeNode node = stack.pop();        Integer temp = level.pop();        maxDepth = Math.max(maxDepth, temp);        if (node.right != null) &#123;            stack.push(node.right);            level.push(temp + 1);        &#125;        if (node.left != null) &#123;            stack.push(node.left);            level.push(temp + 1);        &#125;    &#125;    return maxDepth;&#125;/** * BFS，层层累加树的高度 * 在队首取出该层的节点 * 在队尾放入取出节点的相关节点 * 终止条件：队列取出所有节点 * * @param root * @return */public int maxDepth3(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();    queue.offer(root);    int ans = 0;    while (!queue.isEmpty()) &#123;        int size = queue.size();  //每一层的个数        while (size &gt; 0) &#123;            TreeNode node = queue.poll();            if (node.left != null) &#123;                queue.offer(node.left);            &#125;            if (node.right != null) &#123;                queue.offer(node.right);            &#125;            size--;        &#125;        ans++;    &#125;    return ans;&#125;","categories":["数据结构与算法"],"tags":["leetcode","二叉树"]},{"title":"3. 无重复字符的最长子串","url":"/java4u/2020/07/24/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","content":"3. 无重复字符的最长子串给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1:\n输入: s &#x3D; “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n示例 2:\n输入: s &#x3D; “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。\n示例 3:\n输入: s &#x3D; “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。\n提示：\n0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^4s 由英文字母、数字、符号和空格组成\n题解/** * 使用双指针记录窗口出现的最大值 * @param s * @return */public int lengthOfLongestSubstring(String s) &#123;    int n = s.length();    Set&lt;Character&gt; set = new HashSet&lt;&gt;();    int result = 0, i = 0, j = 0;    while (i &lt; n &amp;&amp; j &lt; n) &#123;        //charAt：返回指定位置处的字符        if (!set.contains(s.charAt(j))) &#123;            set.add(s.charAt(j));            j++;            result = Math.max(result, j - i);        &#125; else &#123;            set.remove(s.charAt(i));            i++;        &#125;    &#125;    return result;&#125;/** * 其实我们可以定义字符到索引的映射，而不是简单通过一个集合来判断字符是否存在。 * 这样的话，当我们找到重复的字符时，我们可以立即跳过该窗口，而不需要对之前的元素进行再次访问。 * @param s * @return */public static int lengthOfLongestSubstring3(String s) &#123;    int n = s.length(), result = 0;    Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();    for (int right = 0, left = 0; right &lt; n; right++) &#123;        if (map.containsKey(s.charAt(right))) &#123;            //出现重复的字符时，直接将左指针指向上次出现该重复字符的位置            //不需要对之前的元素进行访问            //左指针直接越过之前出现重复字符的位置            left = Math.max(map.get(s.charAt(right)), left);        &#125;        result = Math.max(result, right - left + 1);        map.put(s.charAt(right), right + 1);    &#125;    return result;&#125;/** * 我们可以使用一个256位的数组来替代hashmap，以进行优化。（因为ASCII码表里的字符总共有128个。 * ASCII码的长度是一个字节，8位，理论上可以表示256个字符，但是许多时候只谈128个） * @param s * @return */public int lengthOfLongestSubstring4(String s) &#123;    int n = s.length();    int result = 0;    //存放每个字符的位置    int[] charIndex = new int[256];    for (int left = 0, right = 0; right &lt; n; right++) &#123;        char c = s.charAt(right);        //当有字符重复，直接把左指针越过之前重复的位置（right + 1）        left = Math.max(charIndex[c], left);        result = Math.max(result, right - left + 1);        //存放位置与初始的0区分，并越过自己的位置        charIndex[c] = right + 1;    &#125;    return result;&#125;\n","categories":["数据结构与算法"],"tags":["leetcode","滑动窗口"]},{"title":"125. 验证回文串","url":"/java4u/2020/06/19/125.%20%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/","content":"125. 验证回文串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。\n说明：本题中，我们将空字符串定义为有效的回文串。\n示例 1:\n输入: “A man, a plan, a canal: Panama”输出: true解释：”amanaplanacanalpanama” 是回文串\n示例 2:\n输入: “race a car”输出: false解释：”raceacar” 不是回文串\n提示：\n1 &lt;&#x3D; s.length &lt;&#x3D; 2 * 10^5字符串 s 由 ASCII 字符组成\n题解//正则替换掉其余字符，在进行回文验证public boolean isPalindrome(String s)&#123;    char[] chars = s.toLowerCase()            .replaceAll(&quot;[^0-9a-z]&quot;, &quot;&quot;)            .toCharArray();    int i = 0;    int j = chars.length-1;    while (i&lt;j)&#123;        if(chars[i]!= chars[j])return false;        i++;        j--;    &#125;    return true;&#125;//循环时直接跳过不是字母或数字的字符//不需要正则去循环一次字符了public boolean isPalindrome2(String s) &#123;    char[] chars = s.toCharArray();    int length = s.length();    if (length &lt; 2) return true;    int l = 0;    int r = length - 1;    while (l &lt; r) &#123;        //isLetterOrDigit 确认字符是一个字母或数字        while (!Character.isLetterOrDigit(chars[l]) &amp;&amp; l &lt; r) l++;        while (!Character.isLetterOrDigit(chars[r]) &amp;&amp; l &lt; r) r--;        if (Character.toLowerCase(chars[l]) != Character.toLowerCase(chars[r]))            return false;        l++;        r--;    &#125;    return true;&#125;","categories":["数据结构与算法"],"tags":["leetcode","字符串"]}]